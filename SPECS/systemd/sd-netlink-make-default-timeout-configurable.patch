From 852b2023cdac611ae60ee3c0ce665708177f0e3a Mon Sep 17 00:00:00 2001
From: Yu Watanabe <watanabe.yu@gmail.com>
Date: Mon, 9 Oct 2023 12:53:31 +0000
Subject: [PATCH] systemd: sd-netlink - make the default timeout configurable

backport https://github.com/systemd/systemd/pull/29390
---
 src/libsystemd/sd-netlink/netlink-internal.h |  2 +
 src/libsystemd/sd-netlink/sd-netlink.c       | 53 +++++++++++---------
 2 files changed, 31 insertions(+), 24 deletions(-)

diff --git a/src/libsystemd/sd-netlink/netlink-internal.h b/src/libsystemd/sd-netlink/netlink-internal.h
index a53b802..1fa2120 100644
--- a/src/libsystemd/sd-netlink/netlink-internal.h
+++ b/src/libsystemd/sd-netlink/netlink-internal.h
@@ -10,6 +10,8 @@
 #include "prioq.h"
 #include "time-util.h"
 
+#define NETLINK_DEFAULT_TIMEOUT_USEC ((usec_t) (25 * USEC_PER_SEC))
+
 #define RTNL_DEFAULT_TIMEOUT ((usec_t) (25 * USEC_PER_SEC))
 
 #define RTNL_RQUEUE_MAX 64*1024
diff --git a/src/libsystemd/sd-netlink/sd-netlink.c b/src/libsystemd/sd-netlink/sd-netlink.c
index 167e160..f4910c0 100644
--- a/src/libsystemd/sd-netlink/sd-netlink.c
+++ b/src/libsystemd/sd-netlink/sd-netlink.c
@@ -327,7 +327,6 @@ static int process_timeout(sd_netlink *rtnl) {
                 return r;
 
         assert_se(prioq_pop(rtnl->reply_callbacks_prioq) == c);
-        c->timeout = 0;
         hashmap_remove(rtnl->reply_callbacks, UINT32_TO_PTR(c->serial));
 
         slot = container_of(c, sd_netlink_slot, reply_callback);
@@ -360,10 +359,8 @@ static int process_reply(sd_netlink *rtnl, sd_netlink_message *m) {
         if (!c)
                 return 0;
 
-        if (c->timeout != 0) {
+        if (c->timeout != USEC_INFINITY)
                 prioq_remove(rtnl->reply_callbacks_prioq, c, &c->prioq_idx);
-                c->timeout = 0;
-        }
 
         r = sd_netlink_message_get_type(m, &type);
         if (r < 0)
@@ -475,12 +472,28 @@ int sd_netlink_process(sd_netlink *rtnl, sd_netlink_message **ret) {
         return r;
 }
 
-static usec_t calc_elapse(uint64_t usec) {
-        if (usec == (uint64_t) -1)
-                return 0;
+static usec_t timespan_to_timestamp(usec_t usec) {
+        static bool default_timeout_set = false;
+        static usec_t default_timeout;
+        int r;
+
+        if (usec == 0) {
+                if (!default_timeout_set) {
+                        const char *e;
+
+                        default_timeout_set = true;
+                        default_timeout = NETLINK_DEFAULT_TIMEOUT_USEC;
+
+                        e = getenv("SYSTEMD_NETLINK_DEFAULT_TIMEOUT");
+                        if (e) {
+                                r = parse_sec(e, &default_timeout);
+                                if (r < 0)
+                                        log_debug_errno(r, "sd-netlink: Failed to parse $SYSTEMD_NETLINK_DEFAULT_TIMEOUT environment variable, ignoring: %m");
+                        }
+                }
 
-        if (usec == 0)
-                usec = RTNL_DEFAULT_TIMEOUT;
+                usec = default_timeout;
+        }
 
         return now(CLOCK_MONOTONIC) + usec;
 }
@@ -537,12 +550,6 @@ int sd_netlink_wait(sd_netlink *nl, uint64_t timeout_usec) {
 static int timeout_compare(const void *a, const void *b) {
         const struct reply_callback *x = a, *y = b;
 
-        if (x->timeout != 0 && y->timeout == 0)
-                return -1;
-
-        if (x->timeout == 0 && y->timeout != 0)
-                return 1;
-
         return CMP(x->timeout, y->timeout);
 }
 
@@ -570,18 +577,16 @@ int sd_netlink_call_async(
         if (r < 0)
                 return r;
 
-        if (usec != (uint64_t) -1) {
-                r = prioq_ensure_allocated(&nl->reply_callbacks_prioq, timeout_compare);
-                if (r < 0)
-                        return r;
-        }
+        r = prioq_ensure_allocated(&nl->reply_callbacks_prioq, timeout_compare);
+        if (r < 0)
+                return r;
 
         r = netlink_slot_allocate(nl, !ret_slot, NETLINK_REPLY_CALLBACK, sizeof(struct reply_callback), userdata, description, &slot);
         if (r < 0)
                 return r;
 
         slot->reply_callback.callback = callback;
-        slot->reply_callback.timeout = calc_elapse(usec);
+        slot->reply_callback.timeout = timespan_to_timestamp(usec);
 
         k = sd_netlink_send(nl, m, &slot->reply_callback.serial);
         if (k < 0)
@@ -591,7 +596,7 @@ int sd_netlink_call_async(
         if (r < 0)
                 return r;
 
-        if (slot->reply_callback.timeout != 0) {
+        if (slot->reply_callback.timeout != USEC_INFINITY) {
                 r = prioq_put(nl->reply_callbacks_prioq, &slot->reply_callback, &slot->reply_callback.prioq_idx);
                 if (r < 0) {
                         (void) hashmap_remove(nl->reply_callbacks, UINT32_TO_PTR(slot->reply_callback.serial));
@@ -626,7 +631,7 @@ int sd_netlink_call(sd_netlink *rtnl,
         if (r < 0)
                 return r;
 
-        timeout = calc_elapse(usec);
+        timeout = timespan_to_timestamp(usec);
 
         for (;;) {
                 usec_t left;
@@ -675,7 +680,7 @@ int sd_netlink_call(sd_netlink *rtnl,
                         /* received message, so try to process straight away */
                         continue;
 
-                if (timeout > 0) {
+                if (timeout != USEC_INFINITY) {
                         usec_t n;
 
                         n = now(CLOCK_MONOTONIC);
-- 
2.35.6

