From e39429d4e471a075cd7eaf8ddb23c8d887ee89f7 Mon Sep 17 00:00:00 2001
From: Joerie de Gram <j.de.gram@gmail.com>
Date: Wed, 2 Aug 2023 18:58:48 +0530
Subject: [PATCH] network: attempt to trigger kernel IPv6LL address generation

Try to ensure kernel IPv6 link local address generation occurs by
setting the per-if addr_gen_mode sysctl when the link is already up,
instead of the netlink interface (IFLA_INET6_ADDR_GEN_MODE).

The netlink setting is sufficient in cases where the interface is not
yet up when networkd configures an interface - bringing the interface
up will trigger in-kernel address generation.

If the interface is already up, yet the interface has no IPv6LL assigned
setting IFLA_INET6_ADDR_GEN_MODE has no effect.

Writing the addr_gen_mode sysctl is a best effort attempt at triggering
address generation regardless of interface state because it also works
in cases where the interface is already up.

Fixes https://github.com/systemd/systemd/issues/22424

[sshedi: ported fix to v247.x]
Signed-off-by: Shreenidhi Shedi <sshedi@vmware.com>
---
 src/network/networkd-link.c | 24 ++++++++++++++++++++++++
 1 file changed, 24 insertions(+)

diff --git a/src/network/networkd-link.c b/src/network/networkd-link.c
index 50a462f..51787f8 100644
--- a/src/network/networkd-link.c
+++ b/src/network/networkd-link.c
@@ -54,6 +54,7 @@
 #include "udev-util.h"
 #include "util.h"
 #include "vrf.h"
+#include "sysctl-util.h"

 bool link_ipv4ll_enabled(Link *link, AddressFamily mask) {
         assert(link);
@@ -1319,6 +1320,16 @@ static int link_address_genmode_handler(sd_netlink *rtnl, sd_netlink_message *m,
         return 1;
 }

+static int link_set_ipv6ll_addrgen_mode(Link *link, IPv6LinkLocalAddressGenMode mode) {
+        assert(link);
+        assert(mode >= 0 && mode < _IPV6_LINK_LOCAL_ADDRESS_GEN_MODE_MAX);
+
+        if (mode == link->network->ipv6ll_address_gen_mode)
+                return 0;
+
+        return sysctl_write_ip_property_uint32(AF_INET6, link->ifname, "addr_gen_mode", mode);
+}
+
 static int link_configure_addrgen_mode(Link *link) {
         _cleanup_(sd_netlink_message_unrefp) sd_netlink_message *req = NULL;
         uint8_t ipv6ll_mode;
@@ -1362,6 +1373,19 @@ static int link_configure_addrgen_mode(Link *link) {
         } else
                 ipv6ll_mode = link->network->ipv6ll_address_gen_mode;

+        /* If the link is already up, then changing the mode by netlink does not take effect until the
+         * link goes down. Hence, we need to reset the interface. However, setting the mode by sysctl
+         * does not need that. Let's use the sysctl interface when the link is already up.
+         * See also issue #22424. */
+        if (ipv6ll_mode != IPV6_LINK_LOCAL_ADDRESSS_GEN_MODE_NONE &&
+            FLAGS_SET(link->flags, IFF_UP)) {
+                r = link_set_ipv6ll_addrgen_mode(link, ipv6ll_mode);
+                if (r < 0)
+                        log_link_warning_errno(link, r, "Cannot set IPv6 address generation mode, ignoring: %m");
+
+                return 0;
+        }
+
         r = sd_netlink_message_append_u8(req, IFLA_INET6_ADDR_GEN_MODE, ipv6ll_mode);
         if (r < 0)
                 return log_link_error_errno(link, r, "Could not append IFLA_INET6_ADDR_GEN_MODE: %m");
--
2.41.0

