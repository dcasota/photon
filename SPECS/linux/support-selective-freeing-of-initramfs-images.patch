From fdb809cb3ff280807830aff695cfefc479a334b9 Mon Sep 17 00:00:00 2001
From: Him Kalyan Bordoloi <bordoloih@vmware.com>
Date: Wed, 15 Jan 2025 12:32:32 +0000
Subject: [PATCH] support selective freeing of initramfs images

If there is a mix of newc and newca images in initramfs,
we blindly retain the entire initramfs.
We track the start and end offsets of each individual newc image,
while combining adjacent images into larger blobs.
We can then free these newc encoded sections of the initramfs
Signed-off-by: Shivani Agarwal <shivani.agarwal@broadcom.com>
[Guru: Ported to kernel version 4.19.325]
Signed-off-by: Guruswamy Basavaiah <guruswamy.basavaiah@broadcom.com>
---
 init/initramfs.c | 68 ++++++++++++++++++++++++++++++++++++++++++++----
 1 file changed, 63 insertions(+), 5 deletions(-)

diff --git a/init/initramfs.c b/init/initramfs.c
index 694fc1e77..4b7c7219d 100644
--- a/init/initramfs.c
+++ b/init/initramfs.c
@@ -18,6 +18,16 @@ static int __initdata do_retain_initrd;

 static __initdata bool panic_on_initramfs_error = false;

+static __initdata bool end_of_image = false;
+
+static __initdata LIST_HEAD(initramfs_image_list);
+
+struct initramfs_image {
+	struct list_head list;
+	loff_t start_offset;
+	loff_t end_offset;
+};
+
 static int __init panic_on_initramfs_error_setup(char *__unused)
 {
 	panic_on_initramfs_error = true;
@@ -303,8 +313,7 @@ static int __init do_header(void)
 	}
 	if (memcmp(collected, "0707ca", 6)==0) {
 		if (!newca_found) {
-			printk(KERN_INFO "Page aligned format detected. Retain initrd.\n");
-			do_retain_initrd = 1;
+			printk(KERN_INFO "Page aligned format detected\n");
 			newca_found = 1;
 		}
 		page_aligned_fmt = true;
@@ -411,6 +420,7 @@ static int __init do_name(void)
 	}

 	if (strcmp(collected, "TRAILER!!!") == 0) {
+		end_of_image = true;
 		free_hash();
 		return 0;
 	}
@@ -542,6 +552,7 @@ static long __init flush_buffer(void *bufv, unsigned long len)
 static unsigned long my_inptr; /* index of next byte to be processed in inbuf */

 #include <linux/decompress/generic.h>
+extern unsigned long initrd_start;

 static char * __init unpack_to_rootfs(char *buf, unsigned long len)
 {
@@ -549,6 +560,7 @@ static char * __init unpack_to_rootfs(char *buf, unsigned long len)
 	decompress_fn decompress;
 	const char *compress_name;
 	static __initdata char msg_buf[64];
+	char *buf_start = buf;

 	header_buf = kmalloc(110, GFP_KERNEL);
 	symlink_buf = kmalloc(PATH_MAX + N_ALIGN(PATH_MAX) + 1, GFP_KERNEL);
@@ -567,13 +579,13 @@ static char * __init unpack_to_rootfs(char *buf, unsigned long len)
 			written = write_buffer(buf, len);
 			buf += written;
 			len -= written;
-			continue;
+			goto loopend;
 		}
 		if (!*buf) {
 			buf++;
 			len--;
 			this_header++;
-			continue;
+			goto loopend;
 		}
 		this_header = 0;
 		decompress = decompress_method(buf, len, &compress_name);
@@ -597,6 +609,43 @@ static char * __init unpack_to_rootfs(char *buf, unsigned long len)
 		this_header = saved_offset + my_inptr;
 		buf += my_inptr;
 		len -= my_inptr;
+	loopend:
+		if (end_of_image == true) {
+			struct initramfs_image *image = NULL;
+			static loff_t current_image_start_offset = 0;
+
+			end_of_image = false;
+
+			/* We don't need to track this image if:
+			 * it's not a bootloader supplied initramfs
+			 * retain_initrd parameter is set in cmdline
+			 * the image is in page aligned format
+			 */
+			if ((char *)initrd_start !=  buf_start)
+				continue;
+			if (do_retain_initrd)
+				continue;
+			if (page_aligned_fmt) {
+				current_image_start_offset = this_header;
+				continue;
+			}
+
+			/* Get last added image */
+			if (!list_empty(&initramfs_image_list))
+				image = list_last_entry(&initramfs_image_list, struct initramfs_image, list);
+
+			/* Check if we can avoid creating a new element by extending adjacent one */
+			if (!image || image->end_offset + 1 != current_image_start_offset) {
+				image = kmalloc(sizeof(struct initramfs_image), GFP_KERNEL);
+				if (!image)
+					panic("Can't allocate memory to track initramfs image");
+				image->start_offset = current_image_start_offset;
+				list_add_tail(&image->list, &initramfs_image_list);
+			}
+			image->end_offset = this_header - 1;
+			current_image_start_offset = this_header;
+		}
+
 	}
 	dir_utime();
 	kfree(name_buf);
@@ -645,7 +694,16 @@ static void __init free_initrd(void)
 			free_initrd_mem(crashk_end, initrd_end);
 	} else
 #endif
-		free_initrd_mem(initrd_start, initrd_end);
+		{
+		struct initramfs_image *image, *tmp;
+		list_for_each_entry_safe(image, tmp, &initramfs_image_list, list) {
+			free_initrd_mem(initrd_start + image->start_offset, initrd_start + image->end_offset);
+			list_del(&image->list);
+			kfree(image);
+		}
+
+	}
+
 skip:
 	initrd_start = 0;
 	initrd_end = 0;
--
2.39.4

