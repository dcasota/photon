From 404aed75c1bba183c46de4cf24581f8cc46b93b3 Mon Sep 17 00:00:00 2001
From: Srish Srinivasan <ssrish@vmware.com>
Date: Sun, 26 Nov 2023 07:01:43 +0000
Subject: [PATCH] crypto api return status prints for LKCM5 demo

---
 crypto/aead.c             | 36 +++++++++++++++++++++++++++++++++---
 crypto/ahash.c            | 24 +++++++++++++++++++++++-
 crypto/akcipher.c         |  7 ++++++-
 crypto/algif_ecc.c        | 36 ++++++++++++++++++++++++++++++++----
 crypto/kpp.c              |  7 ++++++-
 crypto/rng.c              | 21 ++++++++++++++++++---
 crypto/skcipher.c         | 28 ++++++++++++++++++++++++++--
 include/crypto/akcipher.h | 30 ++++++++++++++++++++++++++++--
 include/crypto/hash.h     |  6 ++++++
 include/crypto/kpp.h      | 18 ++++++++++++++++++
 include/crypto/rng.h      |  6 ++++++
 11 files changed, 202 insertions(+), 17 deletions(-)

diff --git a/crypto/aead.c b/crypto/aead.c
index 169910952..86135b6d1 100644
--- a/crypto/aead.c
+++ b/crypto/aead.c
@@ -51,6 +51,11 @@ int crypto_aead_setkey(struct crypto_aead *tfm,
 	else
 		err = crypto_aead_alg(tfm)->setkey(tfm, key, keylen);
 
+	if(err < 0)
+		printk(KERN_ERR "%s FAILED, returned %d", __func__, err);
+	else
+		printk(KERN_INFO "%s PASSED, returned %d", __func__, err);
+
 	if (unlikely(err)) {
 		crypto_aead_set_flags(tfm, CRYPTO_TFM_NEED_KEY);
 		return err;
@@ -66,16 +71,22 @@ int crypto_aead_setauthsize(struct crypto_aead *tfm, unsigned int authsize)
 	int err;
 
 	if ((!authsize && crypto_aead_maxauthsize(tfm)) ||
-	    authsize > crypto_aead_maxauthsize(tfm))
+	    authsize > crypto_aead_maxauthsize(tfm)) {
+		printk(KERN_ERR "%s FAILED, returned %d", __func__, -EINVAL);
 		return -EINVAL;
+	}
 
 	if (crypto_aead_alg(tfm)->setauthsize) {
 		err = crypto_aead_alg(tfm)->setauthsize(tfm, authsize);
-		if (err)
+		if (err) {
+			printk(KERN_ERR "%s FAILED, returned %d", __func__, err);
 			return err;
+		}
 	}
 
 	tfm->authsize = authsize;
+
+	printk(KERN_INFO "%s PASSED, returned %d", __func__, err);
 	return 0;
 }
 EXPORT_SYMBOL_GPL(crypto_aead_setauthsize);
@@ -92,7 +103,14 @@ int crypto_aead_encrypt(struct aead_request *req)
 		ret = -ENOKEY;
 	else
 		ret = crypto_aead_alg(aead)->encrypt(req);
+
+	if(ret < 0)
+		printk(KERN_ERR "%s FAILED, returned %d", __func__, ret);
+	else
+		printk(KERN_INFO "%s PASSED, returned %d", __func__, ret);
+
 	crypto_stats_aead_encrypt(cryptlen, alg, ret);
+
 	return ret;
 }
 EXPORT_SYMBOL_GPL(crypto_aead_encrypt);
@@ -111,7 +129,14 @@ int crypto_aead_decrypt(struct aead_request *req)
 		ret = -EINVAL;
 	else
 		ret = crypto_aead_alg(aead)->decrypt(req);
+
+	if(ret < 0)
+		printk(KERN_ERR "%s FAILED, returned %d", __func__, ret);
+	else
+		printk(KERN_INFO "%s PASSED, returned %d", __func__, ret);
+
 	crypto_stats_aead_decrypt(cryptlen, alg, ret);
+
 	return ret;
 }
 EXPORT_SYMBOL_GPL(crypto_aead_decrypt);
@@ -213,7 +238,12 @@ EXPORT_SYMBOL_GPL(crypto_grab_aead);
 
 struct crypto_aead *crypto_alloc_aead(const char *alg_name, u32 type, u32 mask)
 {
-	return crypto_alloc_tfm(alg_name, &crypto_aead_type, type, mask);
+	struct crypto_aead *handle = crypto_alloc_tfm(alg_name, &crypto_aead_type, type, mask);
+	if(IS_ERR(handle)) {
+		printk(KERN_ERR "%s FAILED, returned %d", __func__, PTR_ERR(handle));
+	}
+	printk(KERN_INFO "%s PASSED, cipher handle not null", __func__);
+	return handle;
 }
 EXPORT_SYMBOL_GPL(crypto_alloc_aead);
 
diff --git a/crypto/ahash.c b/crypto/ahash.c
index c2ca631a1..11f86b27c 100644
--- a/crypto/ahash.c
+++ b/crypto/ahash.c
@@ -180,6 +180,11 @@ int crypto_ahash_setkey(struct crypto_ahash *tfm, const u8 *key,
 	else
 		err = tfm->setkey(tfm, key, keylen);
 
+	if(err)
+		printk(KERN_ERR "%s FAILED, returned %d", __func__, err);
+	else
+		printk(KERN_INFO "%s PASSED, returned %d", __func__, err);
+
 	if (unlikely(err)) {
 		ahash_set_needkey(tfm);
 		return err;
@@ -347,6 +352,10 @@ int crypto_ahash_final(struct ahash_request *req)
 	crypto_stats_get(alg);
 	ret = crypto_ahash_op(req, crypto_ahash_reqtfm(req)->final);
 	crypto_stats_ahash_final(nbytes, ret, alg);
+	if(ret)
+		printk(KERN_ERR "%s FAILED, returned %d", __func__, ret);
+	else
+		printk(KERN_INFO "%s PASSED, returned %d", __func__, ret);
 	return ret;
 }
 EXPORT_SYMBOL_GPL(crypto_ahash_final);
@@ -361,6 +370,10 @@ int crypto_ahash_finup(struct ahash_request *req)
 	crypto_stats_get(alg);
 	ret = crypto_ahash_op(req, crypto_ahash_reqtfm(req)->finup);
 	crypto_stats_ahash_final(nbytes, ret, alg);
+	if(ret)
+		printk(KERN_ERR "%s FAILED, returned %d", __func__, ret);
+	else
+		printk(KERN_INFO "%s PASSED, returned %d", __func__, ret);
 	return ret;
 }
 EXPORT_SYMBOL_GPL(crypto_ahash_finup);
@@ -377,6 +390,10 @@ int crypto_ahash_digest(struct ahash_request *req)
 		ret = -ENOKEY;
 	else
 		ret = crypto_ahash_op(req, tfm->digest);
+	if(ret)
+		printk(KERN_ERR "%s FAILED, returned %d", __func__, ret);
+	else
+		printk(KERN_INFO "%s PASSED, returned %d", __func__, ret);
 	crypto_stats_ahash_final(nbytes, ret, alg);
 	return ret;
 }
@@ -555,7 +572,12 @@ EXPORT_SYMBOL_GPL(crypto_grab_ahash);
 struct crypto_ahash *crypto_alloc_ahash(const char *alg_name, u32 type,
 					u32 mask)
 {
-	return crypto_alloc_tfm(alg_name, &crypto_ahash_type, type, mask);
+	struct crypto_ahash *handle = crypto_alloc_tfm(alg_name, &crypto_ahash_type, type, mask);
+	if(IS_ERR(handle))
+		printk(KERN_ERR "%s FAILED, returned %d", __func__, PTR_ERR(handle));
+	else
+		printk(KERN_INFO "%s PASSED, cipher handle not null", __func__);
+	return handle;
 }
 EXPORT_SYMBOL_GPL(crypto_alloc_ahash);
 
diff --git a/crypto/akcipher.c b/crypto/akcipher.c
index ab975a420..abf87b4a5 100644
--- a/crypto/akcipher.c
+++ b/crypto/akcipher.c
@@ -102,7 +102,12 @@ EXPORT_SYMBOL_GPL(crypto_grab_akcipher);
 struct crypto_akcipher *crypto_alloc_akcipher(const char *alg_name, u32 type,
 					      u32 mask)
 {
-	return crypto_alloc_tfm(alg_name, &crypto_akcipher_type, type, mask);
+	struct crypto_akcipher *handle = crypto_alloc_tfm(alg_name, &crypto_akcipher_type, type, mask);
+	if(IS_ERR(handle))
+		printk(KERN_ERR "%s FAILED, returned %d", __func__, PTR_ERR(handle));
+	else
+		printk(KERN_INFO "%s PASSED, cipher handle not null", __func__);
+	return handle;
 }
 EXPORT_SYMBOL_GPL(crypto_alloc_akcipher);
 
diff --git a/crypto/algif_ecc.c b/crypto/algif_ecc.c
index 3135286ce..4782ec94e 100644
--- a/crypto/algif_ecc.c
+++ b/crypto/algif_ecc.c
@@ -152,9 +152,27 @@ static int ecc_recvmsg(struct socket *sock, struct msghdr *msg,
 	else if(iov[3].iov_len == 384) {
 		curve = &nist_p384;
 		curve_id = 3;
+	} else {
+		int skip_gen_privkey = 0;
+		switch(iov[3].iov_len) {
+			case 1:  break;
+			case 2:  skip_gen_privkey = 1;
+				 break;
+			default: return -EINVAL;
+		}
+
+		if(!skip_gen_privkey) {
+			ret = ecc_gen_privkey(2, 0, (u64 *)d_buf);
+			if (ret < 0)
+				printk(KERN_ERR "ecc_gen_privkey FAILED, returned %d", ret);
+			return ret;
+		}
+
+		ret = ecc_make_pub_key(2, 0, (u64 *)d_buf, pubkey);
+		if (ret < 0)
+			printk(KERN_ERR "ecc_make_pub_key FAILED, returned %d", ret);
+		return ret;
 	}
-	else
-		return -EINVAL;
 
         if (iov[0].iov_len != curve->g.ndigits * sizeof(u64) ||
             iov[1].iov_len != curve->g.ndigits * sizeof(u64) ||
@@ -162,12 +180,20 @@ static int ecc_recvmsg(struct socket *sock, struct msghdr *msg,
                 return -EINVAL;
 
         ret = ecc_gen_privkey(curve_id, curve->g.ndigits, (u64 *)d_buf);
-        if (ret < 0)
+        if (ret < 0) {
+		printk(KERN_ERR "ecc_gen_privkey FAILED, returned %d", ret);
                 return ret;
+	}
+	else
+		printk(KERN_INFO "ecc_gen_privkey PASSED, returned %d", ret);
 
         ret = ecc_make_pub_key(curve_id, curve->g.ndigits, (u64 *)d_buf, pubkey);
-        if (ret < 0)
+        if (ret < 0) {
+		printk(KERN_ERR "ecc_make_pub_key FAILED, returned %d", ret);
                 return ret;
+	}
+	else
+		printk(KERN_INFO "ecc_make_pub_key PASSED, returned %d", ret);
 
         ret = copy_to_user(iov[0].iov_base, d_buf, iov[0].iov_len);
         if (ret) {
@@ -219,8 +245,10 @@ static void *ecc_bind(const char *name, u32 type, u32 mask)
 	   !strcmp(name, "ecdh-nist-p384")  ||
 	   !strcmp(name, "ecdsa-nist-p256") ||
 	   !strcmp(name, "ecdsa-nist-p384")) {
+		printk(KERN_INFO "%s PASSED, returned %d", __func__, 0);
 		return 0;
 	}
+	printk(KERN_ERR "%s FAILED, returned %d", __func__, -EINVAL);
 	return -EINVAL;
 }
 
diff --git a/crypto/kpp.c b/crypto/kpp.c
index 313b2c699..16fb54228 100644
--- a/crypto/kpp.c
+++ b/crypto/kpp.c
@@ -83,7 +83,12 @@ static const struct crypto_type crypto_kpp_type = {
 
 struct crypto_kpp *crypto_alloc_kpp(const char *alg_name, u32 type, u32 mask)
 {
-	return crypto_alloc_tfm(alg_name, &crypto_kpp_type, type, mask);
+	struct crypto_kpp *handle = crypto_alloc_tfm(alg_name, &crypto_kpp_type, type, mask);
+	if(IS_ERR(handle))
+		printk(KERN_ERR "%s FAILED, returned %d", __func__, PTR_ERR(handle));
+	else
+		printk(KERN_INFO "%s PASSED, cipher handle not null", __func__);
+	return handle;
 }
 EXPORT_SYMBOL_GPL(crypto_alloc_kpp);
 
diff --git a/crypto/rng.c b/crypto/rng.c
index 353026522..e161565da 100644
--- a/crypto/rng.c
+++ b/crypto/rng.c
@@ -56,20 +56,30 @@ int crypto_rng_reset(struct crypto_rng *tfm, const u8 *seed, unsigned int slen)
 
 	if (!seed && slen) {
 		buf = kmalloc(slen, GFP_KERNEL);
-		if (!buf)
+		if (!buf) {
+			printk(KERN_ERR "%s FAILED, returned %d", __func__, -ENOMEM);
 			return -ENOMEM;
+		}
 		if (fips_enabled) {
 			err = get_jent_random_bytes(buf, slen);
 		} else {
 			err = get_random_bytes_wait(buf, slen);
 		}
-		if (err)
+		if (err) {
+			printk(KERN_ERR "%s FAILED, returned %d", __func__, err);
 			goto out;
+		}
 		seed = buf;
 	}
 
 	crypto_stats_get(alg);
 	err = crypto_rng_alg(tfm)->seed(tfm, seed, slen);
+
+	if(err)
+		printk(KERN_ERR "%s FAILED, returned %d", __func__, err);
+	else
+		printk(KERN_INFO "%s PASSED, returned %d", __func__, err);
+
 	crypto_stats_rng_seed(alg, err);
 out:
 	kfree_sensitive(buf);
@@ -132,7 +142,12 @@ static const struct crypto_type crypto_rng_type = {
 
 struct crypto_rng *crypto_alloc_rng(const char *alg_name, u32 type, u32 mask)
 {
-	return crypto_alloc_tfm(alg_name, &crypto_rng_type, type, mask);
+	struct crypto_rng *handle = crypto_alloc_tfm(alg_name, &crypto_rng_type, type, mask);
+	if(IS_ERR(handle))
+		printk(KERN_ERR "%s FAILED, returned %d", __func__, PTR_ERR(handle));
+	else
+		printk(KERN_INFO "%s PASSED, cipher handle not null", __func__);
+	return handle;
 }
 EXPORT_SYMBOL_GPL(crypto_alloc_rng);
 
diff --git a/crypto/skcipher.c b/crypto/skcipher.c
index b4dae640d..d89a6865e 100644
--- a/crypto/skcipher.c
+++ b/crypto/skcipher.c
@@ -603,14 +603,21 @@ int crypto_skcipher_setkey(struct crypto_skcipher *tfm, const u8 *key,
 	unsigned long alignmask = crypto_skcipher_alignmask(tfm);
 	int err;
 
-	if (keylen < cipher->min_keysize || keylen > cipher->max_keysize)
+	if (keylen < cipher->min_keysize || keylen > cipher->max_keysize) {
+		printk(KERN_ERR "%s FAILED, returned %d", __func__, -EINVAL);
 		return -EINVAL;
+	}
 
 	if ((unsigned long)key & alignmask)
 		err = skcipher_setkey_unaligned(tfm, key, keylen);
 	else
 		err = cipher->setkey(tfm, key, keylen);
 
+	if(err)
+		printk(KERN_ERR "%s FAILED, returned %d", __func__, err);
+	else
+		printk(KERN_INFO "%s PASSED, returned %d", __func__, err);
+
 	if (unlikely(err)) {
 		skcipher_set_needkey(tfm);
 		return err;
@@ -633,6 +640,12 @@ int crypto_skcipher_encrypt(struct skcipher_request *req)
 		ret = -ENOKEY;
 	else
 		ret = crypto_skcipher_alg(tfm)->encrypt(req);
+
+	if(ret)
+		printk(KERN_ERR "%s FAILED, returned %d", __func__, ret);
+	else
+		printk(KERN_INFO "%s PASSED, returned %d", __func__, ret);
+
 	crypto_stats_skcipher_encrypt(cryptlen, ret, alg);
 	return ret;
 }
@@ -650,6 +663,12 @@ int crypto_skcipher_decrypt(struct skcipher_request *req)
 		ret = -ENOKEY;
 	else
 		ret = crypto_skcipher_alg(tfm)->decrypt(req);
+
+	if(ret)
+		printk(KERN_ERR "%s FAILED, returned %d", __func__, ret);
+	else
+		printk(KERN_INFO "%s PASSED, returned %d", __func__, ret);
+
 	crypto_stats_skcipher_decrypt(cryptlen, ret, alg);
 	return ret;
 }
@@ -758,7 +777,12 @@ EXPORT_SYMBOL_GPL(crypto_grab_skcipher);
 struct crypto_skcipher *crypto_alloc_skcipher(const char *alg_name,
 					      u32 type, u32 mask)
 {
-	return crypto_alloc_tfm(alg_name, &crypto_skcipher_type, type, mask);
+	struct crypto_skcipher *handle = crypto_alloc_tfm(alg_name, &crypto_skcipher_type, type, mask);
+	if(IS_ERR(handle))
+		printk(KERN_ERR "%s FAILED, returned %d", __func__, PTR_ERR(handle));
+	else
+		printk(KERN_INFO "%s PASSED, cipher handle not null", __func__);
+	return handle;
 }
 EXPORT_SYMBOL_GPL(crypto_alloc_skcipher);
 
diff --git a/include/crypto/akcipher.h b/include/crypto/akcipher.h
index 5764b46bd..92aab12d9 100644
--- a/include/crypto/akcipher.h
+++ b/include/crypto/akcipher.h
@@ -342,6 +342,12 @@ static inline int crypto_akcipher_sign(struct akcipher_request *req)
 	crypto_stats_get(calg);
 	ret = alg->sign(req);
 	crypto_stats_akcipher_sign(ret, calg);
+
+	if(ret)
+		printk(KERN_ERR "%s FAILED, returned %d", __func__, ret);
+	else
+		printk(KERN_INFO "%s PASSED, returned %d", __func__, ret);
+
 	return ret;
 }
 
@@ -369,6 +375,12 @@ static inline int crypto_akcipher_verify(struct akcipher_request *req)
 	crypto_stats_get(calg);
 	ret = alg->verify(req);
 	crypto_stats_akcipher_verify(ret, calg);
+
+	if(ret)
+		printk(KERN_ERR "%s FAILED, returned %d", __func__, ret);
+	else
+		printk(KERN_INFO "%s PASSED, returned %d", __func__, ret);
+
 	return ret;
 }
 
@@ -391,7 +403,14 @@ static inline int crypto_akcipher_set_pub_key(struct crypto_akcipher *tfm,
 {
 	struct akcipher_alg *alg = crypto_akcipher_alg(tfm);
 
-	return alg->set_pub_key(tfm, key, keylen);
+	int ret = alg->set_pub_key(tfm, key, keylen);
+
+	if(ret)
+		printk(KERN_ERR "%s FAILED, returned %d", __func__, ret);
+	else
+		printk(KERN_INFO "%s PASSED, returned %d", __func__, ret);
+
+	return ret;
 }
 
 /**
@@ -413,6 +432,13 @@ static inline int crypto_akcipher_set_priv_key(struct crypto_akcipher *tfm,
 {
 	struct akcipher_alg *alg = crypto_akcipher_alg(tfm);
 
-	return alg->set_priv_key(tfm, key, keylen);
+	int ret = alg->set_priv_key(tfm, key, keylen);
+
+	if(ret)
+		printk(KERN_ERR "%s FAILED, returned %d", __func__, ret);
+	else
+		printk(KERN_INFO "%s PASSED, returned %d", __func__, ret);
+
+	return ret;
 }
 #endif
diff --git a/include/crypto/hash.h b/include/crypto/hash.h
index b2bc1e46e..8698b588d 100644
--- a/include/crypto/hash.h
+++ b/include/crypto/hash.h
@@ -556,6 +556,12 @@ static inline int crypto_ahash_update(struct ahash_request *req)
 	crypto_stats_get(alg);
 	ret = crypto_ahash_reqtfm(req)->update(req);
 	crypto_stats_ahash_update(nbytes, ret, alg);
+
+	if(ret)
+		printk(KERN_ERR "%s FAILED, returned %d", __func__, ret);
+	else
+		printk(KERN_INFO "%s PASSED, returned %d", __func__, ret);
+
 	return ret;
 }
 
diff --git a/include/crypto/kpp.h b/include/crypto/kpp.h
index cccceadc1..7022e4bea 100644
--- a/include/crypto/kpp.h
+++ b/include/crypto/kpp.h
@@ -290,6 +290,12 @@ static inline int crypto_kpp_set_secret(struct crypto_kpp *tfm,
 	crypto_stats_get(calg);
 	ret = alg->set_secret(tfm, buffer, len);
 	crypto_stats_kpp_set_secret(calg, ret);
+
+	if(ret)
+		printk(KERN_ERR "%s FAILED, returned %d", __func__, ret);
+	else
+		printk(KERN_INFO "%s PASSED, returned %d", __func__, ret);
+
 	return ret;
 }
 
@@ -316,6 +322,12 @@ static inline int crypto_kpp_generate_public_key(struct kpp_request *req)
 	crypto_stats_get(calg);
 	ret = alg->generate_public_key(req);
 	crypto_stats_kpp_generate_public_key(calg, ret);
+
+	if(ret)
+		printk(KERN_ERR "%s FAILED, returned %d", __func__, ret);
+	else
+		printk(KERN_INFO "%s PASSED, returned %d", __func__, ret);
+
 	return ret;
 }
 
@@ -339,6 +351,12 @@ static inline int crypto_kpp_compute_shared_secret(struct kpp_request *req)
 	crypto_stats_get(calg);
 	ret = alg->compute_shared_secret(req);
 	crypto_stats_kpp_compute_shared_secret(calg, ret);
+
+	if(ret)
+		printk(KERN_ERR "%s FAILED, returned %d", __func__, ret);
+	else
+		printk(KERN_INFO "%s PASSED, returned %d", __func__, ret);
+
 	return ret;
 }
 
diff --git a/include/crypto/rng.h b/include/crypto/rng.h
index 17bb3673d..a1fcfdea6 100644
--- a/include/crypto/rng.h
+++ b/include/crypto/rng.h
@@ -143,6 +143,12 @@ static inline int crypto_rng_generate(struct crypto_rng *tfm,
 	crypto_stats_get(alg);
 	ret = crypto_rng_alg(tfm)->generate(tfm, src, slen, dst, dlen);
 	crypto_stats_rng_generate(alg, dlen, ret);
+
+	if(ret)
+		printk(KERN_ERR "%s FAILED, returned %d", __func__, ret);
+	else
+		printk(KERN_INFO "%s PASSED, returned %d", __func__, ret);
+
 	return ret;
 }
 
-- 
2.35.6
