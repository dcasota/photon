From ea71c92640a871da306d555b588f42c8e5a90743 Mon Sep 17 00:00:00 2001
From: srinidhira0 <srinidhir@vmware.com>
Date: Tue, 8 Feb 2022 11:10:27 +0000
Subject: [PATCH] crypto: AF_ALG - add ECC support

The patch externalizes the ECC crypto API to user space. ECC domain does not
require cipher handler (such as ECDH for KPP) as ECC routines can be called
directly and there is no ECC cipher algo.

The following operations are supported:

 * Key generation. Return values are private key, public key in form of X and
   Y coordinates.
 * Key verification. It takes X and Y coordinates of a public key as an input
   and performs validation.

Since we need only 2 operations from ECC: to verify key and to generate
key, simply sendmsg/recvmsg API for this domain will be sufficient.

Enabling CONFIG_CRYPTO_USER_API_ECC is not recommended for production, but
it will not harm if enabled, as it does not expose used by kernel keys to
user space.

Added support for LKCM 5.0:

 * In LKCM 4.0 (kernel v5.10.x), nist_p256 was the only fips supported curve.
 * In kernel v6.1.x, there are two fips supported curves - nist_p256 and nist_p384
 * Tweaked ecc_sendmsg and ecc_recvmsg to accomodate both these curves while performing
   keyVer and keyGen respectively.
 * Also made some inclusions in ecc.h, ecc_curve_defs.h, ecdh.h, asymmetric-type.h and
   asymmetric-type.h to accomodate the nist_p384 curve.
 * Make allocation of cipher handle fail if a curve other than nist_p256 and nist_p384
   is sent from user-space.

Signed-off-by: Alexey Makhalov <amakhalov@vmware.com>
Signed-off-by: srinidhira0 <srinidhir@vmware.com>
Signed-off-by: Srish Srinivasan <ssrish@vmwae.com>
---
 crypto/Kconfig                 |   8 +
 crypto/Makefile                |   1 +
 crypto/algif_ecc.c             | 273 +++++++++++++++++++++++++++++++++
 crypto/ecc.h                   |  26 ++++
 crypto/ecc_curve_defs.h        |  49 ++++++
 include/crypto/ecdh.h          |   1 +
 include/keys/asymmetric-type.h |   6 +
 include/linux/oid_registry.h   |  10 +-
 8 files changed, 373 insertions(+), 1 deletion(-)
 create mode 100644 crypto/algif_ecc.c

diff --git a/crypto/Kconfig b/crypto/Kconfig
index 9f068f95cb32..2671bc52ea5c 100644
--- a/crypto/Kconfig
+++ b/crypto/Kconfig
@@ -1975,6 +1975,14 @@ config CRYPTO_USER_API_KPP
 	  primitives algorithms. This covers Diffie-Hellman and EC
 	  Diffie-Hellman.
 
+config CRYPTO_USER_API_ECC
+	tristate "User-space interface for ECC primitives algorithms"
+	depends on NET
+	select CRYPTO_USER_API
+	help
+	  This option enables the user-spaces interface for ECC
+	  primitives algorithms that are used in EC Diffie-Hellman.
+
 config CRYPTO_HASH_INFO
 	bool
 
diff --git a/crypto/Makefile b/crypto/Makefile
index 3ea05f3..38fd14e 100644
--- a/crypto/Makefile
+++ b/crypto/Makefile
@@ -154,6 +154,7 @@ obj-$(CONFIG_CRYPTO_USER_API_RNG) += algif_rng.o
 obj-$(CONFIG_CRYPTO_USER_API_AEAD) += algif_aead.o
 obj-$(CONFIG_CRYPTO_USER_API_AKCIPHER) += algif_akcipher.o
 obj-$(CONFIG_CRYPTO_USER_API_KPP) += algif_kpp.o
+obj-$(CONFIG_CRYPTO_USER_API_ECC) += algif_ecc.o
 obj-$(CONFIG_CRYPTO_ZSTD) += zstd.o
 obj-$(CONFIG_CRYPTO_OFB) += ofb.o
 obj-$(CONFIG_CRYPTO_ESSIV) += essiv.o
diff --git a/crypto/algif_ecc.c b/crypto/algif_ecc.c
new file mode 100644
index 000000000000..1f5defa98b5f
--- /dev/null
+++ b/crypto/algif_ecc.c
@@ -0,0 +1,273 @@
+/*
+ * algif_ecc: User-space interface for ECC routines
+ *
+ * Copyright (C) 2022, VMware Inc.
+ * Author: Alexey Makhalov <amakhalov@vmware.com>
+ *
+ * This file provides the user-space API for ECC routins for keyGen and keyVer
+ * ACVP testing.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * The following concept of the memory management is used:
+ *
+ * The kernel maintains two SGLs, the TX SGL and the RX SGL. The TX SGL is
+ * filled by user space with the data submitted via sendpage/sendmsg. Filling
+ * up the TX SGL does not cause a crypto operation -- the data will only be
+ * tracked by the kernel. Upon receipt of one recvmsg call, the caller must
+ * provide a buffer which is tracked with the RX SGL.
+ *
+ * During the processing of the recvmsg operation, the cipher request is
+ * allocated and prepared. As part of the recvmsg operation, the processed
+ * TX buffers are extracted from the TX SGL into a separate SGL.
+ *
+ * After the completion of the crypto operation, the RX SGL and the cipher
+ * request is released. The extracted TX SGL parts are released together with
+ * the RX SGL release.
+ */
+
+#include <crypto/if_alg.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/net.h>
+#include <net/sock.h>
+#include "ecc.h"
+#include "ecc_curve_defs.h"
+
+/*
+ * Sendmsg to ecc socket is used only to verify public key curve point.
+ * There are 2 input iov segments, one for x coordinate and another for y.
+ * On success, it returns number of bytes that were verified.
+ * Negative return value means failure. -EINVAL value get returned if
+ * key verification failed.
+ */
+
+static int ecc_sendmsg(struct socket *sock, struct msghdr *msg, size_t size)
+{
+	const struct iovec *iov;
+	int ret;
+	/* FIPS supported curves: nist_p256 and nist_p384 */
+	const struct ecc_curve *curve = NULL;
+	u8 x_buf[48] = {0}, y_buf[48] = {0}, hash_buf[64] = {0};
+	int curve_id = 0;
+
+	if (!iter_is_iovec(&msg->msg_iter))
+		return -ENOTSUPP;
+
+	if(msg->msg_iter.nr_segs == 3) {
+
+		iov = msg->msg_iter.iov;
+		struct ecc_point pk;
+
+		if(iov[2].iov_len == 256) {
+			curve = &nist_p256;
+			curve_id = 2;
+		}
+		if(iov[2].iov_len == 384) {
+			curve = &nist_p384;
+			curve_id = 3;
+		}
+		else
+			return -EINVAL;
+
+		if (iov[0].iov_len != curve->g.ndigits * sizeof(u64) ||
+	    		iov[1].iov_len != curve->g.ndigits * sizeof(u64))
+			return -EINVAL;
+
+		ret = copy_from_user(x_buf, iov[0].iov_base, iov[0].iov_len);
+		if (ret) {
+			pr_err("\n Error in copying X from iov_base %p %d\n",
+					iov[0].iov_base, ret);
+			return -ENOMEM;
+		}
+		ret = copy_from_user(y_buf, iov[1].iov_base, iov[1].iov_len);
+		if (ret) {
+			pr_err("\n Error in copying Y from iov_base %p %d\n",
+						iov[1].iov_base, ret);
+			return -ENOMEM;
+		}
+
+		pk.ndigits = curve->g.ndigits;
+		pk.x = kmalloc(pk.ndigits * sizeof(u64), GFP_KERNEL);
+		if (!pk.x)
+			return -ENOMEM;
+
+		pk.y = kmalloc(pk.ndigits * sizeof(u64), GFP_KERNEL);
+		if (!pk.y) {
+			kfree(pk.x);
+			return -ENOMEM;
+		}
+
+		ecc_swap_digits((u64 *)x_buf, pk.x, pk.ndigits);
+		ecc_swap_digits((u64 *)y_buf, pk.y, pk.ndigits);
+
+		ret = ecc_is_pubkey_valid_full(curve, &pk);
+
+
+		kfree(pk.x);
+		kfree(pk.y);
+		return ret;
+	}
+	else
+		return -EINVAL;
+}
+
+/*
+ * Recvmsg from ecc socket is used only to generate private/public key pair
+ * There are 3 output iov segments, one for private key and other two for x
+ * and y coordinates of the public key. Concatenation of bytes from these
+ * coordinates gives a public key.
+ * On success, it returns number of bytes that were provided.
+ * Negative return value means failure.
+ */
+static int ecc_recvmsg(struct socket *sock, struct msghdr *msg,
+			    size_t ignored, int flags)
+{
+        const struct iovec *iov;
+        u64 pubkey[12];
+        int ret;
+        /* FIPS supported curves: nist_p256 and nist_p384 */
+        struct ecc_curve *curve = NULL;
+        u8 d_buf[48] = {0};
+        int curve_id = 0;
+
+        if (!iter_is_iovec(&msg->msg_iter))
+                return -ENOTSUPP;
+
+        if (msg->msg_iter.nr_segs != 4)
+                return -EINVAL;
+
+        iov = msg->msg_iter.iov;
+
+	if(iov[3].iov_len == 256) {
+		curve = &nist_p256;
+		curve_id = 2;
+	}
+	else if(iov[3].iov_len == 384) {
+		curve = &nist_p384;
+		curve_id = 3;
+	}
+	else
+		return -EINVAL;
+
+        if (iov[0].iov_len != curve->g.ndigits * sizeof(u64) ||
+            iov[1].iov_len != curve->g.ndigits * sizeof(u64) ||
+            iov[2].iov_len != curve->g.ndigits * sizeof(u64))
+                return -EINVAL;
+
+        ret = ecc_gen_privkey(curve_id, curve->g.ndigits, (u64 *)d_buf);
+        if (ret < 0)
+                return ret;
+
+        ret = ecc_make_pub_key(curve_id, curve->g.ndigits, (u64 *)d_buf, pubkey);
+        if (ret < 0)
+                return ret;
+
+        ret = copy_to_user(iov[0].iov_base, d_buf, iov[0].iov_len);
+        if (ret) {
+                pr_err("\n Error in copying from iov_base %p %d\n",
+                                        iov[0].iov_base, ret);
+                return -ENOMEM;
+        }
+        ret = copy_to_user(iov[1].iov_base, pubkey,
+                                        curve->g.ndigits * sizeof(u64));
+        if (ret) {
+                pr_err("\n Err in copying to user %d\n", ret);
+                return -ENOMEM;
+        }
+        ret = copy_to_user(iov[2].iov_base, &pubkey[curve->g.ndigits],
+                                curve->g.ndigits * sizeof(u64));
+        if (ret) {
+                pr_err("\n Err in copying to user %d\n", ret);
+                return -ENOMEM;
+        }
+
+        return msg->msg_iter.count;
+}
+
+static struct proto_ops algif_ecc_ops = {
+	.family		=	PF_ALG,
+
+	.connect	=	sock_no_connect,
+	.socketpair	=	sock_no_socketpair,
+	.getname	=	sock_no_getname,
+	.ioctl		=	sock_no_ioctl,
+	.listen		=	sock_no_listen,
+	.shutdown	=	sock_no_shutdown,
+	.getsockopt	=	sock_getsockopt,
+	.mmap		=	sock_no_mmap,
+	.bind		=	sock_no_bind,
+	.accept		=	sock_no_accept,
+	.setsockopt	=	sock_setsockopt,
+
+	.release	=	af_alg_release,
+	.sendmsg	=	ecc_sendmsg,
+	.sendpage	=	af_alg_sendpage,
+	.recvmsg	=	ecc_recvmsg,
+	.poll		=	af_alg_poll,
+};
+
+static void *ecc_bind(const char *name, u32 type, u32 mask)
+{
+	if(!strcmp(name, "ecdh-nist-p256")  ||
+	   !strcmp(name, "ecdh-nist-p384")  ||
+	   !strcmp(name, "ecdsa-nist-p256") ||
+	   !strcmp(name, "ecdsa-nist-p384")) {
+		return 0;
+	}
+	return -EINVAL;
+}
+
+static void ecc_release(void *private)
+{
+}
+
+static void ecc_sock_destruct(struct sock *sk)
+{
+}
+
+static int ecc_accept_parent(void *private, struct sock *sk)
+{
+	sk->sk_destruct = ecc_sock_destruct;
+	return 0;
+}
+
+static const struct af_alg_type algif_type_ecc = {
+	.bind		=	ecc_bind,
+	.release	=	ecc_release,
+	.setkey		=	NULL,
+	.setpubkey	=	NULL,
+	.dhparams	=	NULL,
+	.ecdhcurve	=	NULL,
+	.setauthsize	=	NULL,
+	.accept		=	ecc_accept_parent,
+	.accept_nokey	=	NULL,
+	.ops		=	&algif_ecc_ops,
+	.ops_nokey	=	NULL,
+	.name		=	"ecc",
+	.owner		=	THIS_MODULE
+};
+
+static int __init algif_ecc_init(void)
+{
+	return af_alg_register_type(&algif_type_ecc);
+}
+
+static void __exit algif_ecc_exit(void)
+{
+	int err = af_alg_unregister_type(&algif_type_ecc);
+
+	BUG_ON(err);
+}
+
+module_init(algif_ecc_init);
+module_exit(algif_ecc_exit);
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Alexey Makhalov <amakhalov@vmware.com>");
+MODULE_DESCRIPTION("ECC primitives kernel crypto API user space interface");
diff --git a/crypto/ecc.h b/crypto/ecc.h
index d4e546b9a..a60b6bc35 100644
--- a/crypto/ecc.h
+++ b/crypto/ecc.h
@@ -29,10 +29,13 @@
 /* One digit is u64 qword. */
 #define ECC_CURVE_NIST_P192_DIGITS  3
 #define ECC_CURVE_NIST_P256_DIGITS  4
+#define ECC_CURVE_NIST_P384_DIGITS  6
 #define ECC_MAX_DIGITS             (512 / 64)
 
 #define ECC_DIGITS_TO_BYTES_SHIFT 3
 
+#define ECC_MAX_BYTES (ECC_MAX_DIGITS << ECC_DIGITS_TO_BYTES_SHIFT)
+
 /**
  * struct ecc_point - elliptic curve point in affine coordinates
  *
@@ -48,6 +51,29 @@ struct ecc_point {
 
 #define ECC_POINT_INIT(x, y, ndigits)	(struct ecc_point) { x, y, ndigits }
 
+/**
+ * ecc_swap_digits() - Copy ndigits from big endian array to native array
+ * @in:       Input array
+ * @out:      Output array
+ * @ndigits:  Number of digits to copy
+ */
+static inline void ecc_swap_digits(const u64 *in, u64 *out, unsigned int ndigits)
+{
+       const __be64 *src = (__force __be64 *)in;
+       int i;
+
+       for (i = 0; i < ndigits; i++)
+               out[i] = be64_to_cpu(src[ndigits - 1 - i]);
+}
+
+/**
+ * ecc_get_curve()  - Get a curve given its curve_id
+ * @curve_id:  Id of the curve
+ *
+ * Returns pointer to the curve data, NULL if curve is not available
+ */
+const struct ecc_curve *ecc_get_curve(unsigned int curve_id);
+
 /**
  * struct ecc_curve - definition of elliptic curve
  *
diff --git a/crypto/ecc_curve_defs.h b/crypto/ecc_curve_defs.h
index 69be6c7d2..47cb9440e 100644
--- a/crypto/ecc_curve_defs.h
+++ b/crypto/ecc_curve_defs.h
@@ -54,4 +54,53 @@ static struct ecc_curve nist_p256 = {
 	.b = nist_p256_b
 };
 
+/* NIST P-384 */
+static u64 nist_p384_g_x[] = { 0x3A545E3872760AB7ull, 0x5502F25DBF55296Cull,
+                               0x59F741E082542A38ull, 0x6E1D3B628BA79B98ull,
+                               0x8Eb1C71EF320AD74ull, 0xAA87CA22BE8B0537ull };
+static u64 nist_p384_g_y[] = { 0x7A431D7C90EA0E5Full, 0x0A60B1CE1D7E819Dull,
+                               0xE9DA3113B5F0B8C0ull, 0xF8F41DBD289A147Cull,
+                               0x5D9E98BF9292DC29ull, 0x3617DE4A96262C6Full };
+static u64 nist_p384_p[] = { 0x00000000FFFFFFFFull, 0xFFFFFFFF00000000ull,
+                               0xFFFFFFFFFFFFFFFEull, 0xFFFFFFFFFFFFFFFFull,
+                               0xFFFFFFFFFFFFFFFFull, 0xFFFFFFFFFFFFFFFFull };
+static u64 nist_p384_n[] = { 0xECEC196ACCC52973ull, 0x581A0DB248B0A77Aull,
+                               0xC7634D81F4372DDFull, 0xFFFFFFFFFFFFFFFFull,
+                               0xFFFFFFFFFFFFFFFFull, 0xFFFFFFFFFFFFFFFFull };
+static u64 nist_p384_a[] = { 0x00000000FFFFFFFCull, 0xFFFFFFFF00000000ull,
+                               0xFFFFFFFFFFFFFFFEull, 0xFFFFFFFFFFFFFFFFull,
+                               0xFFFFFFFFFFFFFFFFull, 0xFFFFFFFFFFFFFFFFull };
+static u64 nist_p384_b[] = { 0x2a85c8edd3ec2aefull, 0xc656398d8a2ed19dull,
+                               0x0314088f5013875aull, 0x181d9c6efe814112ull,
+                               0x988e056be3f82d19ull, 0xb3312fa7e23ee7e4ull };
+static struct ecc_curve nist_p384 = {
+       .name = "nist_384",
+       .g = {
+               .x = nist_p384_g_x,
+               .y = nist_p384_g_y,
+               .ndigits = 6,
+       },
+       .p = nist_p384_p,
+       .n = nist_p384_n,
+       .a = nist_p384_a,
+       .b = nist_p384_b
+};
+
+/* curve25519 */
+static u64 curve25519_g_x[] = { 0x0000000000000009, 0x0000000000000000,
+                               0x0000000000000000, 0x0000000000000000 };
+static u64 curve25519_p[] = { 0xffffffffffffffed, 0xffffffffffffffff,
+                               0xffffffffffffffff, 0x7fffffffffffffff };
+static u64 curve25519_a[] = { 0x000000000001DB41, 0x0000000000000000,
+                               0x0000000000000000, 0x0000000000000000 };
+static const struct ecc_curve ecc_25519 = {
+       .name = "curve25519",
+       .g = {
+               .x = curve25519_g_x,
+               .ndigits = 4,
+       },
+       .p = curve25519_p,
+       .a = curve25519_a,
+};
+
 #endif
diff --git a/include/crypto/ecdh.h b/include/crypto/ecdh.h
index a755abb13..5592bd9cb 100644
--- a/include/crypto/ecdh.h
+++ b/include/crypto/ecdh.h
@@ -25,6 +25,7 @@
 /* Curves IDs */
 #define ECC_CURVE_NIST_P192	0x0001
 #define ECC_CURVE_NIST_P256	0x0002
+#define ECC_CURVE_NIST_P384     0x0003
 
 /**
  * struct ecdh - define an ECDH private key
diff --git a/include/keys/asymmetric-type.h b/include/keys/asymmetric-type.h
index a29d3ff2e..747e52785 100644
--- a/include/keys/asymmetric-type.h
+++ b/include/keys/asymmetric-type.h
@@ -72,6 +72,12 @@ const struct asymmetric_key_ids *asymmetric_key_ids(const struct key *key)
 	return key->payload.data[asym_key_ids];
 }
 
+static inline
+const struct public_key *asymmetric_key_public_key(const struct key *key)
+{
+       return key->payload.data[asym_crypto];
+}
+
 extern struct key *find_asymmetric_key(struct key *keyring,
 				       const struct asymmetric_key_id *id_0,
 				       const struct asymmetric_key_id *id_1,
diff --git a/include/linux/oid_registry.h b/include/linux/oid_registry.h
index 4462ed2c1..a3c984b20 100644
--- a/include/linux/oid_registry.h
+++ b/include/linux/oid_registry.h
@@ -19,8 +19,14 @@
 enum OID {
 	OID_id_dsa_with_sha1,		/* 1.2.840.10030.4.3 */
 	OID_id_dsa,			/* 1.2.840.10040.4.1 */
-	OID_id_ecdsa_with_sha1,		/* 1.2.840.10045.4.1 */
 	OID_id_ecPublicKey,		/* 1.2.840.10045.2.1 */
+        OID_id_prime192v1,              /* 1.2.840.10045.3.1.1 */
+        OID_id_prime256v1,              /* 1.2.840.10045.3.1.7 */
+        OID_id_ecdsa_with_sha1,         /* 1.2.840.10045.4.1 */
+        OID_id_ecdsa_with_sha224,       /* 1.2.840.10045.4.3.1 */
+        OID_id_ecdsa_with_sha256,       /* 1.2.840.10045.4.3.2 */
+        OID_id_ecdsa_with_sha384,       /* 1.2.840.10045.4.3.3 */
+        OID_id_ecdsa_with_sha512,       /* 1.2.840.10045.4.3.4 */
 
 	/* PKCS#1 {iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1) pkcs-1(1)} */
 	OID_rsaEncryption,		/* 1.2.840.113549.1.1.1 */
@@ -58,6 +64,7 @@ enum OID {
 
 	OID_certAuthInfoAccess,		/* 1.3.6.1.5.5.7.1.1 */
 	OID_sha1,			/* 1.3.14.3.2.26 */
+	OID_id_ansip384r1,              /* 1.3.132.0.34 */
 	OID_sha256,			/* 2.16.840.1.101.3.4.2.1 */
 	OID_sha384,			/* 2.16.840.1.101.3.4.2.2 */
 	OID_sha512,			/* 2.16.840.1.101.3.4.2.3 */
@@ -117,6 +124,7 @@ enum OID {
 };
 
 extern enum OID look_up_OID(const void *data, size_t datasize);
+extern int parse_OID(const void *data, size_t datasize, enum OID *oid);
 extern int sprint_oid(const void *, size_t, char *, size_t);
 extern int sprint_OID(enum OID, char *, size_t);
 
-- 
2.30.0
