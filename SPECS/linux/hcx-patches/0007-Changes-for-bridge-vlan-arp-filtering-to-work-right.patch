From 297afaa3707d9efeb3d3815d0f5e6a87c259640b Mon Sep 17 00:00:00 2001
From: Keerthana K <keerthanak@vmware.com>
Date: Fri, 24 Jul 2020 14:23:44 +0530
Subject: [PATCH 07/11] Changes for bridge vlan arp filtering to work right

If a bridge port is marked as untagged for vlans, then
the skbs sent to that bridge port must have their vlan
cleared. However, this was being done before running the
netfilter FORWARD hooks, so if a netfilter/arptables rule
wanted to look at the vlan, it would not see it.

Fix this by deferring the vlan clear until after the netfilter
hooks have finished.

Added vlan support for arptables command

Signed-off-by: Srish Srinivasan <ssrish@vmware.com>
---
 include/linux/skbuff.h                        |  1 +
 include/uapi/linux/netfilter_arp/arp_tables.h |  7 ++-
 net/bridge/br_forward.c                       |  9 ++++
 net/bridge/br_private.h                       | 12 +++++
 net/bridge/br_vlan.c                          | 15 ++++--
 net/ipv4/netfilter/arp_tables.c               | 53 ++++++++++++++++++-
 6 files changed, 91 insertions(+), 6 deletions(-)

diff --git a/include/linux/skbuff.h b/include/linux/skbuff.h
index 9dee4f213..bed2c8101 100644
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@ -976,6 +976,7 @@ struct sk_buff {
 	__u8			ipvs_property:1;
 	__u8			inner_protocol_type:1;
 	__u8			remcsum_offload:1;
+	__u8            vlan_clear_needed:1;
 #ifdef CONFIG_NET_SWITCHDEV
 	__u8			offload_fwd_mark:1;
 	__u8			offload_l3_fwd_mark:1;
diff --git a/include/uapi/linux/netfilter_arp/arp_tables.h b/include/uapi/linux/netfilter_arp/arp_tables.h
index a6ac2463f..df634f166 100644
--- a/include/uapi/linux/netfilter_arp/arp_tables.h
+++ b/include/uapi/linux/netfilter_arp/arp_tables.h
@@ -57,7 +57,10 @@ struct arpt_arp {
 
 	/* ARP hardware address and protocol address format. */
 	__be16 arhrd, arhrd_mask;
+
 	__be16 arpro, arpro_mask;
+	/* Vlan of packet. */
+	__u16 vlan, vlan_mask;
 
 	/* The protocol address length is only accepted if it is 4
 	 * so there is no use in offering a way to do filtering on it.
@@ -88,7 +91,9 @@ struct arpt_arp {
 #define ARPT_INV_ARPHRD		0x0080	/* Invert the sense of ARP HRD. */
 #define ARPT_INV_ARPPRO		0x0100	/* Invert the sense of ARP PRO. */
 #define ARPT_INV_ARPHLN		0x0200	/* Invert the sense of ARP HLN. */
-#define ARPT_INV_MASK		0x03FF	/* All possible flag bits mask. */
+#define ARPT_INV_VLAN          0x0400  /* Invert the sense of VLAN. */
+#define ARPT_INV_MASK          0x07FF  /* All possible flag bits mask. */
+
 
 /* This structure defines each of the firewall rules.  Consists of 3
    parts which are 1) general ARP header stuff 2) match specific
diff --git a/net/bridge/br_forward.c b/net/bridge/br_forward.c
index 4e3394a7d..f7fcc3ff1 100644
--- a/net/bridge/br_forward.c
+++ b/net/bridge/br_forward.c
@@ -17,6 +17,12 @@
 #include <linux/netfilter_bridge.h>
 #include "br_private.h"
 
+#ifdef CONFIG_SYSCTL
+extern int arp_vlan_netfilter __read_mostly;
+#else
+#define arp_vlan_netfilter 0
+#endif
+
 /* Don't forward packets to originating port or forwarding disabled */
 static inline int should_deliver(const struct net_bridge_port *p,
 				 const struct sk_buff *skb)
@@ -32,6 +38,9 @@ static inline int should_deliver(const struct net_bridge_port *p,
 
 int br_dev_queue_push_xmit(struct net *net, struct sock *sk, struct sk_buff *skb)
 {
+	if (arp_vlan_netfilter) {
+		br_skb_vlan_clear(skb);
+	}
 	skb_push(skb, ETH_HLEN);
 	if (!is_skb_forwardable(skb->dev, skb))
 		goto drop;
diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 8cec33ed7..bdf9feb03 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -1549,6 +1549,14 @@ static inline u16 br_vlan_flags(const struct net_bridge_vlan *v, u16 pvid)
 {
 	return v->vid == pvid ? v->flags | BRIDGE_VLAN_INFO_PVID : v->flags;
 }
+
+static inline void br_skb_vlan_clear(struct sk_buff *skb)
+{
+	if (skb->vlan_clear_needed) {
+		skb->vlan_tci = 0;
+		skb->vlan_clear_needed = 0;
+	}
+}
 #else
 static inline bool br_allowed_ingress(const struct net_bridge *br,
 				      struct net_bridge_vlan_group *vg,
@@ -1644,6 +1652,10 @@ static inline u16 br_get_pvid(const struct net_bridge_vlan_group *vg)
 	return 0;
 }
 
+static inline void br_skb_vlan_clear(struct sk_buff *skb)
+{
+}
+
 static inline int br_vlan_filter_toggle(struct net_bridge *br,
 					unsigned long val,
 					struct netlink_ext_ack *extack)
diff --git a/net/bridge/br_vlan.c b/net/bridge/br_vlan.c
index 9ffd40b82..b82b7a4a4 100644
--- a/net/bridge/br_vlan.c
+++ b/net/bridge/br_vlan.c
@@ -8,6 +8,12 @@
 #include "br_private.h"
 #include "br_private_tunnel.h"
 
+#ifdef CONFIG_SYSCTL
+extern int arp_vlan_netfilter __read_mostly;
+#else
+#define arp_vlan_netfilter 0
+#endif
+
 static void nbp_vlan_set_vlan_dev_state(struct net_bridge_port *p, u16 vid);
 
 static inline int br_vlan_cmp(struct rhashtable_compare_arg *arg,
@@ -517,9 +523,12 @@ struct sk_buff *br_handle_vlan(struct net_bridge *br,
 	 * hardware on each egress port as appropriate. So only strip the VLAN
 	 * header if forwarding offload is not being used.
 	 */
-	if (v->flags & BRIDGE_VLAN_INFO_UNTAGGED &&
-	    !br_switchdev_frame_uses_tx_fwd_offload(skb))
-		__vlan_hwaccel_clear_tag(skb);
+	if (v->flags & BRIDGE_VLAN_INFO_UNTAGGED) {
+		if (arp_vlan_netfilter)
+			skb->vlan_clear_needed = 1;
+		else if (!br_switchdev_frame_uses_tx_fwd_offload(skb))
+			__vlan_hwaccel_clear_tag(skb);
+	}
 
 	if (p && (p->flags & BR_VLAN_TUNNEL) &&
 	    br_handle_egress_vlan_tunnel(skb, v)) {
diff --git a/net/ipv4/netfilter/arp_tables.c b/net/ipv4/netfilter/arp_tables.c
index 2407066b0..5d7990ebe 100644
--- a/net/ipv4/netfilter/arp_tables.c
+++ b/net/ipv4/netfilter/arp_tables.c
@@ -23,6 +23,7 @@
 #include <linux/init.h>
 #include <linux/mutex.h>
 #include <linux/err.h>
+#include <linux/if_vlan.h>
 #include <net/compat.h>
 #include <net/sock.h>
 #include <linux/uaccess.h>
@@ -31,10 +32,43 @@
 #include <linux/netfilter_arp/arp_tables.h>
 #include "../../netfilter/xt_repldata.h"
 
+#ifdef CONFIG_SYSCTL
+#include <linux/sysctl.h>
+static struct ctl_table_header *arp_filter_sysctl_header;
+int arp_vlan_netfilter __read_mostly = 0;
+EXPORT_SYMBOL(arp_vlan_netfilter);
+#else
+#define arp_vlan_netfilter 0
+#endif
+
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("David S. Miller <davem@redhat.com>");
 MODULE_DESCRIPTION("arptables core");
 
+#ifdef CONFIG_SYSCTL
+static struct ctl_table arp_vlan_netfilter_table[] = {
+	{
+		.procname	= "arp_vlan_netfilter",
+		.data		= &arp_vlan_netfilter,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= proc_dointvec,
+	},
+	{}
+};
+
+static int arp_filter_sysctl_init(void)
+{
+	arp_filter_sysctl_header = register_net_sysctl(&init_net, "net/netfilter",
+						       arp_vlan_netfilter_table);
+	if (arp_filter_sysctl_header == NULL) {
+		printk(KERN_ERR "arp: can't register to sysctl");
+		return -ENOMEM;
+	}
+	return 0;
+}
+#endif
+
 void *arpt_alloc_initial_table(const struct xt_table *info)
 {
 	return xt_alloc_initial_table(arpt, ARPT);
@@ -80,11 +114,12 @@ static unsigned long ifname_compare(const char *_a, const char *_b, const char *
 
 /* Returns whether packet matches rule or not. */
 static inline int arp_packet_match(const struct arphdr *arphdr,
-				   struct net_device *dev,
+				   struct sk_buff *skb,
 				   const char *indev,
 				   const char *outdev,
 				   const struct arpt_arp *arpinfo)
 {
+	struct net_device *dev = skb->dev;
 	const char *arpptr = (char *)(arphdr + 1);
 	const char *src_devaddr, *tgt_devaddr;
 	__be32 src_ipaddr, tgt_ipaddr;
@@ -139,6 +174,14 @@ static inline int arp_packet_match(const struct arphdr *arphdr,
 	if (NF_INVF(arpinfo, ARPT_INV_VIA_OUT, ret != 0))
 		return 0;
 
+	if (arp_vlan_netfilter && NF_INVF(arpinfo, ARPT_INV_VLAN,
+		    (skb_vlan_tag_get_id(skb) & arpinfo->vlan_mask) != arpinfo->vlan)) {
+		printk(KERN_INFO "VLAN mismatch vlan:%04x info->vlan:%04x info->vlan_mask:%04x.%s\n",
+			skb_vlan_tag_get_id(skb), arpinfo->vlan, arpinfo->vlan_mask,
+			arpinfo->invflags & ARPT_INV_VLAN ? " (INV)" : "");
+		return 0;
+	}
+
 	return 1;
 }
 
@@ -222,7 +265,7 @@ unsigned int arpt_do_table(void *priv,
 		const struct xt_entry_target *t;
 		struct xt_counters *counter;
 
-		if (!arp_packet_match(arp, skb->dev, indev, outdev, &e->arp)) {
+		if (!arp_packet_match(arp, skb, indev, outdev, &e->arp)) {
 			e = arpt_next_entry(e);
 			continue;
 		}
@@ -1641,6 +1684,9 @@ static int __init arp_tables_init(void)
 	ret = nf_register_sockopt(&arpt_sockopts);
 	if (ret < 0)
 		goto err4;
+#ifdef CONFIG_SYSCTL
+	arp_filter_sysctl_init();
+#endif
 
 	return 0;
 
@@ -1657,6 +1703,9 @@ static void __exit arp_tables_fini(void)
 	nf_unregister_sockopt(&arpt_sockopts);
 	xt_unregister_targets(arpt_builtin_tg, ARRAY_SIZE(arpt_builtin_tg));
 	unregister_pernet_subsys(&arp_tables_net_ops);
+#ifdef CONFIG_SYSCTL
+	unregister_net_sysctl_table(arp_filter_sysctl_header);
+#endif
 }
 
 EXPORT_SYMBOL(arpt_register_table);
-- 
2.39.0
