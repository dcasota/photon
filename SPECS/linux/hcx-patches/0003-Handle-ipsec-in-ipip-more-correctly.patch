From 2aa560fef8c693a196db341cebfa07ab98f0de8b Mon Sep 17 00:00:00 2001
From: Keerthana K <keerthanak@vmware.com>
Date: Fri, 18 Jun 2021 09:09:34 +0000
Subject: [PATCH 03/11] Handle ipsec in ipip more correctly

If there is already encapsulation present, ipip tries to
use the inner-most header for things like copying ttl and
tos. That is okay, unless ipsec encrypted the inner
header. In that case, ipip tries to use encrypted values
instead of the real ones. Prevent that by treating ipsec
as non encapsulated.

Signed-off-by: Keerthana K <keerthanak@vmware.com>
Signed-off-by: Srish Srinivasan <ssrish@vmware.com>
---
 net/ipv4/ipip.c | 32 ++++++++++++++++++++++++++++++++
 1 file changed, 32 insertions(+)

diff --git a/net/ipv4/ipip.c b/net/ipv4/ipip.c
index 180f9daf5..31d04fe13 100644
--- a/net/ipv4/ipip.c
+++ b/net/ipv4/ipip.c
@@ -116,6 +116,14 @@ static bool log_ecn_error = true;
 module_param(log_ecn_error, bool, 0644);
 MODULE_PARM_DESC(log_ecn_error, "Log packets received with corrupted ECN");
 
+#ifdef CONFIG_SYSCTL
+extern int ipip_tunnel_skip_encap_decap __read_mostly;
+extern struct ctl_table_header *ipip_sysctl_header __read_mostly;
+#else
+#define ipip_tunnel_skip_encap_decap 0
+#define ipip_sysctl_header NULL
+#endif
+
 static unsigned int ipip_net_id __read_mostly;
 
 static int ipip_tunnel_init(struct net_device *dev);
@@ -293,6 +301,24 @@ static netdev_tx_t ipip_tunnel_xmit(struct sk_buff *skb,
 		goto tx_error;
 	}
 
+	/* If there is already encapsulation present, ipip tries to
+	 * use the inner-most header for things like copying ttl and
+	 * tos.  That is okay, unless ipsec encrypted the inner
+	 * header.  In that case, ipip tries to use encrypted values
+	 * instead of the real ones.  Prevent that by treating ipsec
+	 * as non encapsulated.
+	 *
+	 * It's not clear this is 100% correct solution.  It feels
+	 * more like ipsec should prevent this, but it fixes our use
+	 * case.
+	 */
+	if (ipip_tunnel_skip_encap_decap && skb->encapsulation) {
+		struct iphdr *iph = ip_hdr(skb);
+		if (iph->protocol == IPPROTO_ESP) {
+			skb->encapsulation = 0;
+		}
+	}
+
 	if (tiph->protocol != ipproto && tiph->protocol != 0)
 		goto tx_error;
 
@@ -627,6 +653,9 @@ static int __init ipip_init(void)
 	err = rtnl_link_register(&ipip_link_ops);
 	if (err < 0)
 		goto rtnl_link_failed;
+#ifdef CONFIG_SYSCTL
+	ipip_sysctl_init();
+#endif
 
 out:
 	return err;
@@ -653,6 +682,9 @@ static void __exit ipip_fini(void)
 		pr_info("%s: can't deregister tunnel\n", __func__);
 #endif
 	unregister_pernet_device(&ipip_net_ops);
+#ifdef CONFIG_SYSCTL
+	unregister_net_sysctl_table(ipip_sysctl_header);
+#endif
 }
 
 module_init(ipip_init);
-- 
2.39.0
