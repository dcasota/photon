From a887c6c18d54ec736b9f3c9bb3391e7f830a3295 Mon Sep 17 00:00:00 2001
From: Jonathan Shao <sjonathan@vmware.com>
Date: Tue, 14 Jun 2022 15:28:25 -0700
Subject: [PATCH 14/16] iptunnel mark xfrm multi parts

This patch modifies several places for HCX specific purpose.

Signed-off-by: Srish Srinivasan <ssrish@vmware.com>
---
 include/net/dst_cache.h | 27 ++++++++++++++++++++++
 net/core/dst_cache.c    | 51 +++++++++++++++++++++++++++++++++++++----
 net/ipv4/ip_tunnel.c    | 46 ++++++++++++++++++++++++++++++-------
 3 files changed, 112 insertions(+), 12 deletions(-)

diff --git a/include/net/dst_cache.h b/include/net/dst_cache.h
index df6622a5f..d20629399 100644
--- a/include/net/dst_cache.h
+++ b/include/net/dst_cache.h
@@ -32,6 +32,19 @@ struct dst_entry *dst_cache_get(struct dst_cache *dst_cache);
  */
 struct rtable *dst_cache_get_ip4(struct dst_cache *dst_cache, __be32 *saddr);
 
+/**
+ *	dst_cache_get_ip4_use_mark - perform cache lookup and fetch ipv4 source
+ *	                             using custom mark
+ *	@dst_cache: the cache
+ *	@saddr: return value for the retrieved source address
+ *	@mark : the custom mark
+ *	@use_mark: enables using the mark (allows using zero for mark value)
+ *
+ *	local BH must be disabled.
+ */
+struct rtable *dst_cache_get_ip4_use_mark(struct dst_cache *dst_cache,
+        __be32 *saddr, u32 mark);
+
 /**
  *	dst_cache_set_ip4 - store the ipv4 dst into the cache
  *	@dst_cache: the cache
@@ -42,6 +55,20 @@ struct rtable *dst_cache_get_ip4(struct dst_cache *dst_cache, __be32 *saddr);
  */
 void dst_cache_set_ip4(struct dst_cache *dst_cache, struct dst_entry *dst,
 		       __be32 saddr);
+/**
+ *	dst_cache_set_ip4_use_mark - store the ipv4 dst into the cache using
+ *	                             custom mark
+ *	@dst_cache: the cache
+ *	@dst: the entry to be cached
+ *	@saddr: the source address to be stored inside the cache
+ *	@mark : the custom mark
+ *	@use_mark: enables using the mark (allows using zero for mark value)
+ *
+ *	local BH must be disabled.
+ */
+void dst_cache_set_ip4_use_mark(struct dst_cache *dst_cache,
+		        struct dst_entry *dst, __be32 saddr, u32 mark);
+
 
 #if IS_ENABLED(CONFIG_IPV6)
 
diff --git a/net/core/dst_cache.c b/net/core/dst_cache.c
index 0ccfd5fa5..b82d8145e 100644
--- a/net/core/dst_cache.c
+++ b/net/core/dst_cache.c
@@ -22,6 +22,7 @@ struct dst_cache_pcpu {
 		struct in_addr in_saddr;
 		struct in6_addr in6_saddr;
 	};
+	u32 mark;
 };
 
 static void dst_cache_per_cpu_dst_set(struct dst_cache_pcpu *dst_cache,
@@ -69,7 +70,8 @@ struct dst_entry *dst_cache_get(struct dst_cache *dst_cache)
 }
 EXPORT_SYMBOL_GPL(dst_cache_get);
 
-struct rtable *dst_cache_get_ip4(struct dst_cache *dst_cache, __be32 *saddr)
+static struct rtable *__dst_cache_get_ip4(struct dst_cache *dst_cache,
+        __be32 *saddr, u32 mark, bool use_mark)
 {
 	struct dst_cache_pcpu *idst;
 	struct dst_entry *dst;
@@ -82,13 +84,37 @@ struct rtable *dst_cache_get_ip4(struct dst_cache *dst_cache, __be32 *saddr)
 	if (!dst)
 		return NULL;
 
-	*saddr = idst->in_saddr.s_addr;
+	if (use_mark) {
+		if (idst->mark == mark) {
+			*saddr = idst->in_saddr.s_addr;
+		} else {
+			dst_cache_set_ip4_use_mark(dst_cache, NULL, 0, 0);
+			dst_release(dst);
+			dst = NULL;
+			return NULL;
+		}
+	} else {
+		*saddr = idst->in_saddr.s_addr;
+	}
+
 	return container_of(dst, struct rtable, dst);
 }
+
+struct rtable *dst_cache_get_ip4(struct dst_cache *dst_cache, __be32 *saddr)
+{
+	return __dst_cache_get_ip4(dst_cache, saddr, 0, false);
+}
 EXPORT_SYMBOL_GPL(dst_cache_get_ip4);
 
-void dst_cache_set_ip4(struct dst_cache *dst_cache, struct dst_entry *dst,
-		       __be32 saddr)
+struct rtable *dst_cache_get_ip4_use_mark(struct dst_cache *dst_cache,
+        __be32 *saddr, u32 mark)
+{
+	return __dst_cache_get_ip4(dst_cache, saddr, mark, true);
+}
+EXPORT_SYMBOL_GPL(dst_cache_get_ip4_use_mark);
+
+static void __dst_cache_set_ip4(struct dst_cache *dst_cache,
+        struct dst_entry *dst, __be32 saddr, u32 mark, u32 use_mark)
 {
 	struct dst_cache_pcpu *idst;
 
@@ -98,9 +124,26 @@ void dst_cache_set_ip4(struct dst_cache *dst_cache, struct dst_entry *dst,
 	idst = this_cpu_ptr(dst_cache->cache);
 	dst_cache_per_cpu_dst_set(idst, dst, 0);
 	idst->in_saddr.s_addr = saddr;
+	if (use_mark) {
+		idst->mark = mark;
+	}
+}
+
+void dst_cache_set_ip4(struct dst_cache *dst_cache, struct dst_entry *dst,
+               __be32 saddr)
+{
+	__dst_cache_set_ip4(dst_cache, dst, saddr, 0, true);
 }
 EXPORT_SYMBOL_GPL(dst_cache_set_ip4);
 
+void dst_cache_set_ip4_use_mark(struct dst_cache *dst_cache,
+        struct dst_entry *dst, __be32 saddr, u32 mark)
+{
+
+	__dst_cache_set_ip4(dst_cache, dst, saddr, mark, true);
+}
+EXPORT_SYMBOL_GPL(dst_cache_set_ip4_use_mark);
+
 #if IS_ENABLED(CONFIG_IPV6)
 void dst_cache_set_ip6(struct dst_cache *dst_cache, struct dst_entry *dst,
 		       const struct in6_addr *saddr)
diff --git a/net/ipv4/ip_tunnel.c b/net/ipv4/ip_tunnel.c
index 390472c41..4c064665a 100644
--- a/net/ipv4/ip_tunnel.c
+++ b/net/ipv4/ip_tunnel.c
@@ -57,9 +57,11 @@
 struct ctl_table_header *ipip_sysctl_header = NULL;
 int ipip_tunnel_skip_encap_decap __read_mostly = 0;
 int fou_key_multi_port __read_mostly = 0;
+int ipip_dst_cache_use_mark __read_mostly = 0;
 EXPORT_SYMBOL_GPL(ipip_tunnel_skip_encap_decap);
 EXPORT_SYMBOL_GPL(ipip_sysctl_header);
 EXPORT_SYMBOL_GPL(fou_key_multi_port);
+EXPORT_SYMBOL_GPL(ipip_dst_cache_use_mark);
 
 struct ctl_table ipip_sysctl_table[] = {
 	{
@@ -76,6 +78,14 @@ struct ctl_table ipip_sysctl_table[] = {
 		.mode           = 0644,
 		.proc_handler   = proc_dointvec,
 	},
+	{
+		.procname       = "ipip_dst_cache_use_mark",
+		.data           = &ipip_dst_cache_use_mark,
+		.maxlen         = sizeof(int),
+		.mode           = 0644,
+		.proc_handler   = proc_dointvec,
+	},
+
 	{}
 };
 EXPORT_SYMBOL_GPL(ipip_sysctl_table);
@@ -94,6 +104,7 @@ EXPORT_SYMBOL_GPL(ipip_sysctl_init);
 #else
 #define ipip_tunnel_skip_encap_decap 0
 #define fou_key_multi_port 0
+#define ipip_dst_cache_use_mark 0
 #endif
 
 static unsigned int ip_tunnel_hash(__be32 key, __be32 remote)
@@ -782,10 +793,17 @@ void ip_tunnel_xmit(struct sk_buff *skb, struct net_device *dev,
 		}
 	}
 
-	ip_tunnel_init_flow(&fl4, protocol, dst, tnl_params->saddr,
-			    tunnel->parms.o_key, RT_TOS(tos),
-			    dev_net(dev), tunnel->parms.link,
-			    tunnel->fwmark, skb_get_hash(skb), 0);
+	if(ipip_dst_cache_use_mark) {
+		ip_tunnel_init_flow(&fl4, protocol, dst, tnl_params->saddr,
+			    	tunnel->parms.o_key, RT_TOS(tos),
+			    	dev_net(dev), tunnel->parms.link,
+			    	skb->mark, skb_get_hash(skb), 0);
+	} else {
+		ip_tunnel_init_flow(&fl4, protocol, dst, tnl_params->saddr,
+			    	tunnel->parms.o_key, RT_TOS(tos),
+			    	dev_net(dev), tunnel->parms.link,
+			    	tunnel->fwmark, skb_get_hash(skb), 0);		
+	} 
 
 	if (ip_tunnel_encap(skb, tunnel, &protocol, &fl4) < 0)
 		goto tx_error;
@@ -796,8 +814,14 @@ void ip_tunnel_xmit(struct sk_buff *skb, struct net_device *dev,
 			rt = dst_cache_get_ip4(&tun_info->dst_cache,
 					       &fl4.saddr);
 	} else {
-		rt = connected ? dst_cache_get_ip4(&tunnel->dst_cache,
-						&fl4.saddr) : NULL;
+		if(ipip_dst_cache_use_mark) {
+			rt = connected ?
+				dst_cache_get_ip4_use_mark(&tunnel->dst_cache, &fl4.saddr,
+					skb->mark) : NULL;
+		} else {
+			rt = connected ? dst_cache_get_ip4(&tunnel->dst_cache, &fl4.saddr)
+				: NULL;
+		}
 	}
 
 	if (!rt) {
@@ -810,9 +834,15 @@ void ip_tunnel_xmit(struct sk_buff *skb, struct net_device *dev,
 		if (use_cache)
 			dst_cache_set_ip4(&tun_info->dst_cache, &rt->dst,
 					  fl4.saddr);
-		else if (!md && connected)
-			dst_cache_set_ip4(&tunnel->dst_cache, &rt->dst,
+		else if (!md && connected) {
+			if(ipip_dst_cache_use_mark) {
+				dst_cache_set_ip4_use_mark(&tunnel->dst_cache,
+					  &rt->dst, fl4.saddr, fl4.flowi4_mark);
+			} else {
+				dst_cache_set_ip4(&tunnel->dst_cache, &rt->dst,
 					  fl4.saddr);
+			}
+		}
 	}
 
 	if (rt->dst.dev == dev) {
-- 
2.39.0
