From bc20cceacf8456360a74ee62eb1647149a57d52e Mon Sep 17 00:00:00 2001
From: Keerthana K <keerthanak@vmware.com>
Date: Fri, 24 Jul 2020 14:12:30 +0530
Subject: [PATCH 01/11] Active probing of dst mac of unknown unicast

Actively do arp probe when received an unknown unicast.
We just send arp probe back the receiving port in stand of
flooding all the other ports.

Add some stats counters for troubleshooting purpose.
Add a option arp_probe to enable or disable this function.

Change value of arp_probe_per_packets to change the frequence
of arp probing. Skip unknown unicast from gretap dev.

Add proc variable arp_probe_src_mac to let user specify the 
source mac of probing packet.

Add port flag "sink_connected", if this flag on means
this a l2c tapdevice connected. Do not send arp probe for the 
packet coming form port with this flag.

Signed-off-by: Srish Srinivasan <ssrish@vmware.com>
---
 include/linux/if_bridge.h    |   1 +
 include/uapi/linux/if_link.h |   1 +
 net/bridge/br.c              |  12 ++
 net/bridge/br_device.c       |  10 ++
 net/bridge/br_input.c        | 231 +++++++++++++++++++++++++++++++++++
 net/bridge/br_netlink.c      |   5 +
 net/bridge/br_private.h      |   9 ++
 net/bridge/br_sysfs_br.c     |  24 ++++
 net/bridge/br_sysfs_if.c     |   2 +
 net/core/rtnetlink.c         |   4 +-
 10 files changed, 298 insertions(+), 1 deletion(-)

diff --git a/include/linux/if_bridge.h b/include/linux/if_bridge.h
index d62ef428e..f39ae0d42 100644
--- a/include/linux/if_bridge.h
+++ b/include/linux/if_bridge.h
@@ -59,6 +59,7 @@ struct br_ip_list {
 #define BR_MRP_LOST_IN_CONT	BIT(19)
 #define BR_TX_FWD_OFFLOAD	BIT(20)
 #define BR_PORT_LOCKED		BIT(21)
+#define BR_SINK_CONNECTED	BIT(17)
 
 #define BR_DEFAULT_AGEING_TIME	(300 * HZ)
 
diff --git a/include/uapi/linux/if_link.h b/include/uapi/linux/if_link.h
index 5e7a1041d..f1e85edb7 100644
--- a/include/uapi/linux/if_link.h
+++ b/include/uapi/linux/if_link.h
@@ -561,6 +561,7 @@ enum {
 	IFLA_BRPORT_MCAST_EHT_HOSTS_LIMIT,
 	IFLA_BRPORT_MCAST_EHT_HOSTS_CNT,
 	IFLA_BRPORT_LOCKED,
+	IFLA_BRPORT_SINK_CONNECTED,
 	__IFLA_BRPORT_MAX
 };
 #define IFLA_BRPORT_MAX (__IFLA_BRPORT_MAX - 1)
diff --git a/net/bridge/br.c b/net/bridge/br.c
index 96e91d69a..591d26593 100644
--- a/net/bridge/br.c
+++ b/net/bridge/br.c
@@ -19,6 +19,11 @@
 
 #include "br_private.h"
 
+#ifdef CONFIG_SYSCTL
+extern int br_input_sysctl_init(void);
+extern void br_input_sysctl_fini(void);
+#endif
+
 /*
  * Handle changes in state of network devices enslaved to a bridge.
  *
@@ -425,6 +430,10 @@ static int __init br_init(void)
 		"need this.\n");
 #endif
 
+#ifdef CONFIG_SYSCTL
+	br_input_sysctl_init();
+#endif
+
 	return 0;
 
 err_out6:
@@ -461,6 +470,9 @@ static void __exit br_deinit(void)
 	br_fdb_test_addr_hook = NULL;
 #endif
 	br_fdb_fini();
+#ifdef CONFIG_SYSCTL
+	br_input_sysctl_fini();
+#endif
 }
 
 module_init(br_init)
diff --git a/net/bridge/br_device.c b/net/bridge/br_device.c
index b82906fc9..8f45e77ba 100644
--- a/net/bridge/br_device.c
+++ b/net/bridge/br_device.c
@@ -123,9 +123,16 @@ static int br_dev_init(struct net_device *dev)
 	if (!dev->tstats)
 		return -ENOMEM;
 
+	br->ukn_stats = alloc_percpu_gfp(struct ukn_unicast_stats, GFP_KERNEL);
+	if (!br->ukn_stats) {
+		free_percpu(dev->tstats);
+		return -ENOMEM;
+	}
+
 	err = br_fdb_hash_init(br);
 	if (err) {
 		free_percpu(dev->tstats);
+		free_percpu(br->ukn_stats);
 		return err;
 	}
 
@@ -139,6 +146,7 @@ static int br_dev_init(struct net_device *dev)
 	err = br_vlan_init(br);
 	if (err) {
 		free_percpu(dev->tstats);
+		free_percpu(br->ukn_stats);
 		br_mdb_hash_fini(br);
 		br_fdb_hash_fini(br);
 		return err;
@@ -147,6 +155,7 @@ static int br_dev_init(struct net_device *dev)
 	err = br_multicast_init_stats(br);
 	if (err) {
 		free_percpu(dev->tstats);
+		free_percpu(br->ukn_stats);
 		br_vlan_flush(br);
 		br_mdb_hash_fini(br);
 		br_fdb_hash_fini(br);
@@ -166,6 +175,7 @@ static void br_dev_uninit(struct net_device *dev)
 	br_mdb_hash_fini(br);
 	br_fdb_hash_fini(br);
 	free_percpu(dev->tstats);
+	free_percpu(br->ukn_stats);
 }
 
 static int br_dev_open(struct net_device *dev)
diff --git a/net/bridge/br_input.c b/net/bridge/br_input.c
index b94a17839..06cb4ced4 100644
--- a/net/bridge/br_input.c
+++ b/net/bridge/br_input.c
@@ -23,6 +23,18 @@
 #include "br_private.h"
 #include "br_private_tunnel.h"
 
+#ifdef CONFIG_SYSCTL
+#include <linux/sysctl.h>
+static struct ctl_table_header *br_input_sysctl_header;
+int br_arp_probe __read_mostly = 1;
+int br_arp_probe_per_packets __read_mostly = 8192;
+u8 br_arp_probe_src_mac[ETH_ALEN+1] = {0};
+int br_arp_probe_src_mac_set = 0;
+#else
+#define br_arp_probe 1
+#define br_arp_probe_per_packets 8192
+#endif
+
 static int
 br_netif_receive_skb(struct net *net, struct sock *sk, struct sk_buff *skb)
 {
@@ -30,6 +42,124 @@ br_netif_receive_skb(struct net *net, struct sock *sk, struct sk_buff *skb)
 	return netif_receive_skb(skb);
 }
 
+#ifdef CONFIG_SYSCTL
+/* addr string should be in format like 00:50:56:A8:EF:F3 */
+static int string_to_mac(char *mac, u8 *macs, int len)
+{
+	int n;
+
+	n = sscanf(macs, "%hhx:%hhx:%hhx:%hhx:%hhx:%hhx",
+           &mac[0], &mac[1], &mac[2], &mac[3], &mac[4], &mac[5]);
+
+	if ( n != 6 ) {
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int proc_arp_probe_src_mac(struct ctl_table *table, int write,
+				void __user *buffer,
+				size_t *lenp, loff_t *ppos)
+{
+	char macz[ETH_ALEN+1] = {0};
+	char mac[ETH_ALEN+1];
+	char macs[18];
+	size_t len;
+
+	if (!*lenp || (*ppos && !write)) {
+		*lenp = 0;
+		return 0;
+	}
+
+	if (write) {
+		len = *lenp > 17 ? 17 : *lenp;
+		if (len != 17) {
+			printk(KERN_ERR "length %lu or format of mac address is invalid, "
+				"should be in format as 00:50:56:A8:EF:F3", len);
+			return -EINVAL;
+		}
+
+		if (copy_from_user(macs, buffer, len))
+			return -EFAULT;
+
+		macs[17] = 0;
+
+		if ( string_to_mac(mac, macs, len) ) {
+			printk(KERN_ERR "invalid format of mac address %s, should be in " \
+				"format as 00:50:56:A8:EF:F3\n", macs);
+			return -EINVAL;
+		}
+
+		memcpy(br_arp_probe_src_mac, mac, ETH_ALEN);
+		br_arp_probe_src_mac[ETH_ALEN] = 0;
+		if (memcmp(mac, macz, ETH_ALEN) == 0) {
+			br_arp_probe_src_mac_set = 0;
+		}else {
+			br_arp_probe_src_mac_set = 1;
+		}
+
+		*ppos += len;
+
+		return 0;
+	}
+
+	len = sysfs_format_mac(macs, br_arp_probe_src_mac,
+			strlen(br_arp_probe_src_mac));
+
+	if (len > *lenp) len = *lenp;
+
+	if (copy_to_user(buffer, macs, len))
+		return -EFAULT;
+
+	*lenp = len;
+	*ppos += len;
+
+	return 0;
+
+}
+
+static struct ctl_table br_input_table[] = {
+	{
+		.procname	= "arp_probe",
+		.data		= &br_arp_probe,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= proc_dointvec,
+	},
+	{
+		.procname	= "arp_probe_per_packets",
+		.data		= &br_arp_probe_per_packets,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= proc_dointvec,
+	},
+	{
+		.procname	= "arp_probe_src_mac",
+		.data		= &br_arp_probe_src_mac,
+		.maxlen		= 17,
+		.mode		= 0644,
+		.proc_handler	= proc_arp_probe_src_mac,
+	},
+	{}
+};
+
+int br_input_sysctl_init(void)
+{
+	br_input_sysctl_header = register_net_sysctl(&init_net, "net/bridge", br_input_table);
+	if (br_input_sysctl_header == NULL) {
+		printk(KERN_ERR "br: can't register to sysctl.\n");
+		return -ENOMEM;
+	}
+	return 0;
+}
+
+void br_input_sysctl_fini(void)
+{
+	unregister_net_sysctl_table(br_input_sysctl_header);
+}
+#endif
+
 static int br_pass_frame_up(struct sk_buff *skb, bool promisc)
 {
 	struct net_device *indev, *brdev = BR_INPUT_SKB_CB(skb)->brdev;
@@ -72,6 +202,104 @@ static int br_pass_frame_up(struct sk_buff *skb, bool promisc)
 		       br_netif_receive_skb);
 }
 
+/*
+ * under certain circumstances, emit packet to solicit response
+ * from which bridge can learn.
+ */
+static void br_proactive_learn(
+	struct net_bridge *br, struct net_bridge_port *p, struct sk_buff *skb)
+{
+	const struct ethhdr *ethhdr;
+	struct sk_buff *skb2;
+	const u8 *daddr = NULL, *dest_hw = NULL, *src_hw = NULL;
+	struct ukn_unicast_stats *stats = this_cpu_ptr(br->ukn_stats);
+	u32 vlan, buf;
+
+	if (!br_arp_probe) {
+		return;
+	}
+
+	if (unlikely(!skb->dev)) {
+		printk_ratelimited(KERN_WARNING "%s: dev of skb %p is null, failed " \
+			"to creat arp probe", __FUNCTION__, skb);
+		return;
+	}
+
+	/* Skip unknown unicast coming from gretap dev, which means this packet is
+	 * from remote site. If its destination mac is at remote, remote bridge
+	 * will send out arp probe. If its destincation mac is actually local, the
+	 * reverse packet will create the mac entry in local fdb. So no needs to
+	 * send arp probe back to gretap over l2c tunnel.
+	 */
+	if (!(p->flags & BR_SINK_CONNECTED)) {
+		return;
+	}
+
+	stats->ukn_unicast_total_rcvd++;
+
+	/* do sanity check on skb */
+	if (skb->protocol != cpu_to_be16(ETH_P_IP)) {
+		return;
+	}
+
+	/* check the size of IP header */
+	if (unlikely(skb->len < sizeof(struct iphdr))) {
+		printk_ratelimited(KERN_WARNING "%s: can't parse destination IP, " \
+			"header size is less than %lu", __FUNCTION__, sizeof(struct iphdr));
+		return;
+	}
+
+	/* If skb_headlen is less than 20, get daddr from buffer of skb header */
+	daddr = skb_header_pointer(skb, offsetof(struct iphdr, daddr),
+				sizeof(u32), &buf);
+	if (!daddr) {
+		printk_ratelimited(KERN_WARNING "%s: Failed to get daddr, skb_headlen "
+			"is %d", __FUNCTION__, skb_headlen(skb));
+		return;
+	}
+
+	/* every <br_arp_probe_per_packets> of unknown unicast received, we trigger
+	 * an arp probe per CPU.
+	 */
+	stats->ukn_unicast_ip_rcvd++;
+	if (br_arp_probe_per_packets &&
+		(stats->ukn_unicast_ip_rcvd%br_arp_probe_per_packets)) {
+		return;
+	}
+
+	if (likely(skb_mac_header_was_set(skb))) {
+		ethhdr = eth_hdr(skb);
+		dest_hw = ethhdr->h_dest;
+	}
+
+	if (br_arp_probe_src_mac_set) {
+		src_hw = br_arp_probe_src_mac;
+	}else {
+		src_hw = skb->dev->dev_addr;
+	}
+
+	/* skb->dev is actually dev of bridge port */
+	skb2 = arp_create(ARPOP_REQUEST, ETH_P_ARP, *(__be32*)(daddr), skb->dev,
+				0, dest_hw, src_hw, NULL);
+	if (!skb2) {
+		printk_ratelimited(KERN_ERR "Failed to create proactive learning " \
+			"ARP request");
+		stats->ukn_unicast_arp_create_err++;
+		return;
+	}
+
+	/* copy the input vlan tag to arp probe */
+	vlan = skb_vlan_tag_get(skb);
+	if (vlan != 0) {
+		__vlan_hwaccel_put_tag(skb2, cpu_to_be16(ETH_P_8021Q), vlan);
+	}
+
+	dev_queue_xmit(skb2);
+	stats->ukn_unicast_total_probe_sent++;
+
+	return;
+}
+
 /* note: already called with rcu_read_lock */
 int br_handle_frame_finish(struct net *net, struct sock *sk, struct sk_buff *skb)
 {
@@ -194,6 +422,9 @@ int br_handle_frame_finish(struct net *net, struct sock *sk, struct sk_buff *skb
 			dst->used = now;
 		br_forward(dst->dst, skb, local_rcv, false);
 	} else {
+		if (pkt_type == BR_PKT_UNICAST) {
+			br_proactive_learn(br, p, skb);
+		}
 		if (!mcast_hit)
 			br_flood(br, skb, pkt_type, local_rcv, false);
 		else
diff --git a/net/bridge/br_netlink.c b/net/bridge/br_netlink.c
index d38eff277..b88188e96 100644
--- a/net/bridge/br_netlink.c
+++ b/net/bridge/br_netlink.c
@@ -188,6 +188,7 @@ static inline size_t br_port_info_size(void)
 		+ nla_total_size(1)	/* IFLA_BRPORT_NEIGH_SUPPRESS */
 		+ nla_total_size(1)	/* IFLA_BRPORT_ISOLATED */
 		+ nla_total_size(1)	/* IFLA_BRPORT_LOCKED */
+		+ nla_total_size(1) /* IFLA_BRPORT_SINK_CONNECTED */
 		+ nla_total_size(sizeof(struct ifla_bridge_id))	/* IFLA_BRPORT_ROOT_ID */
 		+ nla_total_size(sizeof(struct ifla_bridge_id))	/* IFLA_BRPORT_BRIDGE_ID */
 		+ nla_total_size(sizeof(u16))	/* IFLA_BRPORT_DESIGNATED_PORT */
@@ -253,6 +254,8 @@ static int br_port_fill_attrs(struct sk_buff *skb,
 	    nla_put_u8(skb, IFLA_BRPORT_PROXYARP, !!(p->flags & BR_PROXYARP)) ||
 	    nla_put_u8(skb, IFLA_BRPORT_PROXYARP_WIFI,
 		       !!(p->flags & BR_PROXYARP_WIFI)) ||
+	    nla_put_u8(skb, IFLA_BRPORT_SINK_CONNECTED,
+		       !!(p->flags & BR_SINK_CONNECTED)) ||
 	    nla_put(skb, IFLA_BRPORT_ROOT_ID, sizeof(struct ifla_bridge_id),
 		    &p->designated_root) ||
 	    nla_put(skb, IFLA_BRPORT_BRIDGE_ID, sizeof(struct ifla_bridge_id),
@@ -867,6 +870,7 @@ static const struct nla_policy br_port_policy[IFLA_BRPORT_MAX + 1] = {
 	[IFLA_BRPORT_UNICAST_FLOOD] = { .type = NLA_U8 },
 	[IFLA_BRPORT_PROXYARP]	= { .type = NLA_U8 },
 	[IFLA_BRPORT_PROXYARP_WIFI] = { .type = NLA_U8 },
+	[IFLA_BRPORT_SINK_CONNECTED] = { .type = NLA_U8 },
 	[IFLA_BRPORT_MULTICAST_ROUTER] = { .type = NLA_U8 },
 	[IFLA_BRPORT_MCAST_TO_UCAST] = { .type = NLA_U8 },
 	[IFLA_BRPORT_MCAST_FLOOD] = { .type = NLA_U8 },
@@ -939,6 +943,7 @@ static int br_setport(struct net_bridge_port *p, struct nlattr *tb[],
 	br_set_port_flag(p, tb, IFLA_BRPORT_BCAST_FLOOD, BR_BCAST_FLOOD);
 	br_set_port_flag(p, tb, IFLA_BRPORT_PROXYARP, BR_PROXYARP);
 	br_set_port_flag(p, tb, IFLA_BRPORT_PROXYARP_WIFI, BR_PROXYARP_WIFI);
+	br_set_port_flag(p, tb, IFLA_BRPORT_SINK_CONNECTED, BR_SINK_CONNECTED);
 	br_set_port_flag(p, tb, IFLA_BRPORT_VLAN_TUNNEL, BR_VLAN_TUNNEL);
 	br_set_port_flag(p, tb, IFLA_BRPORT_NEIGH_SUPPRESS, BR_NEIGH_SUPPRESS);
 	br_set_port_flag(p, tb, IFLA_BRPORT_ISOLATED, BR_ISOLATED);
diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index dfeaefa75..a08ddd0d2 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -432,6 +432,14 @@ static inline struct net_bridge_port *br_port_get_rtnl(const struct net_device *
 		rtnl_dereference(dev->rx_handler_data) : NULL;
 }
 
+struct ukn_unicast_stats
+{
+	unsigned long   ukn_unicast_total_rcvd;
+	unsigned long   ukn_unicast_ip_rcvd;
+	unsigned long   ukn_unicast_total_probe_sent;
+	unsigned long   ukn_unicast_arp_create_err;
+};
+
 static inline struct net_bridge_port *br_port_get_rtnl_rcu(const struct net_device *dev)
 {
 	return netif_is_bridge_port(dev) ?
@@ -547,6 +555,7 @@ struct net_bridge {
 #if IS_ENABLED(CONFIG_BRIDGE_CFM)
 	struct hlist_head		mep_list;
 #endif
+	struct ukn_unicast_stats __percpu *ukn_stats;
 };
 
 struct br_input_skb_cb {
diff --git a/net/bridge/br_sysfs_br.c b/net/bridge/br_sysfs_br.c
index ea7335422..cc0f7a301 100644
--- a/net/bridge/br_sysfs_br.c
+++ b/net/bridge/br_sysfs_br.c
@@ -933,6 +933,29 @@ static ssize_t vlan_stats_per_port_store(struct device *d,
 static DEVICE_ATTR_RW(vlan_stats_per_port);
 #endif
 
+static ssize_t ukn_unicast_stats_show(struct device *d,
+					 struct device_attribute *attr,
+					 char *buf)
+{
+	struct net_bridge *br = to_bridge(d);
+	struct ukn_unicast_stats sum = {0};
+	int cpu;
+
+	for_each_possible_cpu(cpu) {
+		const struct ukn_unicast_stats *stats = per_cpu_ptr(br->ukn_stats, cpu);
+		sum.ukn_unicast_total_rcvd += stats->ukn_unicast_total_rcvd;
+		sum.ukn_unicast_ip_rcvd += stats->ukn_unicast_ip_rcvd;
+		sum.ukn_unicast_total_probe_sent += stats->ukn_unicast_total_probe_sent;
+		sum.ukn_unicast_arp_create_err += stats->ukn_unicast_arp_create_err;
+	}
+	return sprintf(buf, "total_rcvd: %lu, ip_rcvd: %lu, total_probe_sent: %lu,"
+				" arp_create_err: %lu\n", sum.ukn_unicast_total_rcvd,
+				sum.ukn_unicast_ip_rcvd, sum.ukn_unicast_total_probe_sent,
+				sum.ukn_unicast_arp_create_err);
+}
+
+static DEVICE_ATTR_RO(ukn_unicast_stats);
+
 static struct attribute *bridge_attrs[] = {
 	&dev_attr_forward_delay.attr,
 	&dev_attr_hello_time.attr,
@@ -987,6 +1010,7 @@ static struct attribute *bridge_attrs[] = {
 	&dev_attr_vlan_stats_enabled.attr,
 	&dev_attr_vlan_stats_per_port.attr,
 #endif
+	&dev_attr_ukn_unicast_stats.attr,
 	NULL
 };
 
diff --git a/net/bridge/br_sysfs_if.c b/net/bridge/br_sysfs_if.c
index 74fdd8105..8f8058d3b 100644
--- a/net/bridge/br_sysfs_if.c
+++ b/net/bridge/br_sysfs_if.c
@@ -240,6 +240,7 @@ BRPORT_ATTR_FLAG(multicast_flood, BR_MCAST_FLOOD);
 BRPORT_ATTR_FLAG(broadcast_flood, BR_BCAST_FLOOD);
 BRPORT_ATTR_FLAG(neigh_suppress, BR_NEIGH_SUPPRESS);
 BRPORT_ATTR_FLAG(isolated, BR_ISOLATED);
+BRPORT_ATTR_FLAG(sink_connected, BR_SINK_CONNECTED);
 
 #ifdef CONFIG_BRIDGE_IGMP_SNOOPING
 static ssize_t show_multicast_router(struct net_bridge_port *p, char *buf)
@@ -293,6 +294,7 @@ static const struct brport_attribute *brport_attrs[] = {
 	&brport_attr_neigh_suppress,
 	&brport_attr_isolated,
 	&brport_attr_backup_port,
+	&brport_attr_sink_connected,
 	NULL
 };
 
diff --git a/net/core/rtnetlink.c b/net/core/rtnetlink.c
index ac379e459..f484ebcbd 100644
--- a/net/core/rtnetlink.c
+++ b/net/core/rtnetlink.c
@@ -57,7 +57,7 @@
 #include "dev.h"
 
 #define RTNL_MAX_TYPE		50
-#define RTNL_SLAVE_MAX_TYPE	40
+#define RTNL_SLAVE_MAX_TYPE	42
 
 struct rtnl_link {
 	rtnl_doit_func		doit;
@@ -4835,6 +4835,8 @@ int ndo_dflt_bridge_getlink(struct sk_buff *skb, u32 pid, u32 seq,
 				IFLA_BRPORT_LEARNING_SYNC, BR_LEARNING_SYNC) ||
 	    brport_nla_put_flag(skb, flags, mask,
 				IFLA_BRPORT_UNICAST_FLOOD, BR_FLOOD) ||
+	    brport_nla_put_flag(skb, flags, mask,
+				IFLA_BRPORT_SINK_CONNECTED, BR_SINK_CONNECTED) ||
 	    brport_nla_put_flag(skb, flags, mask,
 				IFLA_BRPORT_PROXYARP, BR_PROXYARP) ||
 	    brport_nla_put_flag(skb, flags, mask,
-- 
2.39.0
