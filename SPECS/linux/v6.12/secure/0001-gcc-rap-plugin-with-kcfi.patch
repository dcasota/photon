From 00fd6ab91b030d203b9f5d0fadc5bb91958838e2 Mon Sep 17 00:00:00 2001
From: Keerthana K <keerthana.kalyanasundaram@broadcom.com>
Date: Fri, 26 Jul 2024 10:51:50 +0000
Subject: [PATCH] gcc rap plugin with kcfi

This patch adopts the forward-edge control-flow integrity
scheme for Clang known as KCFI in gcc with the help
of RAP plugin.

The original RAP gcc plugin code developed by PaX team
is modified to adopt to kcfi implementation in kernel.

Following changes are made to adopt KCFI in GCC RAP plugin:

- Padding and hash size is changed to match with KCFI
- Function label and size paramter are added
  E.g:
0000000000000000 <__cfi_func>:
       0:       cc                      int3
       1:       cc                      int3
       2:       b8 a7 9e 9e 58          mov    $0x589e9ea7,%eax
       7:       cc                      int3
       8:       cc                      int3
- weak attribute handling and skip generation of rap hash
  for direct calls
- change the runtime comparison injection code of RAP plugin
  to use 4 bytes hash comparision instead of 8 bytes
- Add Kconfig changes to enable CFI_CLANG when PAX_RAP is 'y'
- Fix rap_hash injection for bpf_prog_run() to use int instead of
  long as the size of rap_hash is 4 bytes now
- KCFI code adds SYM_TYPED_FUNC_START which emits the type identifier
  before the assembly functions that are called indirectly from C code.
  As the padding and size of cfi_type and rap_hash_type is different,
  replaced __CFI_TYPE macro with __RAP_TYPE for adding rap_hash for
  callers of SYM_TYPED_FUNC_START when CONFIG_PAX_RAP is enabled.

[Srinidhi Rao<srinidhi.rao@broadcom.com> Back ported this patch to v6.6.x]

Signed-off-by: Keerthana K <keerthana.kalyanasundaram@broadcom.com>
Signed-off-by: Mukul Sikka <mukul.sikka@broadcom.com>

Signed-off-by: srinidhira0 <srinidhi.rao@broadcom.com>
---
 Makefile                                      |   2 +
 arch/Kconfig                                  |   8 +-
 arch/x86/Kconfig                              |   2 +-
 arch/x86/include/asm/text-patching.h          |   4 +
 arch/x86/include/asm/vermagic.h               |   9 +-
 arch/x86/kernel/alternative.c                 |   7 +
 arch/x86/kernel/cpu/vmware.c                  |   9 +-
 arch/x86/kernel/module.c                      |   6 +-
 arch/x86/kernel/traps.c                       |   4 +
 arch/x86/tools/relocs.c                       |   3 +
 drivers/block/floppy.c                        |  11 +-
 drivers/firmware/dmi-id.c                     |   7 +-
 drivers/net/ethernet/brocade/bna/bnad.c       |  11 +-
 drivers/scsi/bfa/bfa.h                        |   4 +-
 drivers/scsi/bfa/bfa_cs.h                     | 124 +++-
 drivers/scsi/bfa/bfa_fcpim.h                  |  12 +-
 drivers/scsi/bfa/bfa_fcs.h                    |  34 +-
 drivers/scsi/bfa/bfa_fcs_fcpim.c              |   6 +-
 drivers/scsi/bfa/bfa_fcs_lport.c              |   4 +-
 drivers/scsi/bfa/bfa_fcs_rport.c              |   4 +-
 drivers/scsi/bfa/bfa_ioc.c                    |   8 +-
 drivers/scsi/bfa/bfa_ioc.h                    |  12 +-
 drivers/scsi/bfa/bfa_svc.c                    |  12 +-
 drivers/scsi/bfa/bfa_svc.h                    |  20 +-
 drivers/scsi/bfa/bfad.c                       |  12 +-
 drivers/scsi/bfa/bfad_drv.h                   |   5 +-
 include/linux/compiler_types.h                |   6 +-
 include/linux/moduleparam.h                   |   4 +-
 include/linux/pci.h                           |   2 +-
 include/linux/syscalls.h                      |  17 +-
 kernel/bpf/core.c                             |  21 +
 kernel/events/core.c                          |   3 +-
 kernel/module/main.c                          |   9 +
 kernel/sched/core.c                           |   2 +-
 net/bridge/br_private.h                       |   3 +-
 net/netfilter/ipset/ip_set_core.c             |   1 -
 scripts/Makefile.gcc-plugins                  |  12 +
 scripts/gcc-plugins/Makefile                  |   8 +-
 scripts/gcc-plugins/rap_plugin/rap.h          |  38 ++
 .../gcc-plugins/rap_plugin/rap_fptr_pass.c    | 224 +++++++
 scripts/gcc-plugins/rap_plugin/rap_hash.c     | 396 +++++++++++++
 scripts/gcc-plugins/rap_plugin/rap_plugin.c   | 557 ++++++++++++++++++
 scripts/gcc-plugins/rap_plugin/sip.c          |  96 +++
 scripts/mod/modpost.c                         |   6 -
 security/Kconfig                              |  29 +
 51 files changed, 1798 insertions(+), 148 deletions(-)
 create mode 100644 scripts/gcc-plugins/rap_plugin/rap.h
 create mode 100644 scripts/gcc-plugins/rap_plugin/rap_fptr_pass.c
 create mode 100644 scripts/gcc-plugins/rap_plugin/rap_hash.c
 create mode 100644 scripts/gcc-plugins/rap_plugin/rap_plugin.c
 create mode 100644 scripts/gcc-plugins/rap_plugin/sip.c

diff --git a/Makefile b/Makefile
index a3839877aafd..13bb55d6347a 100644
--- a/Makefile
+++ b/Makefile
@@ -976,10 +976,12 @@ export CC_FLAGS_LTO
 endif
 
 ifdef CONFIG_CFI_CLANG
+ifdef CONFIG_KCFI_CLANG
 CC_FLAGS_CFI	:= -fsanitize=kcfi
 KBUILD_CFLAGS	+= $(CC_FLAGS_CFI)
 export CC_FLAGS_CFI
 endif
+endif
 
 ifneq ($(CONFIG_FUNCTION_ALIGNMENT),0)
 KBUILD_CFLAGS += -falign-functions=$(CONFIG_FUNCTION_ALIGNMENT)
diff --git a/arch/Kconfig b/arch/Kconfig
index 20c2c93d2c88..6c5bb9651096 100644
--- a/arch/Kconfig
+++ b/arch/Kconfig
@@ -802,10 +802,16 @@ config ARCH_SUPPORTS_CFI_CLANG
 config ARCH_USES_CFI_TRAPS
 	bool
 
+config KCFI_CLANG
+	bool "Use Clang's Kernel Control Flow Integrity (KCFI)"
+	depends on $(cc-option,-fsanitize=kcfi)
+	help
+	  This option is Clang's Kernel Control Flow Integrity checking
+
 config CFI_CLANG
 	bool "Use Clang's Control Flow Integrity (CFI)"
 	depends on ARCH_SUPPORTS_CFI_CLANG
-	depends on $(cc-option,-fsanitize=kcfi)
+	depends on GCC_PLUGINS || KCFI_CLANG
 	help
 	  This option enables Clangâ€™s forward-edge Control Flow Integrity
 	  (CFI) checking, where the compiler injects a runtime check to each
diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig
index 0ca3130c6c8f..c737526635f5 100644
--- a/arch/x86/Kconfig
+++ b/arch/x86/Kconfig
@@ -2406,7 +2406,7 @@ config CALL_PADDING
 
 config FINEIBT
 	def_bool y
-	depends on X86_KERNEL_IBT && CFI_CLANG && RETPOLINE
+	depends on X86_KERNEL_IBT && KCFI_CLANG && MITIGATION_RETPOLINE
 	select CALL_PADDING
 
 config HAVE_CALL_THUNKS
diff --git a/arch/x86/include/asm/text-patching.h b/arch/x86/include/asm/text-patching.h
index 29832c338cdc..a73ecab16ead 100644
--- a/arch/x86/include/asm/text-patching.h
+++ b/arch/x86/include/asm/text-patching.h
@@ -53,6 +53,10 @@ extern void text_poke_bp(void *addr, const void *opcode, size_t len, const void
 extern void text_poke_queue(void *addr, const void *opcode, size_t len, const void *emulate);
 extern void text_poke_finish(void);
 
+#ifdef CONFIG_PAX_RAP
+extern void *memcpy_alt(void *addr, const void *opcode, size_t len);
+#endif
+
 #define INT3_INSN_SIZE		1
 #define INT3_INSN_OPCODE	0xCC
 
diff --git a/arch/x86/include/asm/vermagic.h b/arch/x86/include/asm/vermagic.h
index 75884d2cdec3..266f5ce89639 100644
--- a/arch/x86/include/asm/vermagic.h
+++ b/arch/x86/include/asm/vermagic.h
@@ -5,6 +5,7 @@
 
 #ifdef CONFIG_X86_64
 /* X86_64 does not define MODULE_PROC_FAMILY */
+#define MODULE_PROC_FAMILY ""
 #elif defined CONFIG_M486SX
 #define MODULE_PROC_FAMILY "486SX "
 #elif defined CONFIG_M486
@@ -59,10 +60,12 @@
 #error unknown processor family
 #endif
 
-#ifdef CONFIG_X86_32
-# define MODULE_ARCH_VERMAGIC MODULE_PROC_FAMILY
+#ifdef CONFIG_PAX_RAP
+#define MODULE_PAX_RAP "RAP "
 #else
-# define MODULE_ARCH_VERMAGIC ""
+#define MODULE_PAX_RAP ""
 #endif
 
+#define MODULE_ARCH_VERMAGIC MODULE_PROC_FAMILY MODULE_PAX_RAP
+
 #endif /* _ASM_VERMAGIC_H */
diff --git a/arch/x86/kernel/alternative.c b/arch/x86/kernel/alternative.c
index aae7456ece07..4528ef4726b9 100644
--- a/arch/x86/kernel/alternative.c
+++ b/arch/x86/kernel/alternative.c
@@ -1915,6 +1915,13 @@ void *text_poke(void *addr, const void *opcode, size_t len)
 	return __text_poke(text_poke_memcpy, addr, opcode, len);
 }
 
+#ifdef CONFIG_PAX_RAP
+void *memcpy_alt(void *addr, const void *opcode, size_t len)
+{
+    return memcpy(addr, opcode, len);
+}
+#endif
+
 /**
  * text_poke_kgdb - Update instructions on a live kernel by kgdb
  * @addr: address to modify
diff --git a/arch/x86/kernel/cpu/vmware.c b/arch/x86/kernel/cpu/vmware.c
index 11f83d07925e..e26d67eed850 100644
--- a/arch/x86/kernel/cpu/vmware.c
+++ b/arch/x86/kernel/cpu/vmware.c
@@ -326,10 +326,17 @@ static __init int activate_jump_labels(void)
 }
 arch_initcall(activate_jump_labels);
 
+/*
+ * No need for any "IO delay" on VMware hypervisor
+ */
+static void vmware_io_delay(void)
+{
+}
+
 static void __init vmware_paravirt_ops_setup(void)
 {
 	pv_info.name = "VMware hypervisor";
-	pv_ops.cpu.io_delay = paravirt_nop;
+	pv_ops.cpu.io_delay = vmware_io_delay;
 
 	if (vmware_tsc_khz == 0)
 		return;
diff --git a/arch/x86/kernel/module.c b/arch/x86/kernel/module.c
index 5f71a0cf4399..a87b476e27ed 100644
--- a/arch/x86/kernel/module.c
+++ b/arch/x86/kernel/module.c
@@ -231,7 +231,11 @@ static int write_relocate_add(Elf64_Shdr *sechdrs,
 {
 	int ret;
 	bool early = me->state == MODULE_STATE_UNFORMED;
-	void *(*write)(void *, const void *, size_t) = memcpy;
+#ifdef CONFIG_PAX_RAP
+    void *(*write)(void *, const void *, size_t) = memcpy_alt;
+#else
+    void *(*write)(void *, const void *, size_t) = memcpy;
+#endif
 
 	if (!early) {
 		write = text_poke;
diff --git a/arch/x86/kernel/traps.c b/arch/x86/kernel/traps.c
index c876f1d36a81..e833c1fc48ce 100644
--- a/arch/x86/kernel/traps.c
+++ b/arch/x86/kernel/traps.c
@@ -109,6 +109,10 @@ do_trap_no_signal(struct task_struct *tsk, int trapnr, const char *str,
 
 		tsk->thread.error_code = error_code;
 		tsk->thread.trap_nr = trapnr;
+#ifdef CONFIG_PAX_RAP
+		if (trapnr == X86_TRAP_UD)
+			str = "PAX: overwritten function pointer or return address detected";
+#endif
 		die(str, regs, error_code);
 	} else {
 		if (fixup_vdso_exception(regs, trapnr, error_code, 0))
diff --git a/arch/x86/tools/relocs.c b/arch/x86/tools/relocs.c
index e7013283640f..3d78c48e4460 100644
--- a/arch/x86/tools/relocs.c
+++ b/arch/x86/tools/relocs.c
@@ -57,6 +57,9 @@ static const char * const sym_regex_kernel[S_NSYMTYPES] = {
 	"xen_save_fl_direct_reloc$|"
 	"VDSO|"
 	"__kcfi_typeid_|"
+#if 0
+	"__rap_hash_|"
+#endif
 	"__crc_)",
 
 /*
diff --git a/drivers/block/floppy.c b/drivers/block/floppy.c
index ea4eb88a2e45..c754ce9282bd 100644
--- a/drivers/block/floppy.c
+++ b/drivers/block/floppy.c
@@ -530,14 +530,13 @@ static struct format_descr format_req;
 static char *floppy_track_buffer;
 static int max_buffer_sectors;
 
-typedef void (*done_f)(int);
 static const struct cont_t {
 	void (*interrupt)(void);
 				/* this is called after the interrupt of the
 				 * main command */
 	void (*redo)(void);	/* this is called to retry the operation */
 	void (*error)(void);	/* this is called to tally an error */
-	done_f done;		/* this is called to say if the operation has
+	void (*done)(int);		/* this is called to say if the operation has
 				 * succeeded/failed */
 } *cont;
 
@@ -985,6 +984,10 @@ static void empty(void)
 {
 }
 
+static void empty_done(int)
+{
+}
+
 static void (*floppy_work_fn)(void);
 
 static void floppy_work_workfn(struct work_struct *work)
@@ -1998,14 +2001,14 @@ static const struct cont_t wakeup_cont = {
 	.interrupt	= empty,
 	.redo		= do_wakeup,
 	.error		= empty,
-	.done		= (done_f)empty
+	.done		= empty_done
 };
 
 static const struct cont_t intr_cont = {
 	.interrupt	= empty,
 	.redo		= process_fd_request,
 	.error		= empty,
-	.done		= (done_f)empty
+	.done		= empty_done
 };
 
 /* schedules handler, waiting for completion. May be interrupted, will then
diff --git a/drivers/firmware/dmi-id.c b/drivers/firmware/dmi-id.c
index 5f3a3e913d28..d19c78a78ae3 100644
--- a/drivers/firmware/dmi-id.c
+++ b/drivers/firmware/dmi-id.c
@@ -169,9 +169,14 @@ static int dmi_dev_uevent(const struct device *dev, struct kobj_uevent_env *env)
 	return 0;
 }
 
+static void dmi_dev_release(struct device *dev)
+{
+	kfree(dev);
+}
+
 static struct class dmi_class = {
 	.name = "dmi",
-	.dev_release = (void(*)(struct device *)) kfree,
+	.dev_release = dmi_dev_release,
 	.dev_uevent = dmi_dev_uevent,
 };
 
diff --git a/drivers/net/ethernet/brocade/bna/bnad.c b/drivers/net/ethernet/brocade/bna/bnad.c
index 31191b520b58..d5ce711a9ade 100644
--- a/drivers/net/ethernet/brocade/bna/bnad.c
+++ b/drivers/net/ethernet/brocade/bna/bnad.c
@@ -1091,8 +1091,9 @@ bnad_cb_tx_resume(struct bnad *bnad, struct bna_tx *tx)
  * Free all TxQs buffers and then notify TX_E_CLEANUP_DONE to Tx fsm.
  */
 static void
-bnad_tx_cleanup(struct delayed_work *work)
+bnad_tx_cleanup(struct work_struct *_work)
 {
+	struct delayed_work *work = (struct delayed_work *)_work;
 	struct bnad_tx_info *tx_info =
 		container_of(work, struct bnad_tx_info, tx_cleanup_work);
 	struct bnad *bnad = NULL;
@@ -1170,7 +1171,7 @@ bnad_cb_rx_stall(struct bnad *bnad, struct bna_rx *rx)
  * Free all RxQs buffers and then notify RX_E_CLEANUP_DONE to Rx fsm.
  */
 static void
-bnad_rx_cleanup(void *work)
+bnad_rx_cleanup(struct work_struct *work)
 {
 	struct bnad_rx_info *rx_info =
 		container_of(work, struct bnad_rx_info, rx_cleanup_work);
@@ -1991,8 +1992,7 @@ bnad_setup_tx(struct bnad *bnad, u32 tx_id)
 	}
 	tx_info->tx = tx;
 
-	INIT_DELAYED_WORK(&tx_info->tx_cleanup_work,
-			(work_func_t)bnad_tx_cleanup);
+	INIT_DELAYED_WORK(&tx_info->tx_cleanup_work, bnad_tx_cleanup);
 
 	/* Register ISR for the Tx object */
 	if (intr_info->intr_type == BNA_INTR_T_MSIX) {
@@ -2248,8 +2248,7 @@ bnad_setup_rx(struct bnad *bnad, u32 rx_id)
 	rx_info->rx = rx;
 	spin_unlock_irqrestore(&bnad->bna_lock, flags);
 
-	INIT_WORK(&rx_info->rx_cleanup_work,
-			(work_func_t)(bnad_rx_cleanup));
+	INIT_WORK(&rx_info->rx_cleanup_work, bnad_rx_cleanup);
 
 	/*
 	 * Init NAPI, so that state is set to NAPI_STATE_SCHED,
diff --git a/drivers/scsi/bfa/bfa.h b/drivers/scsi/bfa/bfa.h
index f30fe324e6ec..f4a755651c03 100644
--- a/drivers/scsi/bfa/bfa.h
+++ b/drivers/scsi/bfa/bfa.h
@@ -215,8 +215,10 @@ struct bfa_faa_args_s {
 	bfa_boolean_t		busy;
 };
 
+enum iocfc_event;
+
 struct bfa_iocfc_s {
-	bfa_fsm_t		fsm;
+	void (*fsm)(struct bfa_iocfc_s *, enum iocfc_event);
 	struct bfa_s		*bfa;
 	struct bfa_iocfc_cfg_s	cfg;
 	u32		req_cq_pi[BFI_IOC_MAX_CQS];
diff --git a/drivers/scsi/bfa/bfa_cs.h b/drivers/scsi/bfa/bfa_cs.h
index 6b606bf589b4..aac8ad1f50d3 100644
--- a/drivers/scsi/bfa/bfa_cs.h
+++ b/drivers/scsi/bfa/bfa_cs.h
@@ -176,8 +176,6 @@ bfa_q_is_on_q_func(struct list_head *q, struct list_head *qe)
  * @ BFA state machine interfaces
  */
 
-typedef void (*bfa_sm_t)(void *sm, int event);
-
 /*
  * oc - object class eg. bfa_ioc
  * st - state, eg. reset
@@ -187,20 +185,75 @@ typedef void (*bfa_sm_t)(void *sm, int event);
 #define bfa_sm_state_decl(oc, st, otype, etype)		\
 	static void oc ## _sm_ ## st(otype * fsm, etype event)
 
-#define bfa_sm_set_state(_sm, _state)	((_sm)->sm = (bfa_sm_t)(_state))
+#define bfa_sm_set_state(_sm, _state)	((_sm)->sm = (_state))
 #define bfa_sm_send_event(_sm, _event)	((_sm)->sm((_sm), (_event)))
 #define bfa_sm_get_state(_sm)		((_sm)->sm)
-#define bfa_sm_cmp_state(_sm, _state)	((_sm)->sm == (bfa_sm_t)(_state))
+#define bfa_sm_cmp_state(_sm, _state)	((_sm)->sm == (_state))
 
 /*
  * For converting from state machine function to state encoding.
  */
-struct bfa_sm_table_s {
-	bfa_sm_t	sm;	/*  state machine function	*/
+struct bfa_iocpf_s;
+enum iocpf_event;
+typedef void (*bfa_fsm_iocpf_t)(struct bfa_iocpf_s *, enum iocpf_event);
+
+struct iocpf_sm_table_s {
+	bfa_fsm_iocpf_t sm;	/*  state machine function	*/
+	int		state;	/*  state machine encoding	*/
+	char		*name;	/*  state name for display	*/
+};
+
+struct bfa_ioc_s;
+enum ioc_event;
+typedef void (*bfa_fsm_ioc_t)(struct bfa_ioc_s *, enum ioc_event);
+
+struct ioc_sm_table_s {
+	bfa_fsm_ioc_t sm;	/*  state machine function	*/
 	int		state;	/*  state machine encoding	*/
 	char		*name;	/*  state name for display	*/
 };
-#define BFA_SM(_sm)	((bfa_sm_t)(_sm))
+
+struct bfa_fcs_rport_s;
+enum rport_event;
+typedef void(*bfa_fcs_rport_t)(struct bfa_fcs_rport_s *, enum rport_event);
+
+struct rport_sm_table_s {
+	bfa_fcs_rport_t sm;	/*  state machine function	*/
+	int		state;	/*  state machine encoding	*/
+	char		*name;	/*  state name for display	*/
+};
+
+struct bfa_fcs_vport_s;
+enum bfa_fcs_vport_event;
+typedef void(*bfa_fcs_vport_t)(struct bfa_fcs_vport_s *, enum bfa_fcs_vport_event);
+
+struct vport_sm_table_s {
+	bfa_fcs_vport_t sm;	/*  state machine function	*/
+	int		state;	/*  state machine encoding	*/
+	char		*name;	/*  state name for display	*/
+};
+
+struct bfa_fcs_itnim_s;
+enum bfa_fcs_itnim_event;
+typedef void(*bfa_fcs_itnim_t)(struct bfa_fcs_itnim_s *, enum bfa_fcs_itnim_event);
+
+struct itnim_sm_table_s {
+	bfa_fcs_itnim_t sm;	/*  state machine function	*/
+	int		state;	/*  state machine encoding	*/
+	char		*name;	/*  state name for display	*/
+};
+
+struct bfa_fcport_s;
+enum bfa_fcport_sm_event;
+typedef void(*bfa_fcport_t)(struct bfa_fcport_s *, enum bfa_fcport_sm_event);
+
+struct fcport_sm_table_s {
+	bfa_fcport_t sm;	/*  state machine function	*/
+	int		state;	/*  state machine encoding	*/
+	char		*name;	/*  state name for display	*/
+};
+
+#define BFA_SM(_sm)	(_sm)
 
 /*
  * State machine with entry actions.
@@ -218,17 +271,66 @@ typedef void (*bfa_fsm_t)(void *fsm, int event);
 	static void oc ## _sm_ ## st ## _entry(otype * fsm)
 
 #define bfa_fsm_set_state(_fsm, _state) do {	\
-	(_fsm)->fsm = (bfa_fsm_t)(_state);      \
+	(_fsm)->fsm = (_state);      \
 	_state ## _entry(_fsm);      \
 } while (0)
 
 #define bfa_fsm_send_event(_fsm, _event)	((_fsm)->fsm((_fsm), (_event)))
 #define bfa_fsm_get_state(_fsm)			((_fsm)->fsm)
-#define bfa_fsm_cmp_state(_fsm, _state)		\
-	((_fsm)->fsm == (bfa_fsm_t)(_state))
+#define bfa_fsm_cmp_state(_fsm, _state)		((_fsm)->fsm == (_state))
+
+static inline int
+iocpf_sm_to_state(struct iocpf_sm_table_s *smt, bfa_fsm_iocpf_t sm)
+{
+	int	i = 0;
+
+	while (smt[i].sm && smt[i].sm != sm)
+		i++;
+	return smt[i].state;
+}
+
+static inline int
+ioc_sm_to_state(struct ioc_sm_table_s *smt, bfa_fsm_ioc_t sm)
+{
+	int	i = 0;
+
+	while (smt[i].sm && smt[i].sm != sm)
+		i++;
+	return smt[i].state;
+}
+
+static inline int
+rport_sm_to_state(struct rport_sm_table_s *smt, bfa_fcs_rport_t sm)
+{
+	int	i = 0;
+
+	while (smt[i].sm && smt[i].sm != sm)
+		i++;
+	return smt[i].state;
+}
+
+static inline int
+vport_sm_to_state(struct vport_sm_table_s *smt, bfa_fcs_vport_t sm)
+{
+	int	i = 0;
+
+	while (smt[i].sm && smt[i].sm != sm)
+		i++;
+	return smt[i].state;
+}
+
+static inline int
+itnim_sm_to_state(struct itnim_sm_table_s *smt, bfa_fcs_itnim_t sm)
+{
+	int	i = 0;
+
+	while (smt[i].sm && smt[i].sm != sm)
+		i++;
+	return smt[i].state;
+}
 
 static inline int
-bfa_sm_to_state(struct bfa_sm_table_s *smt, bfa_sm_t sm)
+fcport_sm_to_state(struct fcport_sm_table_s *smt, bfa_fcport_t sm)
 {
 	int	i = 0;
 
diff --git a/drivers/scsi/bfa/bfa_fcpim.h b/drivers/scsi/bfa/bfa_fcpim.h
index 8bf09433549b..060af3ac4fa2 100644
--- a/drivers/scsi/bfa/bfa_fcpim.h
+++ b/drivers/scsi/bfa/bfa_fcpim.h
@@ -157,9 +157,11 @@ struct bfa_fcp_mod_s {
 /*
  * BFA IO (initiator mode)
  */
+enum bfa_ioim_event;
+
 struct bfa_ioim_s {
 	struct list_head	qe;		/*  queue elememt	*/
-	bfa_sm_t		sm;		/*  BFA ioim state machine */
+	void (*sm)(struct bfa_ioim_s *, enum bfa_ioim_event);/*  BFA ioim state machine */
 	struct bfa_s		*bfa;		/*  BFA module	*/
 	struct bfa_fcpim_s	*fcpim;		/*  parent fcpim module */
 	struct bfa_itnim_s	*itnim;		/*  i-t-n nexus for this IO  */
@@ -189,9 +191,11 @@ struct bfa_ioim_sp_s {
 /*
  * BFA Task management command (initiator mode)
  */
+enum bfa_tskim_event;
+
 struct bfa_tskim_s {
 	struct list_head	qe;
-	bfa_sm_t		sm;
+	void (*sm)(struct bfa_tskim_s *, enum bfa_tskim_event);
 	struct bfa_s		*bfa;	/*  BFA module  */
 	struct bfa_fcpim_s	*fcpim;	/*  parent fcpim module	*/
 	struct bfa_itnim_s	*itnim;	/*  i-t-n nexus for this IO  */
@@ -211,9 +215,11 @@ struct bfa_tskim_s {
 /*
  * BFA i-t-n (initiator mode)
  */
+enum bfa_itnim_event;
+
 struct bfa_itnim_s {
 	struct list_head	qe;	/*  queue element	*/
-	bfa_sm_t		sm;	/*  i-t-n im BFA state machine  */
+	void (*sm)(struct bfa_itnim_s *, enum bfa_itnim_event);/*  i-t-n im BFA state machine  */
 	struct bfa_s		*bfa;	/*  bfa instance	*/
 	struct bfa_rport_s	*rport;	/*  bfa rport	*/
 	void			*ditn;	/*  driver i-t-n structure	*/
diff --git a/drivers/scsi/bfa/bfa_fcs.h b/drivers/scsi/bfa/bfa_fcs.h
index c1baf5cd0d3e..733a2993b78a 100644
--- a/drivers/scsi/bfa/bfa_fcs.h
+++ b/drivers/scsi/bfa/bfa_fcs.h
@@ -59,8 +59,10 @@ struct bfa_fcs_s;
 #define BFA_FCS_PID_IS_WKA(pid)  ((bfa_ntoh3b(pid) > 0xFFF000) ?  1 : 0)
 #define BFA_FCS_MAX_RPORT_LOGINS 1024
 
+enum vport_ns_event;
+
 struct bfa_fcs_lport_ns_s {
-	bfa_sm_t        sm;		/*  state machine */
+	void (*sm)(struct bfa_fcs_lport_ns_s *, enum vport_ns_event);/*  state machine */
 	struct bfa_timer_s timer;
 	struct bfa_fcs_lport_s *port;	/*  parent port */
 	struct bfa_fcxp_s *fcxp;
@@ -69,18 +71,20 @@ struct bfa_fcs_lport_ns_s {
 	u8	num_rsnn_nn_retries;
 };
 
+enum port_scn_event;
 
 struct bfa_fcs_lport_scn_s {
-	bfa_sm_t        sm;		/*  state machine */
+	void (*sm)(struct bfa_fcs_lport_scn_s *, enum port_scn_event);/*  state machine */
 	struct bfa_timer_s timer;
 	struct bfa_fcs_lport_s *port;	/*  parent port */
 	struct bfa_fcxp_s *fcxp;
 	struct bfa_fcxp_wqe_s fcxp_wqe;
 };
 
+enum port_fdmi_event;
 
 struct bfa_fcs_lport_fdmi_s {
-	bfa_sm_t        sm;		/*  state machine */
+	void (*sm)(struct bfa_fcs_lport_fdmi_s *, enum port_fdmi_event);/*  state machine */
 	struct bfa_timer_s timer;
 	struct bfa_fcs_lport_ms_s *ms;	/*  parent ms */
 	struct bfa_fcxp_s *fcxp;
@@ -89,9 +93,10 @@ struct bfa_fcs_lport_fdmi_s {
 	u8	rsvd[3];
 };
 
+enum port_ms_event;
 
 struct bfa_fcs_lport_ms_s {
-	bfa_sm_t        sm;		/*  state machine */
+	void (*sm)(struct bfa_fcs_lport_ms_s *, enum port_ms_event);/*  state machine */
 	struct bfa_timer_s timer;
 	struct bfa_fcs_lport_s *port;	/*  parent port */
 	struct bfa_fcxp_s *fcxp;
@@ -131,10 +136,11 @@ union bfa_fcs_lport_topo_u {
 	struct bfa_fcs_lport_n2n_s pn2n;
 };
 
+enum bfa_fcs_lport_event;
 
 struct bfa_fcs_lport_s {
 	struct list_head         qe;	/*  used by port/vport */
-	bfa_sm_t               sm;	/*  state machine */
+	void (*sm)(struct bfa_fcs_lport_s *, enum bfa_fcs_lport_event);	/*  state machine */
 	struct bfa_fcs_fabric_s *fabric;	/*  parent fabric */
 	struct bfa_lport_cfg_s  port_cfg;	/*  port configuration */
 	struct bfa_timer_s link_timer;	/*  timer for link offline */
@@ -171,10 +177,11 @@ enum bfa_fcs_fabric_type {
 	BFA_FCS_FABRIC_LOOP = 3,
 };
 
+enum bfa_fcs_fabric_event;
 
 struct bfa_fcs_fabric_s {
 	struct list_head   qe;		/*  queue element */
-	bfa_sm_t	 sm;		/*  state machine */
+	void (*sm)(struct bfa_fcs_fabric_s *, enum bfa_fcs_fabric_event); /*  state machine */
 	struct bfa_fcs_s *fcs;		/*  FCS instance */
 	struct bfa_fcs_lport_s  bport;	/*  base logical port */
 	enum bfa_fcs_fabric_type fab_type; /*  fabric type */
@@ -344,9 +351,11 @@ void            bfa_fcs_lport_scn_process_rscn(struct bfa_fcs_lport_s *port,
 					      struct fchs_s *rx_frame, u32 len);
 void		bfa_fcs_lport_lip_scn_online(bfa_fcs_lport_t *port);
 
+enum bfa_fcs_vport_event;
+
 struct bfa_fcs_vport_s {
 	struct list_head		qe;		/*  queue elem	*/
-	bfa_sm_t		sm;		/*  state machine	*/
+	void (*sm)(struct bfa_fcs_vport_s *, enum bfa_fcs_vport_event);/*  state machine	*/
 	bfa_fcs_lport_t		lport;		/*  logical port	*/
 	struct bfa_timer_s	timer;
 	struct bfad_vport_s	*vport_drv;	/*  Driver private	*/
@@ -398,8 +407,10 @@ struct bfa_fcs_tin_s;
 struct bfa_fcs_iprp_s;
 
 /* Rport Features (RPF) */
+enum rpf_event;
+
 struct bfa_fcs_rpf_s {
-	bfa_sm_t	sm;	/*  state machine */
+	void (*sm)(struct bfa_fcs_rpf_s *, enum rpf_event); /*  state machine */
 	struct bfa_fcs_rport_s *rport;	/*  parent rport */
 	struct bfa_timer_s	timer;	/*  general purpose timer */
 	struct bfa_fcxp_s	*fcxp;	/*  FCXP needed for discarding */
@@ -414,6 +425,8 @@ struct bfa_fcs_rpf_s {
 	 */
 };
 
+enum rport_event;
+
 struct bfa_fcs_rport_s {
 	struct list_head	qe;	/*  used by port/vport */
 	struct bfa_fcs_lport_s *port;	/*  parent FCS port */
@@ -430,7 +443,7 @@ struct bfa_fcs_rport_s {
 	wwn_t	pwwn;	/*  port wwn of rport */
 	wwn_t	nwwn;	/*  node wwn of rport */
 	struct bfa_rport_symname_s psym_name; /*  port symbolic name  */
-	bfa_sm_t	sm;		/*  state machine */
+	void (*sm)(struct bfa_fcs_rport_s *, enum rport_event); /*  state machine */
 	struct bfa_timer_s timer;	/*  general purpose timer */
 	struct bfa_fcs_itnim_s *itnim;	/*  ITN initiator mode role */
 	struct bfa_fcs_tin_s *tin;	/*  ITN initiator mode role */
@@ -491,9 +504,10 @@ void  bfa_fcs_rpf_rport_offline(struct bfa_fcs_rport_s *rport);
  * forward declarations
  */
 struct bfad_itnim_s;
+enum bfa_fcs_itnim_event;
 
 struct bfa_fcs_itnim_s {
-	bfa_sm_t		sm;		/*  state machine */
+	void (*sm)(struct bfa_fcs_itnim_s *, enum bfa_fcs_itnim_event);/*  state machine */
 	struct bfa_fcs_rport_s	*rport;		/*  parent remote rport  */
 	struct bfad_itnim_s	*itnim_drv;	/*  driver peer instance */
 	struct bfa_fcs_s	*fcs;		/*  fcs instance	*/
diff --git a/drivers/scsi/bfa/bfa_fcs_fcpim.c b/drivers/scsi/bfa/bfa_fcs_fcpim.c
index c7de62baeec9..27ccaf6a4786 100644
--- a/drivers/scsi/bfa/bfa_fcs_fcpim.c
+++ b/drivers/scsi/bfa/bfa_fcs_fcpim.c
@@ -52,7 +52,7 @@ static void	bfa_fcs_itnim_sm_hcb_offline(struct bfa_fcs_itnim_s *itnim,
 static void	bfa_fcs_itnim_sm_initiator(struct bfa_fcs_itnim_s *itnim,
 					   enum bfa_fcs_itnim_event event);
 
-static struct bfa_sm_table_s itnim_sm_table[] = {
+static struct itnim_sm_table_s itnim_sm_table[] = {
 	{BFA_SM(bfa_fcs_itnim_sm_offline), BFA_ITNIM_OFFLINE},
 	{BFA_SM(bfa_fcs_itnim_sm_prli_send), BFA_ITNIM_PRLI_SEND},
 	{BFA_SM(bfa_fcs_itnim_sm_prli), BFA_ITNIM_PRLI_SENT},
@@ -665,7 +665,7 @@ bfa_status_t
 bfa_fcs_itnim_get_online_state(struct bfa_fcs_itnim_s *itnim)
 {
 	bfa_trc(itnim->fcs, itnim->rport->pid);
-	switch (bfa_sm_to_state(itnim_sm_table, itnim->sm)) {
+	switch (itnim_sm_to_state(itnim_sm_table, itnim->sm)) {
 	case BFA_ITNIM_ONLINE:
 	case BFA_ITNIM_INITIATIOR:
 		return BFA_STATUS_OK;
@@ -765,7 +765,7 @@ bfa_fcs_itnim_attr_get(struct bfa_fcs_lport_s *port, wwn_t rpwwn,
 	if (itnim == NULL)
 		return BFA_STATUS_NO_FCPIM_NEXUS;
 
-	attr->state	    = bfa_sm_to_state(itnim_sm_table, itnim->sm);
+	attr->state	    = itnim_sm_to_state(itnim_sm_table, itnim->sm);
 	attr->retry	    = itnim->seq_rec;
 	attr->rec_support   = itnim->rec_support;
 	attr->conf_comp	    = itnim->conf_comp;
diff --git a/drivers/scsi/bfa/bfa_fcs_lport.c b/drivers/scsi/bfa/bfa_fcs_lport.c
index 008afd817087..198b2495e949 100644
--- a/drivers/scsi/bfa/bfa_fcs_lport.c
+++ b/drivers/scsi/bfa/bfa_fcs_lport.c
@@ -6037,7 +6037,7 @@ static void	bfa_fcs_vport_sm_stopping(struct bfa_fcs_vport_s *vport,
 static void	bfa_fcs_vport_sm_logo_for_stop(struct bfa_fcs_vport_s *vport,
 					enum bfa_fcs_vport_event event);
 
-static struct bfa_sm_table_s  vport_sm_table[] = {
+static struct vport_sm_table_s vport_sm_table[] = {
 	{BFA_SM(bfa_fcs_vport_sm_uninit), BFA_FCS_VPORT_UNINIT},
 	{BFA_SM(bfa_fcs_vport_sm_created), BFA_FCS_VPORT_CREATED},
 	{BFA_SM(bfa_fcs_vport_sm_offline), BFA_FCS_VPORT_OFFLINE},
@@ -6864,7 +6864,7 @@ bfa_fcs_vport_get_attr(struct bfa_fcs_vport_s *vport,
 	memset(attr, 0, sizeof(struct bfa_vport_attr_s));
 
 	bfa_fcs_lport_get_attr(&vport->lport, &attr->port_attr);
-	attr->vport_state = bfa_sm_to_state(vport_sm_table, vport->sm);
+	attr->vport_state = vport_sm_to_state(vport_sm_table, vport->sm);
 }
 
 
diff --git a/drivers/scsi/bfa/bfa_fcs_rport.c b/drivers/scsi/bfa/bfa_fcs_rport.c
index c21aa37b8adb..6db306c600e5 100644
--- a/drivers/scsi/bfa/bfa_fcs_rport.c
+++ b/drivers/scsi/bfa/bfa_fcs_rport.c
@@ -136,7 +136,7 @@ static void	bfa_fcs_rport_sm_fc4_off_delete(struct bfa_fcs_rport_s *rport,
 static void	bfa_fcs_rport_sm_delete_pending(struct bfa_fcs_rport_s *rport,
 						enum rport_event event);
 
-static struct bfa_sm_table_s rport_sm_table[] = {
+static struct rport_sm_table_s rport_sm_table[] = {
 	{BFA_SM(bfa_fcs_rport_sm_uninit), BFA_RPORT_UNINIT},
 	{BFA_SM(bfa_fcs_rport_sm_plogi_sending), BFA_RPORT_PLOGI},
 	{BFA_SM(bfa_fcs_rport_sm_plogiacc_sending), BFA_RPORT_ONLINE},
@@ -2964,7 +2964,7 @@ bfa_fcs_rport_send_ls_rjt(struct bfa_fcs_rport_s *rport, struct fchs_s *rx_fchs,
 int
 bfa_fcs_rport_get_state(struct bfa_fcs_rport_s *rport)
 {
-	return bfa_sm_to_state(rport_sm_table, rport->sm);
+	return rport_sm_to_state(rport_sm_table, rport->sm);
 }
 
 
diff --git a/drivers/scsi/bfa/bfa_ioc.c b/drivers/scsi/bfa/bfa_ioc.c
index e1ed1424fddb..478f67bd5fa6 100644
--- a/drivers/scsi/bfa/bfa_ioc.c
+++ b/drivers/scsi/bfa/bfa_ioc.c
@@ -140,7 +140,7 @@ bfa_fsm_state_decl(bfa_ioc, disabling, struct bfa_ioc_s, enum ioc_event);
 bfa_fsm_state_decl(bfa_ioc, disabled, struct bfa_ioc_s, enum ioc_event);
 bfa_fsm_state_decl(bfa_ioc, hwfail, struct bfa_ioc_s, enum ioc_event);
 
-static struct bfa_sm_table_s ioc_sm_table[] = {
+static struct ioc_sm_table_s ioc_sm_table[] = {
 	{BFA_SM(bfa_ioc_sm_uninit), BFA_IOC_UNINIT},
 	{BFA_SM(bfa_ioc_sm_reset), BFA_IOC_RESET},
 	{BFA_SM(bfa_ioc_sm_enabling), BFA_IOC_ENABLING},
@@ -228,7 +228,7 @@ bfa_fsm_state_decl(bfa_iocpf, disabling_sync, struct bfa_iocpf_s,
 						enum iocpf_event);
 bfa_fsm_state_decl(bfa_iocpf, disabled, struct bfa_iocpf_s, enum iocpf_event);
 
-static struct bfa_sm_table_s iocpf_sm_table[] = {
+static struct iocpf_sm_table_s iocpf_sm_table[] = {
 	{BFA_SM(bfa_iocpf_sm_reset), BFA_IOCPF_RESET},
 	{BFA_SM(bfa_iocpf_sm_fwcheck), BFA_IOCPF_FWMISMATCH},
 	{BFA_SM(bfa_iocpf_sm_mismatch), BFA_IOCPF_FWMISMATCH},
@@ -2815,12 +2815,12 @@ enum bfa_ioc_state
 bfa_ioc_get_state(struct bfa_ioc_s *ioc)
 {
 	enum bfa_iocpf_state iocpf_st;
-	enum bfa_ioc_state ioc_st = bfa_sm_to_state(ioc_sm_table, ioc->fsm);
+	enum bfa_ioc_state ioc_st = ioc_sm_to_state(ioc_sm_table, ioc->fsm);
 
 	if (ioc_st == BFA_IOC_ENABLING ||
 		ioc_st == BFA_IOC_FAIL || ioc_st == BFA_IOC_INITFAIL) {
 
-		iocpf_st = bfa_sm_to_state(iocpf_sm_table, ioc->iocpf.fsm);
+		iocpf_st = iocpf_sm_to_state(iocpf_sm_table, ioc->iocpf.fsm);
 
 		switch (iocpf_st) {
 		case BFA_IOCPF_SEMWAIT:
diff --git a/drivers/scsi/bfa/bfa_ioc.h b/drivers/scsi/bfa/bfa_ioc.h
index 5e568d6d7b26..cbf6c3f9250a 100644
--- a/drivers/scsi/bfa/bfa_ioc.h
+++ b/drivers/scsi/bfa/bfa_ioc.h
@@ -282,16 +282,20 @@ struct bfa_ioc_notify_s {
 	(__notify)->cbarg = (__cbarg);      \
 } while (0)
 
+enum iocpf_event;
+
 struct bfa_iocpf_s {
-	bfa_fsm_t		fsm;
+	void (*fsm)(struct bfa_iocpf_s *, enum iocpf_event);
 	struct bfa_ioc_s	*ioc;
 	bfa_boolean_t		fw_mismatch_notified;
 	bfa_boolean_t		auto_recover;
 	u32			poll_time;
 };
 
+enum ioc_event;
+
 struct bfa_ioc_s {
-	bfa_fsm_t		fsm;
+	void (*fsm)(struct bfa_ioc_s *, enum ioc_event);
 	struct bfa_s		*bfa;
 	struct bfa_pcidev_s	pcidev;
 	struct bfa_timer_mod_s	*timer_mod;
@@ -779,8 +783,10 @@ struct bfa_dconf_s {
 };
 #pragma pack()
 
+enum bfa_dconf_event;
+
 struct bfa_dconf_mod_s {
-	bfa_sm_t		sm;
+	void (*sm)(struct bfa_dconf_mod_s *, enum bfa_dconf_event);
 	u8			instance;
 	bfa_boolean_t		read_data_valid;
 	bfa_boolean_t		min_cfg;
diff --git a/drivers/scsi/bfa/bfa_svc.c b/drivers/scsi/bfa/bfa_svc.c
index c9745c0b4eee..500f6885587d 100644
--- a/drivers/scsi/bfa/bfa_svc.c
+++ b/drivers/scsi/bfa/bfa_svc.c
@@ -201,7 +201,7 @@ static void     bfa_fcport_ln_sm_up_dn_nf(struct bfa_fcport_ln_s *ln,
 static void     bfa_fcport_ln_sm_up_dn_up_nf(struct bfa_fcport_ln_s *ln,
 					enum bfa_fcport_ln_sm_event event);
 
-static struct bfa_sm_table_s hal_port_sm_table[] = {
+static struct fcport_sm_table_s hal_port_sm_table[] = {
 	{BFA_SM(bfa_fcport_sm_uninit), BFA_PORT_ST_UNINIT},
 	{BFA_SM(bfa_fcport_sm_enabling_qwait), BFA_PORT_ST_ENABLING_QWAIT},
 	{BFA_SM(bfa_fcport_sm_enabling), BFA_PORT_ST_ENABLING},
@@ -3545,7 +3545,7 @@ bfa_fcport_isr(struct bfa_s *bfa, struct bfi_msg_s *msg)
 	fcport->event_arg.i2hmsg = i2hmsg;
 
 	bfa_trc(bfa, msg->mhdr.msg_id);
-	bfa_trc(bfa, bfa_sm_to_state(hal_port_sm_table, fcport->sm));
+	bfa_trc(bfa, fcport_sm_to_state(hal_port_sm_table, fcport->sm));
 
 	switch (msg->mhdr.msg_id) {
 	case BFI_FCPORT_I2H_ENABLE_RSP:
@@ -3980,7 +3980,7 @@ bfa_fcport_get_attr(struct bfa_s *bfa, struct bfa_port_attr_s *attr)
 
 	attr->pport_cfg.path_tov  = bfa_fcpim_path_tov_get(bfa);
 	attr->pport_cfg.q_depth  = bfa_fcpim_qdepth_get(bfa);
-	attr->port_state = bfa_sm_to_state(hal_port_sm_table, fcport->sm);
+	attr->port_state = fcport_sm_to_state(hal_port_sm_table, fcport->sm);
 
 	attr->fec_state = fcport->fec_state;
 
@@ -4062,7 +4062,7 @@ bfa_fcport_is_disabled(struct bfa_s *bfa)
 {
 	struct bfa_fcport_s *fcport = BFA_FCPORT_MOD(bfa);
 
-	return bfa_sm_to_state(hal_port_sm_table, fcport->sm) ==
+	return fcport_sm_to_state(hal_port_sm_table, fcport->sm) ==
 		BFA_PORT_ST_DISABLED;
 
 }
@@ -4072,7 +4072,7 @@ bfa_fcport_is_dport(struct bfa_s *bfa)
 {
 	struct bfa_fcport_s *fcport = BFA_FCPORT_MOD(bfa);
 
-	return (bfa_sm_to_state(hal_port_sm_table, fcport->sm) ==
+	return (fcport_sm_to_state(hal_port_sm_table, fcport->sm) ==
 		BFA_PORT_ST_DPORT);
 }
 
@@ -4081,7 +4081,7 @@ bfa_fcport_is_ddport(struct bfa_s *bfa)
 {
 	struct bfa_fcport_s *fcport = BFA_FCPORT_MOD(bfa);
 
-	return (bfa_sm_to_state(hal_port_sm_table, fcport->sm) ==
+	return (fcport_sm_to_state(hal_port_sm_table, fcport->sm) ==
 		BFA_PORT_ST_DDPORT);
 }
 
diff --git a/drivers/scsi/bfa/bfa_svc.h b/drivers/scsi/bfa/bfa_svc.h
index 9c83109574e9..5a4ad66bcbff 100644
--- a/drivers/scsi/bfa/bfa_svc.h
+++ b/drivers/scsi/bfa/bfa_svc.h
@@ -152,6 +152,8 @@ struct bfa_fcxp_rsp_info_s {
 	u32	rsp_maxlen;	/*  max response length expected */
 };
 
+typedef void (*bfa_sm_t)(void *sm, int event);
+
 struct bfa_fcxp_s {
 	struct list_head	qe;		/*  fcxp queue element */
 	bfa_sm_t	sm;		/*  state machine */
@@ -287,9 +289,11 @@ struct bfa_rport_info_s {
 /*
  * BFA rport data structure
  */
+enum bfa_rport_event;
+
 struct bfa_rport_s {
 	struct list_head	qe;	/*  queue element		    */
-	bfa_sm_t	sm;		/*  state machine		    */
+	void (*sm)(struct bfa_rport_s *, enum bfa_rport_event);/*  state machine		    */
 	struct bfa_s	*bfa;		/*  backpointer to BFA		    */
 	void		*rport_drv;	/*  fcs/driver rport object	    */
 	u16	fw_handle;	/*  firmware rport handle	    */
@@ -380,10 +384,12 @@ void	bfa_uf_res_recfg(struct bfa_s *bfa, u16 num_uf_fw);
 /*
  * LPS - bfa lport login/logout service interface
  */
+enum bfa_lps_event;
+
 struct bfa_lps_s {
 	struct list_head	qe;	/*  queue element		*/
 	struct bfa_s	*bfa;		/*  parent bfa instance	*/
-	bfa_sm_t	sm;		/*  finite state machine	*/
+	void (*sm)(struct bfa_lps_s *, enum bfa_lps_event);/*  finite state machine	*/
 	u8		bfa_tag;	/*  lport tag		*/
 	u8		fw_tag;		/*  lport fw tag                */
 	u8		reqq;		/*  lport request queue	*/
@@ -442,9 +448,11 @@ void	bfa_lps_isr(struct bfa_s *bfa, struct bfi_msg_s *msg);
 /*
  * Link notification data structure
  */
+enum bfa_fcport_ln_sm_event;
+
 struct bfa_fcport_ln_s {
 	struct bfa_fcport_s	*fcport;
-	bfa_sm_t		sm;
+	void (*sm)(struct bfa_fcport_ln_s *, enum bfa_fcport_ln_sm_event);
 	struct bfa_cb_qe_s	ln_qe;	/*  BFA callback queue elem for ln */
 	enum bfa_port_linkstate ln_event; /*  ln event for callback */
 };
@@ -458,7 +466,7 @@ struct bfa_fcport_trunk_s {
  */
 struct bfa_fcport_s {
 	struct bfa_s		*bfa;	/*  parent BFA instance */
-	bfa_sm_t		sm;	/*  port state machine */
+	void (*sm)(struct bfa_fcport_s *, enum bfa_fcport_sm_event);	/*  port state machine */
 	wwn_t			nwwn;	/*  node wwn of physical port */
 	wwn_t			pwwn;	/*  port wwn of physical oprt */
 	enum bfa_port_speed speed_sup;
@@ -706,9 +714,11 @@ struct bfa_fcdiag_lb_s {
 	u32        status;
 };
 
+enum bfa_dport_sm_event;
+
 struct bfa_dport_s {
 	struct bfa_s	*bfa;		/* Back pointer to BFA	*/
-	bfa_sm_t	sm;		/* finite state machine */
+	void (*sm)(struct bfa_dport_s *, enum bfa_dport_sm_event);/* finite state machine */
 	struct bfa_reqq_wait_s reqq_wait;
 	bfa_cb_diag_t	cbfn;
 	void		*cbarg;
diff --git a/drivers/scsi/bfa/bfad.c b/drivers/scsi/bfa/bfad.c
index 62cb7a864fd5..13dcfb37edd3 100644
--- a/drivers/scsi/bfa/bfad.c
+++ b/drivers/scsi/bfa/bfad.c
@@ -400,6 +400,16 @@ bfad_hcb_comp(void *arg, bfa_status_t status)
 	complete(&fcomp->comp);
 }
 
+void
+bfad_stats_comp(void *arg, bfa_boolean_t _status)
+{
+	struct bfad_hal_comp *fcomp = (struct bfad_hal_comp *)arg;
+	bfa_status_t status = (bfa_status_t)_status;
+
+	fcomp->status = status;
+	complete(&fcomp->comp);
+}
+
 /*
  * bfa_init callback
  */
@@ -1424,7 +1434,7 @@ bfad_pci_remove(struct pci_dev *pdev)
  * PCI Error Recovery entry, error detected.
  */
 static pci_ers_result_t
-bfad_pci_error_detected(struct pci_dev *pdev, pci_channel_state_t state)
+bfad_pci_error_detected(struct pci_dev *pdev, enum pci_channel_state state)
 {
 	struct bfad_s *bfad = pci_get_drvdata(pdev);
 	unsigned long	flags;
diff --git a/drivers/scsi/bfa/bfad_drv.h b/drivers/scsi/bfa/bfad_drv.h
index 7682cfa34265..bb815507fa8b 100644
--- a/drivers/scsi/bfa/bfad_drv.h
+++ b/drivers/scsi/bfa/bfad_drv.h
@@ -178,8 +178,10 @@ union bfad_tmp_buf {
 /*
  * BFAD (PCI function) data structure
  */
+enum bfad_sm_event;
+
 struct bfad_s {
-	bfa_sm_t	sm;	/* state machine */
+	void (*sm)(struct bfad_s *, enum bfad_sm_event); /* state machine */
 	struct list_head list_entry;
 	struct bfa_s	bfa;
 	struct bfa_fcs_s bfa_fcs;
@@ -300,6 +302,7 @@ void		bfad_fcs_stop(struct bfad_s *bfad);
 void		bfad_remove_intr(struct bfad_s *bfad);
 void		bfad_hal_mem_release(struct bfad_s *bfad);
 void		bfad_hcb_comp(void *arg, bfa_status_t status);
+void		bfad_stats_comp(void *arg, bfa_boolean_t _status);
 
 int		bfad_setup_intr(struct bfad_s *bfad);
 void		bfad_remove_intr(struct bfad_s *bfad);
diff --git a/include/linux/compiler_types.h b/include/linux/compiler_types.h
index b2f9e2c409cf..f3a17f64c5d6 100644
--- a/include/linux/compiler_types.h
+++ b/include/linux/compiler_types.h
@@ -79,7 +79,7 @@ static inline void __chk_io_ptr(const volatile void __iomem *ptr) { }
 /* Attributes */
 #include <linux/compiler_attributes.h>
 
-#if CONFIG_FUNCTION_ALIGNMENT > 0
+#if !defined(CONFIG_PAX_RAP) && (CONFIG_FUNCTION_ALIGNMENT > 0)
 #define __function_aligned		__aligned(CONFIG_FUNCTION_ALIGNMENT)
 #else
 #define __function_aligned
@@ -394,6 +394,10 @@ struct ftrace_likely_data {
 			 __scalar_type_to_expr_cases(long long),	\
 			 default: (x)))
 
+#define __type_is_unsigned(t) \
+	(__same_type((t)0, 0UL) || __same_type((t)0, 0U) || \
+	__same_type((t)0, (unsigned short)0) || __same_type((t)0, (unsigned char)0))
+
 /* Is this type a native word size -- useful for atomic operations */
 #define __native_word(t) \
 	(sizeof(t) == sizeof(char) || sizeof(t) == sizeof(short) || \
diff --git a/include/linux/moduleparam.h b/include/linux/moduleparam.h
index 962cd41a2cb5..b503411267ad 100644
--- a/include/linux/moduleparam.h
+++ b/include/linux/moduleparam.h
@@ -354,7 +354,7 @@ static inline void kernel_param_unlock(struct module *mod)
  * @len is usually just sizeof(string).
  */
 #define module_param_string(name, string, len, perm)			\
-	static const struct kparam_string __param_string_##name		\
+	static const struct kparam_string __param_string_##name __used	\
 		= { len, string };					\
 	__module_param_call(MODULE_PARAM_PREFIX, name,			\
 			    &param_ops_string,				\
@@ -513,7 +513,7 @@ extern int param_set_bint(const char *val, const struct kernel_param *kp);
  */
 #define module_param_array_named(name, array, type, nump, perm)		\
 	param_check_##type(name, &(array)[0]);				\
-	static const struct kparam_array __param_arr_##name		\
+	static const struct kparam_array __param_arr_##name __used	\
 	= { .max = ARRAY_SIZE(array), .num = nump,                      \
 	    .ops = &param_ops_##type,					\
 	    .elemsize = sizeof(array[0]), .elem = array };		\
diff --git a/include/linux/pci.h b/include/linux/pci.h
index b548d5646a86..c70da725d8b6 100644
--- a/include/linux/pci.h
+++ b/include/linux/pci.h
@@ -195,7 +195,7 @@ static inline const char *pci_power_name(pci_power_t state)
  */
 typedef unsigned int __bitwise pci_channel_state_t;
 
-enum {
+enum pci_channel_state {
 	/* I/O channel is in normal state */
 	pci_channel_io_normal = (__force pci_channel_state_t) 1,
 
diff --git a/include/linux/syscalls.h b/include/linux/syscalls.h
index bbbd6fac3aff..9ee89dec0864 100644
--- a/include/linux/syscalls.h
+++ b/include/linux/syscalls.h
@@ -124,8 +124,14 @@ struct cachestat;
 #define __TYPE_IS_UL(t)	(__TYPE_AS(t, 0UL))
 #define __TYPE_IS_LL(t) (__TYPE_AS(t, 0LL) || __TYPE_AS(t, 0ULL))
 #define __SC_LONG(t, a) __typeof(__builtin_choose_expr(__TYPE_IS_LL(t), 0LL, 0L)) a
+#define __SC_TYPE(t, a) __typeof__(                               \
+       __builtin_choose_expr(                                  \
+               sizeof(t) > sizeof(int),                        \
+               (t) 0,                                          \
+               __builtin_choose_expr(__type_is_unsigned(t), 0UL, 0L)   \
+       ))
+#define __SC_WRAP(t, a)        (__SC_TYPE(t, a)) a
 #define __SC_CAST(t, a)	(__force t) a
-#define __SC_TYPE(t, a)	t
 #define __SC_ARGS(t, a)	a
 #define __SC_TEST(t, a) (void)BUILD_BUG_ON_ZERO(!__TYPE_IS_LL(t) && sizeof(t) > sizeof(long))
 
@@ -242,18 +248,19 @@ static inline int is_syscall_trace_event(struct trace_event_call *tp_event)
 	__diag_push();							\
 	__diag_ignore(GCC, 8, "-Wattribute-alias",			\
 		      "Type aliasing is used to sanitize syscall arguments");\
-	asmlinkage long sys##name(__MAP(x,__SC_DECL,__VA_ARGS__))	\
-		__attribute__((alias(__stringify(__se_sys##name))));	\
 	ALLOW_ERROR_INJECTION(sys##name, ERRNO);			\
 	static inline long __do_sys##name(__MAP(x,__SC_DECL,__VA_ARGS__));\
-	asmlinkage long __se_sys##name(__MAP(x,__SC_LONG,__VA_ARGS__));	\
-	asmlinkage long __se_sys##name(__MAP(x,__SC_LONG,__VA_ARGS__))	\
+	static inline asmlinkage long __se_sys##name(__MAP(x,__SC_LONG,__VA_ARGS__))    \
 	{								\
 		long ret = __do_sys##name(__MAP(x,__SC_CAST,__VA_ARGS__));\
 		__MAP(x,__SC_TEST,__VA_ARGS__);				\
 		__PROTECT(x, ret,__MAP(x,__SC_ARGS,__VA_ARGS__));	\
 		return ret;						\
 	}								\
+	asmlinkage long sys##name(__MAP(x,__SC_DECL,__VA_ARGS__))       \
+	{                                                               \
+		return __se_sys##name(__MAP(x,__SC_WRAP,__VA_ARGS__));  \
+	}                                                               \
 	__diag_pop();							\
 	static inline long __do_sys##name(__MAP(x,__SC_DECL,__VA_ARGS__))
 #endif /* __SYSCALL_DEFINEx */
diff --git a/kernel/bpf/core.c b/kernel/bpf/core.c
index 1333273a71de..54ae1a1d4183 100644
--- a/kernel/bpf/core.c
+++ b/kernel/bpf/core.c
@@ -1075,6 +1075,10 @@ void bpf_jit_binary_free(struct bpf_binary_header *hdr)
 	bpf_jit_uncharge_modmem(size);
 }
 
+#ifdef CONFIG_PAX_RAP
+extern long __rap_hash___bpf_prog_run;
+#endif
+
 /* Allocate jit binary from bpf_prog_pack allocator.
  * Since the allocated memory is RO+X, the JIT engine cannot write directly
  * to the memory. To solve this problem, a RW buffer is also allocated at
@@ -1092,6 +1096,10 @@ bpf_jit_binary_pack_alloc(unsigned int proglen, u8 **image_ptr,
 {
 	struct bpf_binary_header *ro_header;
 	u32 size, hole, start;
+	u32 padding_bytes = 0;
+#ifdef CONFIG_CALL_PADDING
+	padding_bytes += CONFIG_FUNCTION_PADDING_BYTES;
+#endif
 
 	WARN_ON_ONCE(!is_power_of_2(alignment) ||
 		     alignment > BPF_IMAGE_ALIGNMENT);
@@ -1121,10 +1129,23 @@ bpf_jit_binary_pack_alloc(unsigned int proglen, u8 **image_ptr,
 
 	hole = min_t(unsigned int, size - (proglen + sizeof(*ro_header)),
 		     BPF_PROG_CHUNK_SIZE - sizeof(*ro_header));
+#ifdef CONFIG_PAX_RAP
+	hole -= (4 + padding_bytes);
+#endif
 	start = get_random_u32_below(hole) & ~(alignment - 1);
 
+#ifdef CONFIG_PAX_RAP
+	start += (4 + padding_bytes);
+#endif
 	*image_ptr = &ro_header->image[start];
 	*rw_image = &(*rw_header)->image[start];
+#ifdef CONFIG_PAX_RAP
+#ifdef CONFIG_RELOCATABLE
+	*(int *)(*rw_image - (4 + padding_bytes)) = 0x456bce13;
+#else
+	*(int *)(*rw_image - (4 + padding_bytes)) = (int)&__rap_hash___bpf_prog_run;
+#endif
+#endif
 
 	return ro_header;
 }
diff --git a/kernel/events/core.c b/kernel/events/core.c
index fe543e7898f5..6ba94752f1c1 100644
--- a/kernel/events/core.c
+++ b/kernel/events/core.c
@@ -1119,8 +1119,9 @@ static void __perf_mux_hrtimer_init(struct perf_cpu_pmu_context *cpc, int cpu)
 	timer->function = perf_mux_hrtimer_handler;
 }
 
-static int perf_mux_hrtimer_restart(struct perf_cpu_pmu_context *cpc)
+static int perf_mux_hrtimer_restart(void *_cpc)
 {
+	struct perf_cpu_pmu_context *cpc = _cpc;
 	struct hrtimer *timer = &cpc->hrtimer;
 	unsigned long flags;
 
diff --git a/kernel/module/main.c b/kernel/module/main.c
index 34d9e718c2c7..c28f9b9481f3 100644
--- a/kernel/module/main.c
+++ b/kernel/module/main.c
@@ -2076,8 +2076,17 @@ static void module_augment_kernel_taints(struct module *mod, struct load_info *i
 static int check_modinfo(struct module *mod, struct load_info *info, int flags)
 {
 	const char *modmagic = get_modinfo(info, "vermagic");
+#ifdef CONFIG_PAX_RAP
+	const char *license = get_modinfo(info, "license");
+#endif
 	int err;
 
+#if defined(CONFIG_PAX_KERNEXEC_PLUGIN_METHOD_OR) || defined(CONFIG_PAX_RAP)
+	if (!license || !license_is_gpl_compatible(license)) {
+		pr_err("%s: module is not compatible with the KERNEXEC 'or' method and RAP\n", mod->name);
+		return -ENOEXEC;
+	}
+#endif
 	if (flags & MODULE_INIT_IGNORE_VERMAGIC)
 		modmagic = NULL;
 
diff --git a/kernel/sched/core.c b/kernel/sched/core.c
index 1f91e2c12731..60a530d51d6e 100644
--- a/kernel/sched/core.c
+++ b/kernel/sched/core.c
@@ -5019,7 +5019,7 @@ static void do_balance_callbacks(struct rq *rq, struct balance_callback *head)
 	lockdep_assert_rq_held(rq);
 
 	while (head) {
-		func = (void (*)(struct rq *))head->func;
+		func = head->func;
 		next = head->next;
 		head->next = NULL;
 		head = next;
diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 82e63908dce8..83f37c4d2477 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -921,7 +921,8 @@ void br_del_frame(struct net_bridge *br, struct br_frame_type *ft);
 
 static inline bool br_rx_handler_check_rcu(const struct net_device *dev)
 {
-	return rcu_dereference(dev->rx_handler) == br_get_rx_handler(dev);
+	//return rcu_dereference(dev->rx_handler) == br_get_rx_handler(dev);
+	return br_get_rx_handler(dev) == rcu_dereference(dev->rx_handler);
 }
 
 static inline bool br_rx_handler_check_rtnl(const struct net_device *dev)
diff --git a/net/netfilter/ipset/ip_set_core.c b/net/netfilter/ipset/ip_set_core.c
index 3184cc6be4c9..c0c14fceed21 100644
--- a/net/netfilter/ipset/ip_set_core.c
+++ b/net/netfilter/ipset/ip_set_core.c
@@ -391,7 +391,6 @@ ip_set_comment_free(struct ip_set *set, void *ptr)
 	rcu_assign_pointer(comment->c, NULL);
 }
 
-typedef void (*destroyer)(struct ip_set *, void *);
 /* ipset data extension types, in size order */
 
 const struct ip_set_ext_type ip_set_extensions[] = {
diff --git a/scripts/Makefile.gcc-plugins b/scripts/Makefile.gcc-plugins
index e4deaf5fa571..7acd78f9d9c4 100644
--- a/scripts/Makefile.gcc-plugins
+++ b/scripts/Makefile.gcc-plugins
@@ -22,6 +22,14 @@ export DISABLE_STRUCTLEAK_PLUGIN
 gcc-plugin-cflags-$(CONFIG_GCC_PLUGIN_STRUCTLEAK)		\
 		+= -DSTRUCTLEAK_PLUGIN
 
+gcc-plugin-$(CONFIG_PAX_RAP)                           += rap_plugin.so
+gcc-plugin-cflags-$(CONFIG_PAX_RAP)                    += -DRAP_PLUGIN -fplugin-arg-rap_plugin-check=call -fplugin-arg-rap_plugin-hash=abs-finish
+# gcc-plugin-cflags-$(CONFIG_PAX_RAP)                  += -fplugin-arg-rap_plugin-report=func,fptr,abs
+ifdef CONFIG_PAX_RAP
+  RAP_PLUGIN_ABS_CFLAGS                                := -fplugin-arg-rap_plugin-hash=abs-finish
+endif
+gcc-plugin-aflags-$(CONFIG_PAX_RAP)                    += -DRAP_PLUGIN
+
 gcc-plugin-$(CONFIG_GCC_PLUGIN_STACKLEAK)	+= stackleak_plugin.so
 gcc-plugin-cflags-$(CONFIG_GCC_PLUGIN_STACKLEAK)		\
 		+= -DSTACKLEAK_PLUGIN
@@ -47,8 +55,12 @@ export DISABLE_ARM_SSP_PER_TASK_PLUGIN
 GCC_PLUGINS_CFLAGS := $(strip $(addprefix -fplugin=$(objtree)/scripts/gcc-plugins/, $(gcc-plugin-y)) $(gcc-plugin-cflags-y))
 export GCC_PLUGINS_CFLAGS
 
+GCC_PLUGINS_AFLAGS := $(gcc-plugin-aflags-y)
+export RAP_PLUGIN_ABS_CFLAGS GCC_PLUGINS_AFLAGS
+
 # Add the flags to the build!
 KBUILD_CFLAGS += $(GCC_PLUGINS_CFLAGS)
+KBUILD_AFLAGS += $(GCC_PLUGINS_AFLAGS)
 
 # Some plugins are enabled outside of this Makefile, but they still need to
 # be included in GCC_PLUGIN so they can get built.
diff --git a/scripts/gcc-plugins/Makefile b/scripts/gcc-plugins/Makefile
index 320afd3cf8e8..0d3c8bdeca84 100644
--- a/scripts/gcc-plugins/Makefile
+++ b/scripts/gcc-plugins/Makefile
@@ -33,14 +33,20 @@ plugin_cxxflags	= -Wp,-MMD,$(depfile) $(KBUILD_HOSTCXXFLAGS) -fPIC \
 		  -fno-rtti -fno-exceptions -fasynchronous-unwind-tables \
 		  -ggdb -Wno-narrowing -Wno-unused-variable \
 		  -Wno-format-diag
+ifdef CONFIG_CALL_PADDING
+plugin_cxxflags += -DCONFIG_FUNCTION_PADDING_BYTES='$(CONFIG_FUNCTION_PADDING_BYTES)'
+endif
+
 
 plugin_ldflags	= -shared
 
+rap_plugin-objs := $(patsubst $(srctree)/$(src)/rap_plugin/%.c,rap_plugin/%.o,$(wildcard $(srctree)/$(src)/rap_plugin/*.c))
+
 plugin-single	:= $(foreach m, $(GCC_PLUGIN), $(if $($(m:%.so=%-objs)),,$(m)))
 plugin-multi	:= $(filter-out $(plugin-single), $(GCC_PLUGIN))
 plugin-objs	:= $(sort $(foreach m, $(plugin-multi), $($(m:%.so=%-objs))))
-
 targets += $(plugin-single) $(plugin-multi) $(plugin-objs)
+
 clean-files += *.so
 
 plugin-single	:= $(addprefix $(obj)/, $(plugin-single))
diff --git a/scripts/gcc-plugins/rap_plugin/rap.h b/scripts/gcc-plugins/rap_plugin/rap.h
new file mode 100644
index 000000000000..0e2c26301e33
--- /dev/null
+++ b/scripts/gcc-plugins/rap_plugin/rap.h
@@ -0,0 +1,38 @@
+#ifndef RAP_H_INCLUDED
+#define RAP_H_INCLUDED
+
+#include "gcc-common.h"
+
+#define RAP_HASH_START_PADDING_SIZE  1
+#define RAP_HASH_END_PADDING_SIZE  2
+typedef struct {
+	int hash; // will be sign extended to long in reality
+} rap_hash_t;
+
+typedef struct {
+	unsigned int qual_const:1;
+	unsigned int qual_volatile:1;
+} rap_hash_flags_t;
+extern rap_hash_flags_t imprecise_rap_hash_flags;
+
+extern bool report_fptr_hash;
+
+extern GTY(()) tree rap_hash_type_node;
+
+void siphash24fold(unsigned char *out, const unsigned char *in, unsigned long long inlen, const unsigned char *k);
+void rap_calculate_func_hashes(void *event_data, void *data);
+rap_hash_t rap_hash_function_type(const_tree fntype, rap_hash_flags_t flags);
+rap_hash_t rap_hash_function_decl(const_tree fndecl, rap_hash_flags_t flags);
+rap_hash_t rap_hash_function_node_imprecise(cgraph_node_ptr node);
+const_tree type_name(const_tree type);
+tree create_new_var(tree type, const char *name);
+
+gimple barrier(tree var, bool full);
+
+#if BUILDING_GCC_VERSION >= 4009
+opt_pass *make_rap_fptr_pass(void);
+#else
+struct opt_pass *make_rap_fptr_pass(void);
+#endif
+
+#endif
diff --git a/scripts/gcc-plugins/rap_plugin/rap_fptr_pass.c b/scripts/gcc-plugins/rap_plugin/rap_fptr_pass.c
new file mode 100644
index 000000000000..f8124b597b2d
--- /dev/null
+++ b/scripts/gcc-plugins/rap_plugin/rap_fptr_pass.c
@@ -0,0 +1,224 @@
+/*
+ * Copyright 2012-2016 by PaX Team <pageexec@freemail.hu>
+ * Licensed under the GPL v2
+ *
+ * Homepage: http://pax.grsecurity.net/
+ */
+
+#include "rap.h"
+
+bool report_fptr_hash;
+
+static bool rap_fptr_gate(void)
+{
+#ifdef TARGET_64BIT
+	tree section;
+
+	if (!TARGET_64BIT || ix86_cmodel != CM_KERNEL)
+		return true;
+
+	section = lookup_attribute("section", DECL_ATTRIBUTES(current_function_decl));
+	if (!section || !TREE_VALUE(section))
+		return true;
+
+	section = TREE_VALUE(TREE_VALUE(section));
+	return strncmp(TREE_STRING_POINTER(section), ".vsyscall_", 10);
+#else
+#error unsupported target
+#endif
+}
+
+static tree build_rap_hash(gimple call_stmt, tree fntype)
+{
+	rap_hash_t hash;
+
+	hash = rap_hash_function_type(fntype, imprecise_rap_hash_flags);
+	if (report_fptr_hash)
+		inform(gimple_location(call_stmt), "fptr rap_hash: %x", hash.hash);
+	return build_int_cst_type(rap_hash_type_node, hash.hash);
+}
+
+// check the function hash of the target of the fptr
+static basic_block rap_instrument_fptr(gimple_stmt_iterator *gsi)
+{
+	gimple assign_hash, check_hash, call_stmt, stmt;
+	location_t loc;
+	tree computed_hash, target_hash, fptr, fntype;
+#if BUILDING_GCC_VERSION == 4005
+	tree fptr2;
+#endif
+	basic_block cond_bb, join_bb, true_bb;
+	edge e;
+	const HOST_WIDE_INT rap_hash_offset = sizeof(rap_hash_t) + CONFIG_FUNCTION_PADDING_BYTES;
+
+	call_stmt = gsi_stmt(*gsi);
+	loc = gimple_location(call_stmt);
+	fptr = gimple_call_fn(call_stmt);
+	fntype = TREE_TYPE(TREE_TYPE(fptr));
+
+	if (TREE_CODE(fntype) == FUNCTION_TYPE) {
+		computed_hash = build_rap_hash(call_stmt, fntype);
+	} else {
+		debug_tree(fntype);
+		gcc_unreachable();
+	}
+
+	// target_hash = ((s64*)fptr)[-rap_hash_offset]
+	target_hash = create_tmp_var(rap_hash_type_node, "rap_hash");
+	add_referenced_var(target_hash);
+	target_hash = make_ssa_name(target_hash, NULL);
+#if BUILDING_GCC_VERSION == 4005
+	fptr2 = create_tmp_var(ptr_type_node, "rap_fptr2");
+	fptr2 = make_ssa_name(fptr2, NULL);
+	assign_hash = gimple_build_assign(fptr2, build2(POINTER_PLUS_EXPR, ptr_type_node, fptr, build_int_cst_type(sizetype, -rap_hash_offset)));
+	gimple_set_location(assign_hash, loc);
+	SSA_NAME_DEF_STMT(fptr2) = assign_hash;
+	gsi_insert_before(gsi, assign_hash, GSI_SAME_STMT);
+	update_stmt(assign_hash);
+	fptr = gimple_get_lhs(assign_hash);
+
+	fptr2 = create_tmp_var(build_pointer_type(rap_hash_type_node), "rap_fptr2");
+	fptr2 = make_ssa_name(fptr2, NULL);
+	assign_hash = gimple_build_assign(fptr2, fold_convert(build_pointer_type(TREE_TYPE(target_hash)), fptr));
+	gimple_set_location(assign_hash, loc);
+	SSA_NAME_DEF_STMT(fptr2) = assign_hash;
+	gsi_insert_before(gsi, assign_hash, GSI_SAME_STMT);
+	update_stmt(assign_hash);
+	fptr = gimple_get_lhs(assign_hash);
+
+	assign_hash = gimple_build_assign(target_hash, build1(INDIRECT_REF, rap_hash_type_node, fptr));
+#else
+	assign_hash = gimple_build_assign(target_hash, build2(MEM_REF, integer_type_node, fptr, build_int_cst_type(build_pointer_type(rap_hash_type_node), -rap_hash_offset)));
+#endif
+	gimple_set_location(assign_hash, loc);
+	SSA_NAME_DEF_STMT(target_hash) = assign_hash;
+	gsi_insert_before(gsi, assign_hash, GSI_NEW_STMT);
+	update_stmt(assign_hash);
+
+	// compare target_hash against computed function hash
+	// bail out on mismatch
+	check_hash = gimple_build_cond(NE_EXPR, target_hash, computed_hash, NULL_TREE, NULL_TREE);
+	gimple_set_location(check_hash, loc);
+	gsi_insert_after(gsi, check_hash, GSI_NEW_STMT);
+
+	cond_bb = gimple_bb(gsi_stmt(*gsi));
+	gcc_assert(!gsi_end_p(*gsi));
+	gcc_assert(check_hash == gsi_stmt(*gsi));
+
+	e = split_block(cond_bb, gsi_stmt(*gsi));
+	cond_bb = e->src;
+	join_bb = e->dest;
+	e->flags = EDGE_FALSE_VALUE;
+#if BUILDING_GCC_VERSION < 8000
+	e->probability = REG_BR_PROB_BASE;
+#else
+	e->probability = profile_probability::always ();
+#endif
+
+	true_bb = create_empty_bb(EXIT_BLOCK_PTR_FOR_FN(cfun)->prev_bb);
+	make_edge(cond_bb, true_bb, EDGE_TRUE_VALUE | EDGE_PRESERVE);
+
+	gcc_assert(dom_info_available_p(CDI_DOMINATORS));
+	set_immediate_dominator(CDI_DOMINATORS, true_bb, cond_bb);
+	set_immediate_dominator(CDI_DOMINATORS, join_bb, cond_bb);
+
+	gcc_assert(cond_bb->loop_father == join_bb->loop_father);
+	add_bb_to_loop(true_bb, cond_bb->loop_father);
+
+	*gsi = gsi_start_bb(true_bb);
+
+	// this fake dependency is to prevent PRE from merging this BB with others of the same kind
+	stmt = barrier(fptr, false);
+	gimple_set_location(stmt, loc);
+	gsi_insert_after(gsi, stmt, GSI_CONTINUE_LINKING);
+
+	stmt = gimple_build_call(builtin_decl_implicit(BUILT_IN_TRAP), 0);
+	gimple_set_location(stmt, loc);
+	gsi_insert_after(gsi, stmt, GSI_CONTINUE_LINKING);
+
+	return join_bb;
+}
+
+// find all language level function pointer dereferences and verify the target function
+static unsigned int rap_fptr_execute(void)
+{
+	basic_block bb;
+
+	loop_optimizer_init(LOOPS_NORMAL | LOOPS_HAVE_RECORDED_EXITS);
+	gcc_assert(current_loops);
+
+	calculate_dominance_info(CDI_DOMINATORS);
+	calculate_dominance_info(CDI_POST_DOMINATORS);
+
+	// 1. loop through BBs and GIMPLE statements
+	FOR_EACH_BB_FN(bb, cfun) {
+		gimple_stmt_iterator gsi;
+
+		for (gsi = gsi_start_bb(bb); !gsi_end_p(gsi); gsi_next(&gsi)) {
+			// gimple match: h_1 = get_fptr (); D.2709_3 = h_1 (x_2(D));
+			tree fptr, fntype;
+			gimple call_stmt;
+
+			// is it a call ...
+			call_stmt = gsi_stmt(gsi);
+			if (!is_gimple_call(call_stmt))
+				continue;
+
+			fptr = gimple_call_fn(call_stmt);
+			if (!fptr)
+				continue;
+
+			switch (TREE_CODE(fptr)) {
+			default:
+				debug_gimple_stmt(call_stmt);
+				debug_tree(fptr);
+				debug_tree(TREE_TYPE(fptr));
+				gcc_unreachable();
+
+			case ADDR_EXPR:
+				continue;
+
+			case SSA_NAME:
+				if (SSA_NAME_VAR(fptr) == NULL_TREE)
+					break;
+
+				switch (TREE_CODE(SSA_NAME_VAR(fptr))) {
+				default:
+					debug_gimple_stmt(call_stmt);
+					debug_tree(fptr);
+					gcc_unreachable();
+
+				case VAR_DECL:
+				case PARM_DECL:
+					break;
+				}
+				break;
+
+			case INTEGER_CST:
+			case OBJ_TYPE_REF:
+				break;
+			}
+
+			// ... through a function pointer
+			fntype = TREE_TYPE(fptr);
+			if (TREE_CODE(fntype) != POINTER_TYPE)
+				continue;
+
+			fntype = TREE_TYPE(fntype);
+			gcc_assert(TREE_CODE(fntype) == FUNCTION_TYPE || TREE_CODE(fntype) == METHOD_TYPE);
+
+			bb = rap_instrument_fptr(&gsi);
+			gsi = gsi_start_bb(bb);
+		}
+	}
+
+	free_dominance_info(CDI_DOMINATORS);
+	free_dominance_info(CDI_POST_DOMINATORS);
+	loop_optimizer_finalize();
+
+	return 0;
+}
+
+#define PASS_NAME rap_fptr
+#define TODO_FLAGS_FINISH TODO_verify_ssa | TODO_verify_stmts | TODO_dump_func | TODO_remove_unused_locals | TODO_update_ssa | TODO_cleanup_cfg | TODO_rebuild_cgraph_edges | TODO_verify_flow
+#include "gcc-generate-gimple-pass.h"
diff --git a/scripts/gcc-plugins/rap_plugin/rap_hash.c b/scripts/gcc-plugins/rap_plugin/rap_hash.c
new file mode 100644
index 000000000000..420fcbdbfc05
--- /dev/null
+++ b/scripts/gcc-plugins/rap_plugin/rap_hash.c
@@ -0,0 +1,396 @@
+/*
+ * Copyright 2012-2016 by PaX Team <pageexec@freemail.hu>
+ * Licensed under the GPL v2
+ *
+ * Homepage: http://pax.grsecurity.net/
+ */
+
+#include "rap.h"
+
+static rap_hash_t *rap_imprecise_hashes;
+static int rap_cgraph_max_uid;
+
+static void rap_hash_function(const_tree fntype, rap_hash_flags_t flags, unsigned char sip_hash[8]);
+
+static const unsigned char rap_hash_tree_code[MAX_TREE_CODES] = {
+	[0] = 0,
+	[1] = 0,
+	[2] = 0,
+	[3] = 0,
+	[4] = 0,
+	[OFFSET_TYPE] = 10,
+	[ENUMERAL_TYPE] = 20,
+	[BOOLEAN_TYPE] = 30,
+	[INTEGER_TYPE] = 40,
+	[REAL_TYPE] = 50,
+	[POINTER_TYPE] = 60,
+	[REFERENCE_TYPE] = 70,
+#if BUILDING_GCC_VERSION >= 4006
+	[NULLPTR_TYPE] = 80,
+#endif
+	[FIXED_POINT_TYPE] = 0,
+	[COMPLEX_TYPE] = 100,
+	[VECTOR_TYPE] = 110,
+	[ARRAY_TYPE] = 120,
+	[RECORD_TYPE] = 130,
+	[UNION_TYPE] = 140,
+	[QUAL_UNION_TYPE] = 0,
+	[VOID_TYPE] = 160,
+#if BUILDING_GCC_VERSION >= 5000 && BUILDING_GCC_VERSION < 9000
+	[POINTER_BOUNDS_TYPE] = 170,
+#endif
+	[FUNCTION_TYPE] = 180,
+	[METHOD_TYPE] = 0,
+	[LANG_TYPE] = 0,
+};
+
+static void rap_fold_hash(unsigned char *out, const unsigned char *in, unsigned long long inlen)
+{
+	static const unsigned char rap_sip_key[16] = {
+		'P', 'a', 'X', ' ', 'T', 'e', 'a', 'm',
+		'R', 'A', 'P', ' ', 'H', 'A', 'S', 'H',
+	};
+
+	siphash24fold(out, in, inlen, rap_sip_key);
+}
+
+// compute the final hash value in the range [1,INT_MAX]
+// the % and +1 trick leaves the value 0 available for marking non-indirectly callable functions
+// and INT_MIN (0x80000000) for longjmp targets (sign extended)
+// return places will use the (sign extended) range [INT_MIN+1,-1] ([0x8000001,0xffffffff])
+static rap_hash_t rap_extract_hash(const unsigned char sip_hash[8])
+{
+	rap_hash_t hash;
+	unsigned long long dividend, divisor;
+
+	memcpy(&dividend, sip_hash, sizeof dividend);
+//	divisor = 1ULL << (sizeof hash * 8 - 1);
+//	divisor |= divisor - 1;
+	divisor = 0x7fffffffUL;
+	hash.hash = dividend % divisor + 1;
+	return hash;
+}
+
+static void rap_hash_type_name(const_tree type, unsigned char sip_hash[8])
+{
+	const_tree name = type_name(TYPE_MAIN_VARIANT(type));
+
+	// handle typedefs of anonymous structs/unions
+	if (name == NULL_TREE)
+		name = type_name(type);
+
+	if (name == NULL_TREE)
+		return;
+
+	gcc_assert(TREE_CODE(name) == IDENTIFIER_NODE);
+	rap_fold_hash(sip_hash, (const unsigned char *)IDENTIFIER_POINTER(name), IDENTIFIER_LENGTH(name));
+}
+
+static void rap_hash_type_precision(const_tree type, unsigned char sip_hash[8])
+{
+	unsigned HOST_WIDE_INT size;
+
+	gcc_assert(TYPE_PRECISION(type));
+
+	size = TYPE_PRECISION(type);
+	rap_fold_hash(sip_hash, (const unsigned char *)&size, sizeof size);
+}
+
+const_tree type_name(const_tree type)
+{
+	const_tree name;
+
+	name = TYPE_NAME(type);
+	if (!name)
+		return NULL_TREE;
+
+	switch (TREE_CODE(name)) {
+	case IDENTIFIER_NODE:
+		return name;
+
+	case TYPE_DECL:
+		gcc_assert(DECL_NAME(name));
+		return DECL_NAME(name);
+
+	default:
+		gcc_unreachable();
+	}
+}
+
+__attribute__((weak)) tree c_global_trees[CTI_MAX];
+
+// the core computation of the rap hash
+// the first piece is a (hopefully) compiler independent encondig of the type, derived from the gcc tree code
+// the second piece is type specific information, such as the size, qualifiers, (recursively) referenced types, etc
+static void rap_hash_tree(const_tree type, rap_hash_flags_t flags, unsigned char sip_hash[8])
+{
+	enum tree_code code;
+	unsigned int attrs;
+
+	code = TREE_CODE(type);
+	attrs = rap_hash_tree_code[code];
+	if (!attrs) {
+		fprintf(stderr, "unhandled tree_code %s %d\n", get_tree_code_name(code), code);
+		debug_tree(type);
+		gcc_unreachable();
+	}
+	rap_fold_hash(sip_hash, (const unsigned char *)&attrs, sizeof attrs);
+
+	enum {
+	// attrs layout for
+		// - all types:
+		RAP_HASH_VOLATILE		= 1U << 31,
+		RAP_HASH_NOT_VOLATILE		= 1U << 30,
+		RAP_HASH_CONST			= 1U << 29,
+		RAP_HASH_NOT_CONST		= 1U << 28,
+
+		// - pointer types:
+		RAP_HASH_RESTRICT		= 1U << 27,
+		RAP_HASH_NOT_RESTRICT		= 1U << 26,
+
+		// - C integer types:
+		RAP_HASH_UNSIGNED		= 1U << 25,
+		RAP_HASH_SIGNED			= 1U << 24,
+
+		RAP_HASH_UNQUALIFIED_CHAR	= 1U << 23,
+		RAP_HASH_CHAR			= 1U << 22,
+		RAP_HASH_SHORT			= 1U << 21,
+		RAP_HASH_INT			= 1U << 20,
+		RAP_HASH_LONG			= 1U << 19,
+		RAP_HASH_LONG_LONG		= 1U << 18,
+		RAP_HASH_WCHAR			= 1U << 17,
+		RAP_HASH_CHAR16			= 1U << 16,
+		RAP_HASH_CHAR32			= 1U << 15,
+
+		// - C float types
+		RAP_HASH_FLOAT			= 1U << 14,
+		RAP_HASH_DOUBLE			= 1U << 13,
+		RAP_HASH_LONG_DOUBLE		= 1U << 12,
+		RAP_HASH_DFLOAT32		= 1U << 11,
+		RAP_HASH_DFLOAT64		= 1U << 10,
+		RAP_HASH_DFLOAT128		= 1U << 9,
+	};
+
+	attrs = 0;
+	if (flags.qual_volatile)
+		attrs |= TYPE_VOLATILE(type) ? RAP_HASH_VOLATILE : RAP_HASH_NOT_VOLATILE;
+	if (flags.qual_const)
+		attrs |= TYPE_READONLY(type) ? RAP_HASH_CONST : RAP_HASH_NOT_CONST;
+
+	switch (code) {
+	default:
+		debug_tree(type);
+		gcc_unreachable();
+		break;
+
+	case VOID_TYPE:
+		break;
+
+	case OFFSET_TYPE:
+		rap_hash_tree(TREE_TYPE(type), flags, sip_hash);
+		rap_hash_tree(TYPE_OFFSET_BASETYPE(type), flags, sip_hash);
+		break;
+
+	case FUNCTION_TYPE:
+		rap_hash_function(type, flags, sip_hash);
+		break;
+
+	case RECORD_TYPE:
+		rap_hash_type_name(type, sip_hash);
+		break;
+
+	case UNION_TYPE:
+		rap_hash_type_name(type, sip_hash);
+		break;
+
+	case POINTER_TYPE:
+	case REFERENCE_TYPE:
+		rap_hash_tree(TREE_TYPE(type), flags, sip_hash);
+		break;
+
+	case VECTOR_TYPE:
+		rap_hash_tree(TREE_TYPE(type), flags, sip_hash);
+		rap_hash_type_precision(TREE_TYPE(type), sip_hash);
+		break;
+
+	case ARRAY_TYPE:
+		rap_hash_tree(TREE_TYPE(type), flags, sip_hash);
+		break;
+
+	case REAL_TYPE: {
+		const_tree main_variant = TYPE_MAIN_VARIANT(type);
+
+		switch (TYPE_PRECISION(main_variant)) {
+		default:
+			debug_tree(type);
+			debug_tree(TYPE_MAIN_VARIANT(type));
+			gcc_unreachable();
+
+		case 32:
+//			attrs |= RAP_HASH_FLOAT;
+			break;
+
+		case 64:
+//			attrs |= RAP_HASH_DOUBLE;
+			break;
+
+		case 80:
+		case 128:
+			attrs |= RAP_HASH_LONG_DOUBLE;
+			break;
+		}
+		rap_hash_type_precision(main_variant, sip_hash);
+		break;
+	}
+
+	case ENUMERAL_TYPE:
+		rap_hash_type_name(type, sip_hash);
+	case BOOLEAN_TYPE:
+		rap_hash_type_precision(type, sip_hash);
+		break;
+
+	case INTEGER_TYPE: {
+		attrs |= TYPE_UNSIGNED(type) ? RAP_HASH_UNSIGNED : RAP_HASH_SIGNED;
+		rap_hash_type_precision(type, sip_hash);
+		break;
+	}
+	}
+
+	rap_fold_hash(sip_hash, (const unsigned char *)&attrs, sizeof attrs);
+}
+
+static const_tree rap_dequal_argtype(const_tree argtype)
+{
+	// since gcc/tree.c:free_lang_data_in_type removes const/volatile from the top level param decl
+	// we have to simulate it here as this can be called earlier from the frontend as well
+	if (TYPE_READONLY(argtype) || TYPE_VOLATILE(argtype)) {
+		int quals;
+
+		quals = TYPE_QUALS(argtype) & ~TYPE_QUAL_CONST & ~TYPE_QUAL_VOLATILE;
+		argtype = build_qualified_type(CONST_CAST_TREE(argtype), quals);
+	}
+
+	return argtype;
+}
+
+// main function to compute the rap hash for function types
+// while virtual class methods are always replaced with their ancestor,
+// callers can decide whether to fully utilize that information via flags.method_ancestor
+static void rap_hash_function(const_tree fntype, rap_hash_flags_t flags, unsigned char sip_hash[8])
+{
+	function_args_iterator args_iter;
+	const_tree arg;
+
+	switch (TREE_CODE(fntype)) {
+	default:
+		debug_tree(fntype);
+		gcc_unreachable();
+
+	case FUNCTION_TYPE:
+		// 1. hash the result
+		rap_hash_tree(TREE_TYPE(fntype), flags, sip_hash);
+
+		// 2. hash the function parameters
+		FOREACH_FUNCTION_ARGS(fntype, arg, args_iter) {
+			const_tree argtype = arg;
+
+			argtype = rap_dequal_argtype(argtype);
+			rap_hash_tree(argtype, flags, sip_hash);
+		}
+		break;
+	}
+}
+
+rap_hash_t rap_hash_function_type(const_tree fntype, rap_hash_flags_t flags)
+{
+	unsigned char sip_hash[8] = { };
+	rap_hash_t hash;
+
+	rap_hash_function(fntype, flags, sip_hash);
+	hash = rap_extract_hash(sip_hash);
+
+	gcc_assert(hash.hash);
+	return hash;
+}
+
+rap_hash_t rap_hash_function_decl(const_tree fndecl, rap_hash_flags_t flags)
+{
+	tree fntype;
+
+	gcc_assert(TREE_CODE(fndecl) == FUNCTION_DECL);
+	fntype = TREE_TYPE(fndecl);
+
+	switch (TREE_CODE(fntype)) {
+	default:
+		debug_tree(fndecl);
+		gcc_unreachable();
+
+	case FUNCTION_TYPE:
+		return rap_hash_function_type(fntype, flags);
+	}
+}
+
+rap_hash_t rap_hash_function_node_imprecise(cgraph_node_ptr node)
+{
+	rap_hash_t hash;
+	tree fndecl;
+	int uid;
+
+	gcc_assert(rap_imprecise_hashes);
+
+	hash.hash = 0;
+#if BUILDING_GCC_VERSION < 9003
+	uid = node->uid;
+#else
+	uid = node->get_uid();
+#endif
+	if (uid < rap_cgraph_max_uid)
+		hash = rap_imprecise_hashes[uid];
+
+	if (hash.hash)
+		return hash;
+
+	fndecl = NODE_DECL(node);
+	if (TREE_CODE(TREE_TYPE(fndecl)) == FUNCTION_TYPE)
+		return rap_hash_function_decl(fndecl, imprecise_rap_hash_flags);
+
+	debug_cgraph_node(node);
+	debug_tree(fndecl);
+	error("indirect call to function %qD with a reserved hash value", fndecl);
+	return hash;
+}
+
+void rap_calculate_func_hashes(void *event_data __unused, void *data __unused)
+{
+	cgraph_node_ptr node;
+	int uid;
+
+	gcc_assert(!rap_imprecise_hashes);
+
+	rap_imprecise_hashes = (rap_hash_t *)xcalloc(cgraph_max_uid, sizeof(*rap_imprecise_hashes));
+	rap_cgraph_max_uid = cgraph_max_uid;
+
+	FOR_EACH_FUNCTION(node) {
+		const_tree fndecl;
+
+#if BUILDING_GCC_VERSION < 9003
+		uid = node->uid;
+#else
+		uid = node->get_uid();
+#endif
+		gcc_assert(uid < rap_cgraph_max_uid);
+
+#if BUILDING_GCC_VERSION < 10000
+		if (node->global.inlined_to)
+#else
+		if (node->inlined_to)
+#endif
+			continue;
+
+		fndecl = NODE_DECL(node);
+		gcc_assert(fndecl);
+
+		rap_imprecise_hashes[uid] = rap_hash_function_decl(fndecl, imprecise_rap_hash_flags);
+		gcc_assert(rap_imprecise_hashes[uid].hash);
+	}
+}
diff --git a/scripts/gcc-plugins/rap_plugin/rap_plugin.c b/scripts/gcc-plugins/rap_plugin/rap_plugin.c
new file mode 100644
index 000000000000..b05e0bf95753
--- /dev/null
+++ b/scripts/gcc-plugins/rap_plugin/rap_plugin.c
@@ -0,0 +1,557 @@
+/*
+ * Copyright 2012-2016 by PaX Team <pageexec@freemail.hu>
+ * Licensed under the GPL v2
+ *
+ * Homepage: http://pax.grsecurity.net/
+ *
+ * Usage:
+ * $ # for 4.5/4.6/C based 4.7
+ * $ gcc -I`gcc -print-file-name=plugin`/include -I`gcc -print-file-name=plugin`/include/c-family -fPIC -shared -O2 -o rap_plugin.so rap_plugin.c
+ * $ # for C++ based 4.7/4.8+
+ * $ g++ -I`g++ -print-file-name=plugin`/include -I`g++ -print-file-name=plugin`/include/c-family -fPIC -shared -O2 -o rap_plugin.so rap_plugin.c
+ * $ gcc -fplugin=./rap_plugin.so -fplugin-arg-rap_plugin-check=call test.c -O2
+ */
+
+#include "rap.h"
+
+__visible int plugin_is_GPL_compatible;
+
+static struct plugin_info rap_plugin_info = {
+	.version	= "201604272100",
+	.help		= "check=call\tenable the corresponding features\n"
+			  "hash=abs,abs-finish,const,volatile\n"
+			  "report=func,fptr,abs\n"
+};
+
+rap_hash_flags_t imprecise_rap_hash_flags = {
+	.qual_const	= 1,
+	.qual_volatile	= 1,
+};
+
+tree rap_hash_type_node;
+
+static bool report_func_hash, report_abs_hash;
+
+// create the equivalent of
+// asm volatile("" : : : "memory");
+// or
+// asm("" : "+rm"(var));
+// or
+// asm("" : : "rm"(var));
+gimple barrier(tree var, bool full)
+{
+	gimple stmt;
+	gasm *asm_stmt;
+#if BUILDING_GCC_VERSION <= 4007
+	VEC(tree, gc) *inputs = NULL;
+	VEC(tree, gc) *outputs = NULL;
+	VEC(tree, gc) *clobbers = NULL;
+#else
+	vec<tree, va_gc> *inputs = NULL;
+	vec<tree, va_gc> *outputs = NULL;
+	vec<tree, va_gc> *clobbers = NULL;
+#endif
+
+	if (!var && full) {
+		tree clobber;
+
+		clobber = build_tree_list(NULL_TREE, build_string(7, "memory"));
+#if BUILDING_GCC_VERSION <= 4007
+		VEC_safe_push(tree, gc, clobbers, clobber);
+#else
+		vec_safe_push(clobbers, clobber);
+#endif
+	} else if (full) {
+		tree input, output;
+
+		input = build_tree_list(NULL_TREE, build_string(2, "0"));
+		input = chainon(NULL_TREE, build_tree_list(input, var));
+#if BUILDING_GCC_VERSION <= 4007
+		VEC_safe_push(tree, gc, inputs, input);
+#else
+		vec_safe_push(inputs, input);
+#endif
+
+		output = build_tree_list(NULL_TREE, build_string(4, "=rm"));
+		gcc_assert(SSA_NAME_VAR(var));
+		var = make_ssa_name(SSA_NAME_VAR(var), NULL);
+		output = chainon(NULL_TREE, build_tree_list(output, var));
+#if BUILDING_GCC_VERSION <= 4007
+		VEC_safe_push(tree, gc, outputs, output);
+#else
+		vec_safe_push(outputs, output);
+#endif
+	} else {
+		tree input;
+
+		input = build_tree_list(NULL_TREE, build_string(3, "rm"));
+		input = chainon(NULL_TREE, build_tree_list(input, var));
+#if BUILDING_GCC_VERSION <= 4007
+		VEC_safe_push(tree, gc, inputs, input);
+#else
+		vec_safe_push(inputs, input);
+#endif
+	}
+
+	stmt = gimple_build_asm_vec("", inputs, outputs, clobbers, NULL);
+	asm_stmt = as_a_gasm(stmt);
+	if (!var && full)
+		gimple_asm_set_volatile(asm_stmt, true);
+	else if (full)
+		SSA_NAME_DEF_STMT(var) = stmt;
+	return stmt;
+}
+
+static const struct gcc_debug_hooks *old_debug_hooks;
+static struct gcc_debug_hooks rap_debug_hooks;
+
+static bool __rap_cgraph_indirectly_callable(cgraph_node_ptr node, void *data)
+{
+#if BUILDING_GCC_VERSION >= 4008
+	if (NODE_SYMBOL(node)->externally_visible)
+#else
+	if (node->local.externally_visible)
+#endif
+		return true;
+
+	if (NODE_SYMBOL(node)->address_taken)
+		return true;
+
+	return false;
+}
+
+static bool rap_cgraph_indirectly_callable(cgraph_node_ptr node)
+{
+	return cgraph_for_node_and_aliases(node, __rap_cgraph_indirectly_callable, NULL, true);
+}
+
+static void rap_hash_align(tree decl)
+{
+	const unsigned HOST_WIDE_INT rap_hash_offset = TARGET_64BIT ? 2 * sizeof(rap_hash_t) : sizeof(rap_hash_t);
+	unsigned HOST_WIDE_INT skip;
+
+#if BUILDING_GCC_VERSION < 9003
+	skip = 1ULL << align_functions_log;
+#else
+	skip = 1ULL <<  align_functions.levels[0].log;
+#endif
+	if (DECL_USER_ALIGN(decl))
+		return;
+
+	if (!optimize_function_for_speed_p(cfun)) {
+		ASM_OUTPUT_ASCII(asm_out_file, "\xb8", 1);
+		return;
+	}
+
+	if (skip <= rap_hash_offset)
+		return;
+
+#ifdef TARGET_64BIT
+	{
+		char padding[RAP_HASH_START_PADDING_SIZE];
+
+		// this byte sequence helps disassemblers not trip up on the following rap hash
+		//memset(padding, 0xcc, sizeof padding - 1);
+		padding[sizeof padding - 1] = 0xb8;
+		ASM_OUTPUT_ASCII(asm_out_file, padding, sizeof padding);
+	}
+#else
+	ASM_OUTPUT_SKIP(asm_out_file, skip - rap_hash_offset);
+#endif
+}
+
+static void rap_begin_function(tree decl)
+{
+	cgraph_node_ptr node;
+	rap_hash_t imprecise_rap_hash;
+	char *name = NULL;
+#if 0
+	char end_padding[RAP_HASH_END_PADDING_SIZE];
+
+	memset(end_padding, 0xcc, sizeof end_padding);
+#endif
+	gcc_assert(debug_hooks == &rap_debug_hooks);
+
+	// chain to previous callback
+	if (old_debug_hooks && old_debug_hooks->begin_function)
+		old_debug_hooks->begin_function(decl);
+
+	// don't compute hash for functions called only directly
+	node = cgraph_get_node(decl);
+	gcc_assert(node);
+	if (!rap_cgraph_indirectly_callable(node)) {
+		imprecise_rap_hash.hash = 0;
+		return;
+	} else {
+		imprecise_rap_hash = rap_hash_function_node_imprecise(node);
+	}
+
+	gcc_assert(asprintf(&name, "__cfi_%s", IDENTIFIER_POINTER(DECL_ASSEMBLER_NAME(decl))) != -1);
+	if (TREE_PUBLIC(decl)) {
+		if (lookup_attribute("weak", DECL_ATTRIBUTES(decl)))
+			fprintf(asm_out_file, "\t.weak\t%s\n", name);
+		else
+			fprintf(asm_out_file, GLOBAL_ASM_OP " %s\n", name);
+	}
+
+	ASM_OUTPUT_TYPE_DIRECTIVE(asm_out_file, name, "function");
+	ASM_OUTPUT_LABEL(asm_out_file, name);
+
+	// align the rap hash if necessary
+	rap_hash_align(decl);
+
+	if (report_func_hash)
+		inform(DECL_SOURCE_LOCATION(decl), "func rap_hash: %x %s", imprecise_rap_hash.hash, IDENTIFIER_POINTER(DECL_ASSEMBLER_NAME(decl)));
+
+	fprintf(asm_out_file, "\t.long %#x\t%s __kcfi_typeid_%s\n", imprecise_rap_hash.hash, ASM_COMMENT_START, IDENTIFIER_POINTER(DECL_ASSEMBLER_NAME(decl)));
+
+#if 0
+	ASM_OUTPUT_ASCII(asm_out_file, end_padding, sizeof end_padding);
+#endif
+	fprintf(asm_out_file, "\t.size\t%s, .-%s\n", name, name);
+}
+
+static void rap_start_unit_common(void *gcc_data __unused, void *user_data __unused)
+{
+	rap_hash_type_node = long_integer_type_node;
+
+	if (debug_hooks)
+		rap_debug_hooks = *debug_hooks;
+	rap_debug_hooks.begin_function = rap_begin_function;
+	old_debug_hooks = debug_hooks;
+	debug_hooks = &rap_debug_hooks;
+}
+
+/*
+   emit an absolute symbol for each function that may be referenced through the plt
+     - all externs
+     - non-static functions
+       - use visibility instead?
+
+   .globl __rap_hash_func
+   .offset 0xhash_for_func
+   .type __rap_hash_func, @object
+   __rap_hash_func:
+   .previous
+*/
+static void rap_finish_unit(void *gcc_data __unused, void *user_data __unused)
+{
+	cgraph_node_ptr node;
+	rap_hash_t hash;
+
+	gcc_assert(debug_hooks == &rap_debug_hooks);
+
+	hash.hash = 0;
+	FOR_EACH_FUNCTION(node) {
+		tree fndecl;
+		const char *asmname;
+		char *name = NULL;
+
+		if (cgraph_function_body_availability(node) >= AVAIL_INTERPOSABLE) {
+			if (node->thunk || node->alias)
+				continue;
+			if (!rap_cgraph_indirectly_callable(node))
+				continue;
+		}
+
+#if BUILDING_GCC_VERSION >= 4007
+		gcc_assert(cgraph_function_or_thunk_node(node, NULL) == node);
+#endif
+
+		fndecl = NODE_DECL(node);
+		gcc_assert(fndecl);
+		if (DECL_IS_UNDECLARED_BUILTIN(fndecl) && DECL_BUILT_IN_CLASS(fndecl) == BUILT_IN_NORMAL)
+			continue;
+
+		if (!TREE_PUBLIC(fndecl))
+			continue;
+
+		if (DECL_ARTIFICIAL(fndecl))
+			continue;
+
+		if (DECL_ABSTRACT_ORIGIN(fndecl) && DECL_ABSTRACT_ORIGIN(fndecl) != fndecl)
+			continue;
+
+		gcc_assert(DECL_ASSEMBLER_NAME(fndecl));
+		asmname = IDENTIFIER_POINTER(DECL_ASSEMBLER_NAME(fndecl));
+		if (strchr(asmname, '.'))
+			continue;
+
+		if (asmname[0] == '*')
+			asmname++;
+
+		gcc_assert(asmname[0]);
+		gcc_assert(asprintf(&name, "__kcfi_typeid_%s", asmname) != -1);
+
+		hash = rap_hash_function_node_imprecise(node);
+		if (report_abs_hash)
+			inform(DECL_SOURCE_LOCATION(fndecl), "abs rap_hash: %x %s", hash.hash, IDENTIFIER_POINTER(DECL_ASSEMBLER_NAME(fndecl)));
+
+		fprintf(asm_out_file, GLOBAL_ASM_OP " %s\n", name);
+		fprintf(asm_out_file, "\t.offset %#x\n", hash.hash);
+		ASM_OUTPUT_TYPE_DIRECTIVE(asm_out_file, name, "object");
+		ASM_OUTPUT_LABEL(asm_out_file, name);
+		free(name);
+	}
+
+	if (hash.hash)
+		fprintf(asm_out_file, "\t.previous\n");
+}
+
+#if BUILDING_GCC_VERSION >= 4007
+// emit the rap hash as an absolute symbol for all functions seen in the frontend
+// this is necessary as later unreferenced nodes will be removed yet we'd like to emit as many hashes as possible
+static void rap_finish_decl(void *event_data, void *data __unused)
+{
+	tree fndecl = (tree)event_data;
+	rap_hash_t hash;
+	const char *asmname;
+	char *name = NULL;
+
+	if (fndecl == error_mark_node)
+		return;
+
+	if (TREE_CODE(fndecl) != FUNCTION_DECL)
+		return;
+
+	if (!TREE_PUBLIC(fndecl))
+		return;
+
+	if (DECL_ARTIFICIAL(fndecl))
+		return;
+
+	if (DECL_ABSTRACT_ORIGIN(fndecl) && DECL_ABSTRACT_ORIGIN(fndecl) != fndecl)
+		return;
+
+	asmname = DECL_NAME_POINTER(fndecl);
+	gcc_assert(asmname[0]);
+
+	if (strchr(asmname, '.'))
+		return;
+
+	gcc_assert(asprintf(&name, "__kcfi_typeid_%s", asmname) != -1);
+
+	hash = rap_hash_function_decl(fndecl, imprecise_rap_hash_flags);
+
+	if (report_abs_hash)
+		inform(DECL_SOURCE_LOCATION(fndecl), "abs rap_hash: %x %s", hash.hash, asmname);
+
+	fprintf(asm_out_file, GLOBAL_ASM_OP " %s\n", name);
+	if (TARGET_64BIT)
+		fprintf(asm_out_file, "\t.offset %#lx\n", (long)hash.hash);
+	else
+		fprintf(asm_out_file, "\t.offset %#x\n", hash.hash);
+	ASM_OUTPUT_TYPE_DIRECTIVE(asm_out_file, name, "object");
+	ASM_OUTPUT_LABEL(asm_out_file, name);
+	free(name);
+
+	fprintf(asm_out_file, "\t.previous\n");
+}
+#endif
+
+static bool rap_unignore_gate(void)
+{
+	if (!DECL_IGNORED_P(current_function_decl))
+		return false;
+
+	inform(DECL_SOURCE_LOCATION(current_function_decl), "DECL_IGNORED fixed");
+
+	DECL_IGNORED_P(current_function_decl) = 0;
+	return false;
+}
+
+#define PASS_NAME rap_unignore
+#define NO_EXECUTE
+#define TODO_FLAGS_FINISH TODO_dump_func
+#include "gcc-generate-rtl-pass.h"
+
+static bool rap_version_check(struct plugin_gcc_version *gcc_version, struct plugin_gcc_version *plugin_version)
+{
+	if (!gcc_version || !plugin_version)
+		return false;
+
+#if BUILDING_GCC_VERSION >= 5000
+	if (strncmp(gcc_version->basever, plugin_version->basever, 4))
+#else
+	if (strcmp(gcc_version->basever, plugin_version->basever))
+#endif
+		return false;
+	if (strcmp(gcc_version->datestamp, plugin_version->datestamp))
+		return false;
+	if (strcmp(gcc_version->devphase, plugin_version->devphase))
+		return false;
+	if (strcmp(gcc_version->revision, plugin_version->revision))
+		return false;
+//	if (strcmp(gcc_version->configuration_arguments, plugin_version->configuration_arguments))
+//		return false;
+	return true;
+}
+
+EXPORTED_CONST struct ggc_root_tab gt_ggc_r_gt_rap[] = {
+	{
+		.base = &rap_hash_type_node,
+		.nelt = 1,
+		.stride = sizeof(rap_hash_type_node),
+		.cb = &gt_ggc_mx_tree_node,
+		.pchw = &gt_pch_nx_tree_node
+	},
+	LAST_GGC_ROOT_TAB
+};
+
+static void
+handle_type_cast (void *gcc_data, void *user_data)
+{
+  (void) user_data;
+  tree *t = (tree *) gcc_data;
+  tree type = t[0];
+  tree otype = t[1];
+
+  if (TREE_CODE (type) == POINTER_TYPE
+      && TREE_CODE (otype) == POINTER_TYPE
+      && TREE_CODE (TREE_TYPE (type)) == FUNCTION_TYPE
+      && TREE_CODE (TREE_TYPE (otype)) == FUNCTION_TYPE
+//      && type != TYPE_MAIN_VARIANT (otype)
+      && TYPE_CANONICAL (TREE_TYPE (type)) != TYPE_CANONICAL (TREE_TYPE (otype)))
+        error (G_("cast from function type %qT "
+                  "to non-matching type %qT"), otype, type);
+
+}
+
+__visible int plugin_init(struct plugin_name_args *plugin_info, struct plugin_gcc_version *version)
+{
+	int i;
+	const char * const plugin_name = plugin_info->base_name;
+	const int argc = plugin_info->argc;
+	const struct plugin_argument * const argv = plugin_info->argv;
+	bool enable_call = false;
+	bool enable_abs = false, enable_abs_finish = false;
+
+	struct register_pass_info rap_fptr_pass_info;
+	struct register_pass_info rap_unignore_pass_info;
+
+	rap_fptr_pass_info.pass						= make_rap_fptr_pass();
+	rap_fptr_pass_info.reference_pass_name				= "nrv";
+	rap_fptr_pass_info.ref_pass_instance_number			= 1;
+	rap_fptr_pass_info.pos_op 					= PASS_POS_INSERT_AFTER;
+
+	rap_unignore_pass_info.pass					= make_rap_unignore_pass();
+	rap_unignore_pass_info.reference_pass_name			= "final";
+	rap_unignore_pass_info.ref_pass_instance_number			= 1;
+	rap_unignore_pass_info.pos_op 					= PASS_POS_INSERT_BEFORE;
+
+	if (!rap_version_check(version, &gcc_version)) {
+		error(G_("incompatible gcc/plugin versions"));
+		return 1;
+	}
+
+#if BUILDING_GCC_VERSION >= 5000
+	if (flag_ipa_icf_functions) {
+//		warning_at(UNKNOWN_LOCATION, 0, G_("-fipa-icf is incompatible with %s, disabling..."), plugin_name);
+//		inform(UNKNOWN_LOCATION, G_("-fipa-icf is incompatible with %s, disabling..."), plugin_name);
+		flag_ipa_icf_functions = 0;
+	}
+#endif
+
+	for (i = 0; i < argc; ++i) {
+		if (!strcmp(argv[i].key, "disable"))
+			continue;
+
+		if (!strcmp(argv[i].key, "check")) {
+			char *values, *value, *saveptr;
+
+			if (!argv[i].value) {
+				error(G_("no value supplied for option '-fplugin-arg-%s-%s'"), plugin_name, argv[i].key);
+				continue;
+			}
+
+			values = xstrdup(argv[i].value);
+			value = strtok_r(values, ",", &saveptr);
+			while (value) {
+				if (!strcmp(value, "call"))
+					enable_call = true;
+				else
+					error(G_("unknown value supplied for option '-fplugin-arg-%s-%s=%s'"), plugin_name, argv[i].key, value);
+				value = strtok_r(NULL, ",", &saveptr);
+			}
+			free(values);
+			continue;
+		}
+
+		if (!strcmp(argv[i].key, "hash")) {
+			char *values, *value, *saveptr;
+
+			if (!argv[i].value) {
+				error(G_("no value supplied for option '-fplugin-arg-%s-%s'"), plugin_name, argv[i].key);
+				continue;
+			}
+
+			values = xstrdup(argv[i].value);
+			value = strtok_r(values, ",", &saveptr);
+			while (value) {
+				if (!strcmp(value, "abs"))
+					enable_abs = enable_abs_finish = true;
+				else if (!strcmp(value, "abs-finish"))
+					enable_abs_finish = true;
+//				else if (!strcmp(value, "const"))
+//					imprecise_rap_hash_flags.qual_const = 1;
+//				else if (!strcmp(value, "volatile"))
+//					imprecise_rap_hash_flags.qual_volatile = 1;
+				else
+					error(G_("unknown value supplied for option '-fplugin-arg-%s-%s=%s'"), plugin_name, argv[i].key, value);
+				value = strtok_r(NULL, ",", &saveptr);
+			}
+			free(values);
+			continue;
+		}
+
+		if (!strcmp(argv[i].key, "report")) {
+			char *values, *value, *saveptr;
+
+			if (!argv[i].value) {
+				error(G_("no value supplied for option '-fplugin-arg-%s-%s'"), plugin_name, argv[i].key);
+				continue;
+			}
+
+			values = xstrdup(argv[i].value);
+			value = strtok_r(values, ",", &saveptr);
+			while (value) {
+				if (!strcmp(value, "func"))
+					report_func_hash = true;
+				else if (!strcmp(value, "fptr"))
+					report_fptr_hash = true;
+				else if (!strcmp(value, "abs"))
+					report_abs_hash = true;
+				else
+					error(G_("unknown value supplied for option '-fplugin-arg-%s-%s=%s'"), plugin_name, argv[i].key, value);
+				value = strtok_r(NULL, ",", &saveptr);
+			}
+			free(values);
+			continue;
+		}
+
+		error(G_("unkown option '-fplugin-arg-%s-%s'"), plugin_name, argv[i].key);
+	}
+
+	register_callback(plugin_name, PLUGIN_INFO, NULL, &rap_plugin_info);
+
+	if (enable_call) {
+		register_callback(plugin_name, PLUGIN_PASS_MANAGER_SETUP, NULL, &rap_fptr_pass_info);
+	}
+
+	if (enable_call || enable_abs_finish) {
+#if BUILDING_GCC_VERSION >= 4007
+		if (enable_abs)
+			register_callback(plugin_name, PLUGIN_FINISH_DECL, rap_finish_decl, NULL);
+#else
+#warning TODO
+#endif
+		register_callback(plugin_name, PLUGIN_PASS_MANAGER_SETUP, NULL, &rap_unignore_pass_info);
+		register_callback(plugin_name, PLUGIN_REGISTER_GGC_ROOTS, NULL, (void *)&gt_ggc_r_gt_rap);
+		register_callback(plugin_name, PLUGIN_START_UNIT, rap_start_unit_common, NULL);
+		if (enable_abs_finish)
+			register_callback(plugin_name, PLUGIN_FINISH_UNIT, rap_finish_unit, NULL);
+		register_callback(plugin_name, PLUGIN_ALL_IPA_PASSES_START, rap_calculate_func_hashes, NULL);
+		register_callback (plugin_name, PLUGIN_TYPE_CAST, handle_type_cast, NULL);
+	}
+	return 0;
+}
diff --git a/scripts/gcc-plugins/rap_plugin/sip.c b/scripts/gcc-plugins/rap_plugin/sip.c
new file mode 100644
index 000000000000..65bc1cdea580
--- /dev/null
+++ b/scripts/gcc-plugins/rap_plugin/sip.c
@@ -0,0 +1,96 @@
+// SipHash-2-4 adapted by the PaX Team from the public domain version written by
+//   Jean-Philippe Aumasson <jeanphilippe.aumasson@gmail.com>
+//   Daniel J. Bernstein <djb@cr.yp.to>
+
+#include <stdint.h>
+
+#define ROTL(x, b) (u64)(((x) << (b)) | ((x) >> (64 - (b))))
+
+#define U32TO8_LE(p, v)						\
+	(p)[0] = (u8)((v)      ); (p)[1] = (u8)((v) >>  8);	\
+	(p)[2] = (u8)((v) >> 16); (p)[3] = (u8)((v) >> 24);
+
+#define U64TO8_LE(p, v)				\
+	U32TO8_LE((p),     (u32)((v)      ));	\
+	U32TO8_LE((p) + 4, (u32)((v) >> 32));
+
+#define U8TO64_LE(p)	(	\
+	((u64)((p)[0])      ) |	\
+	((u64)((p)[1]) <<  8) |	\
+	((u64)((p)[2]) << 16) |	\
+	((u64)((p)[3]) << 24) |	\
+	((u64)((p)[4]) << 32) |	\
+	((u64)((p)[5]) << 40) |	\
+	((u64)((p)[6]) << 48) |	\
+	((u64)((p)[7]) << 56))
+
+#define SIPROUND							\
+do {									\
+	v0 += v1; v1 = ROTL(v1, 13); v1 ^= v0; v0 = ROTL(v0, 32);	\
+	v2 += v3; v3 = ROTL(v3, 16); v3 ^= v2;				\
+	v0 += v3; v3 = ROTL(v3, 21); v3 ^= v0;				\
+	v2 += v1; v1 = ROTL(v1, 17); v1 ^= v2; v2 = ROTL(v2, 32);	\
+} while(0)
+
+typedef uint64_t u64;
+typedef uint32_t u32;
+typedef uint8_t u8;
+
+/* SipHash-2-4 with previous output folding, a poor man's streaming interface */
+void siphash24fold(unsigned char *out, const unsigned char *in, unsigned long long inlen, const unsigned char *k);
+
+void siphash24fold(unsigned char *out, const unsigned char *in, unsigned long long inlen, const unsigned char *k)
+{
+	u64 k0 = U8TO64_LE(k);
+	u64 k1 = U8TO64_LE(k + 8);
+	/* "somepseudorandomlygeneratedbytes" */
+	u64 v0 = 0x736f6d6570736575ULL ^ k0;
+	u64 v1 = 0x646f72616e646f6dULL ^ k1;
+	u64 v2 = 0x6c7967656e657261ULL ^ k0;
+	u64 v3 = 0x7465646279746573ULL ^ k1;
+	u64 b, m;
+	const u8 * const end = in + inlen - (inlen % sizeof(u64));
+	const int left = inlen & 7;
+	b = ((u64)inlen) << 56;
+
+	// fold in the previous output
+	m = U8TO64_LE(out);
+	v3 ^= m;
+	SIPROUND;
+	SIPROUND;
+	v0 ^= m;
+
+	// consume full input blocks
+	for (; in != end; in += 8) {
+		m = U8TO64_LE(in);
+		v3 ^= m;
+		SIPROUND;
+		SIPROUND;
+		v0 ^= m;
+	}
+
+	// consume the last potentially partial block
+	switch (left) {
+	case 7: b |= ((u64)in[6]) << 48;
+	case 6: b |= ((u64)in[5]) << 40;
+	case 5: b |= ((u64)in[4]) << 32;
+	case 4: b |= ((u64)in[3]) << 24;
+	case 3: b |= ((u64)in[2]) << 16;
+	case 2: b |= ((u64)in[1]) <<  8;
+	case 1: b |= ((u64)in[0]); break;
+	case 0: break;
+	}
+
+	// finalize
+	v3 ^= b;
+	SIPROUND;
+	SIPROUND;
+	v0 ^= b;
+	v2 ^= 0xff;
+	SIPROUND;
+	SIPROUND;
+	SIPROUND;
+	SIPROUND;
+	b = v0 ^ v1 ^ v2 ^ v3;
+	U64TO8_LE(out, b);
+}
diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index 269bd79bcd9a..367f5a30b77d 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -1774,15 +1774,9 @@ static void check_exports(struct module *mod)
 		const char *basename;
 		exp = find_symbol(s->name);
 		if (!exp) {
-			if (!s->weak && nr_unresolved++ < MAX_UNRESOLVED_REPORTS)
-				modpost_log(warn_unresolved ? LOG_WARN : LOG_ERROR,
-					    "\"%s\" [%s.ko] undefined!\n",
-					    s->name, mod->name);
 			continue;
 		}
 		if (exp->module == mod) {
-			error("\"%s\" [%s.ko] was exported without definition\n",
-			      s->name, mod->name);
 			continue;
 		}
 
diff --git a/security/Kconfig b/security/Kconfig
index 52c9af08ad35..0581ff078066 100644
--- a/security/Kconfig
+++ b/security/Kconfig
@@ -5,6 +5,35 @@
 
 menu "Security options"
 
+menuconfig PAX
+	bool "Enable various PaX features"
+	depends on X86
+	help
+	  This allows you to enable various PaX features.  PaX adds
+	  intrusion prevention mechanisms to the kernel that reduce
+	  the risks posed by exploitable memory corruption bugs.
+
+if PAX
+config PAX_RAP
+	bool "Prevent code reuse attacks"
+	depends on X86_64 && GCC_PLUGINS
+	select CFI_CLANG
+	help
+	  By saying Y here the kernel will check indirect control transfers
+	  in order to detect and prevent attacks that try to hijack control
+	  flow by overwriting code pointers.
+
+	  If you have an amd64 processor that does not support SMEP then you
+	  must also enable a KERNEXEC code pointer instrumentation method
+	  (see PAX_KERNEXEC_PLUGIN).
+
+	  Note that binary modules cannot be instrumented by this approach.
+
+	  Note that the implementation requires a gcc with plugin support,
+	  i.e., gcc 4.5 or newer.  You may need to install the supporting
+	  headers explicitly in addition to the normal gcc package.
+endif
+
 source "security/keys/Kconfig"
 
 config SECURITY_DMESG_RESTRICT
-- 
2.35.6

