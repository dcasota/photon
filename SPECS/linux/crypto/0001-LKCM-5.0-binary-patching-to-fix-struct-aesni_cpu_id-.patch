From 4aac32910a4ca9300b1a6dd7e13cbf189d481fab Mon Sep 17 00:00:00 2001
From: Keerthana K <keerthana.kalyanasundaram@broadcom.com>
Date: Tue, 20 Aug 2024 15:29:10 +0000
Subject: [PATCH] LKCM 5.0 binary patching to fix struct aesni_cpu_id mismatch

x86_cpu_id structure in kernel v6.1.96 is changed. A new member flags
is added just before the last member driver_data. As part of this
change, the INTEL CPU detection code has also been modified to utilize
the flags member. If flags member is not set, then x86_match_cpu will
return NULL. It means the given CPU is not matched with the known array of
available x86_cpu_ids.

commit: https://github.com/gregkh/linux/commit/8ab1361b2eae44077fef4a

Problem:
aesni_intel-glue.c declares and populates aesni_cpu_id. This file is
part of fips_canister.o. So the new changes to struct x86_cpu_id will
not be available for aesni_intel-glue.c.

Fix:
In order to make this work, we have to binary patch aesni_cpu_id value
at runtime. Size of 'aesni_cpu_id[0]' before the commit is 24 bytes
(actually 18 bytes but padded to make it 24 bytes). 6 bytes of padding
is added after 'feature' and before 'driver_data'. Size of
'aesni_cpu_id[0]' after the commit is also 24 bytes, as the flags member
is placed in the padded region.

Fix here is to set the 2 bytes located after 'feature' member
in the padded region with value X86_CPU_ID_FLAG_ENTRY_VALID.
This will act as u16 flags member of aesni_cpu_id.

aesni_cpu_id symbol is located in .rodata section at offset 0x3C0 in fips_canister.o
Logic is to locate the __canister_srodata symbol and add this offset to
reach aesni_cpu_id value and set 10th byte (first 5 u16 members) with
X86_CPU_ID_FLAG_ENTRY_VALID value.

Memory dump of aesni_cpu_id before patching:

 70740 ffff0000 00000000 99000000 00000000  ................
 70750 00000000 00000000 00000000 00000000  ................
 70760 00000000 00000000 00000000 00000000  ................

Memory dump of aesni_cpu_ud after patching:

 70740 ffff0000 00000000 99000100 00000000  ................
 70750 00000000 00000000 00000000 00000000  ................
 70760 00000000 00000000 00000000 00000000  ................

Signed-off-by: Keerthana K <keerthana.kalyanasundaram@broadcom.com>
---
 init/main.c | 56 +++++++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 56 insertions(+)

diff --git a/init/main.c b/init/main.c
index 6df050a..283b6ab 100644
--- a/init/main.c
+++ b/init/main.c
@@ -102,6 +102,7 @@
 #include <linux/stackdepot.h>
 #include <linux/randomize_kstack.h>
 #include <net/net_namespace.h>
+#include <asm/cpu_device_id.h>
 
 #include <asm/io.h>
 #include <asm/setup.h>
@@ -992,6 +993,61 @@ asmlinkage __visible void __init __no_sanitize_address start_kernel(void)
 	random_init_early(command_line);
 
 	fips_integrity_init();
+
+	if(boot_cpu_data.x86_vendor == X86_VENDOR_INTEL &&
+	   boot_cpu_has(X86_FEATURE_AES)) {
+		u8 *s, *hmac, *start, *skip, *end, *pos, *aesni_val_pos;
+		u16 val = 0, flags_val = X86_CPU_ID_FLAG_ENTRY_VALID;
+		static struct x86_cpu_id aesni_cpu_id_value = X86_MATCH_FEATURE(X86_FEATURE_AES, NULL);
+		u8 canister_hmac[32] =
+			{'\xea', '\x46', '\x29', '\x44', '\x7a', '\xe1', '\x87', '\x00',
+			 '\x5c', '\xa7', '\xa1', '\x2a', '\x75', '\x22', '\x0f', '\x28',
+			 '\x3c', '\xde', '\x80', '\x1c', '\x16', '\x0a', '\xa6', '\xbf',
+			 '\xc7', '\x4f', '\x63', '\xe9', '\xf9', '\x40', '\x91', '\x19'};
+
+		/* Check if the size of struct x86_cpu_id is same as expected size */
+		BUG_ON (sizeof(aesni_cpu_id_value) != 24);
+
+		/* Verify LKCM 5.0 signature before patching */
+		hmac = (unsigned char *)kallsyms_lookup_name("canister_hmac");
+		if (!hmac || memcmp (hmac, canister_hmac, 32)) {
+			pr_warn("LKCM 5.0 not found\n");
+			goto quit;
+		}
+		/* Patch location: <canister rodata start> + 0x3c0 + 0xA */
+		s = (u8 *)kallsyms_lookup_name("__canister_srodata");
+		if (!s) {
+			pr_warn("LKCM 5.0 patching failed!"
+				"Symbol __canister_srodata not present\n");
+			goto quit;
+		}
+		start = s + 0x3C0; // start of aesni_cpu_id structure value
+		skip = s + 0x3C0 + 0xA; // Location of flags member in the struct x86_cpu_id
+		end = s + 0x3C0 + 24; // End of aesni_cpu_id structure value
+		aesni_val_pos = (u8 *)&aesni_cpu_id_value;
+
+		for (pos = start; pos < end; pos++, aesni_val_pos++) {
+			/* Skip checking 2 bytes that contains flags */
+			if (pos == skip || pos == (skip+1))
+				continue;
+			/* Check if all the bytes in aesni_cpu_id
+			 * is same as aesni_cpu_id_value */
+			BUG_ON (memcmp (pos, aesni_val_pos, 1));
+		}
+		s = skip;
+		aesni_val_pos = (u8 *)&aesni_cpu_id_value + 0xA;
+
+		/* Verify the bytes that is going to be replaced has value 0 */
+		BUG_ON (memcmp(s, &val, 2));
+
+		/* Sanity check flags member 2 bytes */
+		BUG_ON (memcmp(aesni_val_pos, &flags_val, 2));
+
+		memcpy(s, &flags_val, 2); // Copy 2 bytes of flags
+		pr_info("LKCM 5.0 was patched successfully\n");
+	}
+
+quit:
 	/*
 	 * These use large bootmem allocations and must precede
 	 * kmem_cache_init()
-- 
2.19.0

