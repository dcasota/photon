From 4217ea9f4c392beed90737da46ca90ba059e2328 Mon Sep 17 00:00:00 2001
From: Keerthana K <keerthanak@vmware.com>
Date: Tue, 7 Nov 2023 20:49:00 +0530
Subject: [PATCH] changes to build with jitterentropy v3.4.1

Signed-off-by: Keerthana K <keerthanak@vmware.com>
Signed-off-by: Vamsi Krishna Brahmajosyula <vbrahmajosyula@vmware.com>
---
 crypto/Kconfig               |   1 -
 crypto/Makefile              |   6 +-
 crypto/jitterentropy-kcapi.c | 205 +++--------------------------------
 3 files changed, 19 insertions(+), 193 deletions(-)

diff --git a/crypto/Kconfig b/crypto/Kconfig
index bef3e2310..b5bfc7a80 100644
--- a/crypto/Kconfig
+++ b/crypto/Kconfig
@@ -1306,7 +1306,6 @@ endif	# if CRYPTO_DRBG_MENU
 config CRYPTO_JITTERENTROPY
	tristate "CPU Jitter Non-Deterministic RNG (Random Number Generator)"
	select CRYPTO_RNG
-	select CRYPTO_SHA3
	help
	  CPU Jitter RNG (Random Number Generator) from the Jitterentropy library

diff --git a/crypto/Makefile b/crypto/Makefile
index e68702518..5110df193 100644
--- a/crypto/Makefile
+++ b/crypto/Makefile
@@ -6,6 +6,10 @@
 obj-$(CONFIG_CRYPTO) += crypto.o
 crypto-y := api.o cipher.o compress.o

+obj-$(CONFIG_CRYPTO_JITTERENTROPY) += jitterentropy_rng.o jitterentropy-3.4.1/ jitterentropy-3.4.1/jitterentropy_canister_wrapper.o jitterentropy-3.4.1/jitterentropy_canister_wrapper_asm.o
+
+jitterentropy_rng-y := jitterentropy-kcapi.o
+
 obj-$(CONFIG_CRYPTO_ENGINE) += crypto_engine.o
 obj-$(CONFIG_CRYPTO_FIPS) += fips.o

@@ -168,11 +172,9 @@ obj-$(CONFIG_CRYPTO_842) += 842.o
 obj-$(CONFIG_CRYPTO_RNG2) += rng.o
 obj-$(CONFIG_CRYPTO_ANSI_CPRNG) += ansi_cprng.o
 obj-$(CONFIG_CRYPTO_DRBG) += drbg.o
-obj-$(CONFIG_CRYPTO_JITTERENTROPY) += jitterentropy_rng.o
 CFLAGS_jitterentropy.o = -O0
 KASAN_SANITIZE_jitterentropy.o = n
 UBSAN_SANITIZE_jitterentropy.o = n
-jitterentropy_rng-y := jitterentropy.o jitterentropy-kcapi.o
 obj-$(CONFIG_CRYPTO_JITTERENTROPY_TESTINTERFACE) += jitterentropy-testing.o
 obj-$(CONFIG_CRYPTO_TEST) += tcrypt.o
 obj-$(CONFIG_CRYPTO_GHASH) += ghash-generic.o
diff --git a/crypto/jitterentropy-kcapi.c b/crypto/jitterentropy-kcapi.c
index 7d6408031..f46dcec4d 100644
--- a/crypto/jitterentropy-kcapi.c
+++ b/crypto/jitterentropy-kcapi.c
@@ -37,8 +37,6 @@
  * DAMAGE.
  */

-#include <crypto/hash.h>
-#include <crypto/sha3.h>
 #include <linux/fips.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
@@ -46,9 +44,8 @@
 #include <linux/time.h>
 #include <crypto/internal/rng.h>

-#include "jitterentropy.h"
-
-#define JENT_CONDITIONING_HASH	"sha3-256-generic"
+#include "jitterentropy-3.4.1/jitterentropy.h"
+#include "jitterentropy-3.4.1/jitterentropy-timer.h"

 /***************************************************************************
  * Helper function
@@ -59,123 +56,12 @@ void *jent_zalloc(unsigned int len)
	return kzalloc(len, GFP_KERNEL);
 }

-void jent_zfree(void *ptr)
+void jent_zfree(void *ptr, unsigned int len)
 {
+	memzero_explicit(ptr, len);
	kfree_sensitive(ptr);
 }

-/*
- * Obtain a high-resolution time stamp value. The time stamp is used to measure
- * the execution time of a given code path and its variations. Hence, the time
- * stamp must have a sufficiently high resolution.
- *
- * Note, if the function returns zero because a given architecture does not
- * implement a high-resolution time stamp, the RNG code's runtime test
- * will detect it and will not produce output.
- */
-void jent_get_nstime(__u64 *out)
-{
-	__u64 tmp = 0;
-
-	tmp = random_get_entropy();
-
-	/*
-	 * If random_get_entropy does not return a value, i.e. it is not
-	 * implemented for a given architecture, use a clock source.
-	 * hoping that there are timers we can work with.
-	 */
-	if (tmp == 0)
-		tmp = ktime_get_ns();
-
-	*out = tmp;
-	jent_raw_hires_entropy_store(tmp);
-}
-
-int jent_hash_time(void *hash_state, __u64 time, u8 *addtl,
-		   unsigned int addtl_len, __u64 hash_loop_cnt,
-		   unsigned int stuck)
-{
-	struct shash_desc *hash_state_desc = (struct shash_desc *)hash_state;
-	SHASH_DESC_ON_STACK(desc, hash_state_desc->tfm);
-	u8 intermediary[SHA3_256_DIGEST_SIZE];
-	__u64 j = 0;
-	int ret;
-
-	desc->tfm = hash_state_desc->tfm;
-
-	if (sizeof(intermediary) != crypto_shash_digestsize(desc->tfm)) {
-		pr_warn_ratelimited("Unexpected digest size\n");
-		return -EINVAL;
-	}
-
-	/*
-	 * This loop fills a buffer which is injected into the entropy pool.
-	 * The main reason for this loop is to execute something over which we
-	 * can perform a timing measurement. The injection of the resulting
-	 * data into the pool is performed to ensure the result is used and
-	 * the compiler cannot optimize the loop away in case the result is not
-	 * used at all. Yet that data is considered "additional information"
-	 * considering the terminology from SP800-90A without any entropy.
-	 *
-	 * Note, it does not matter which or how much data you inject, we are
-	 * interested in one Keccack1600 compression operation performed with
-	 * the crypto_shash_final.
-	 */
-	for (j = 0; j < hash_loop_cnt; j++) {
-		ret = crypto_shash_init(desc) ?:
-		      crypto_shash_update(desc, intermediary,
-					  sizeof(intermediary)) ?:
-		      crypto_shash_finup(desc, addtl, addtl_len, intermediary);
-		if (ret)
-			goto err;
-	}
-
-	/*
-	 * Inject the data from the previous loop into the pool. This data is
-	 * not considered to contain any entropy, but it stirs the pool a bit.
-	 */
-	ret = crypto_shash_update(desc, intermediary, sizeof(intermediary));
-	if (ret)
-		goto err;
-
-	/*
-	 * Insert the time stamp into the hash context representing the pool.
-	 *
-	 * If the time stamp is stuck, do not finally insert the value into the
-	 * entropy pool. Although this operation should not do any harm even
-	 * when the time stamp has no entropy, SP800-90B requires that any
-	 * conditioning operation to have an identical amount of input data
-	 * according to section 3.1.5.
-	 */
-	if (!stuck) {
-		ret = crypto_shash_update(hash_state_desc, (u8 *)&time,
-					  sizeof(__u64));
-	}
-
-err:
-	shash_desc_zero(desc);
-	memzero_explicit(intermediary, sizeof(intermediary));
-
-	return ret;
-}
-
-int jent_read_random_block(void *hash_state, char *dst, unsigned int dst_len)
-{
-	struct shash_desc *hash_state_desc = (struct shash_desc *)hash_state;
-	u8 jent_block[SHA3_256_DIGEST_SIZE];
-	/* Obtain data from entropy pool and re-initialize it */
-	int ret = crypto_shash_final(hash_state_desc, jent_block) ?:
-		  crypto_shash_init(hash_state_desc) ?:
-		  crypto_shash_update(hash_state_desc, jent_block,
-				      sizeof(jent_block));
-
-	if (!ret && dst_len)
-		memcpy(dst, jent_block, dst_len);
-
-	memzero_explicit(jent_block, sizeof(jent_block));
-	return ret;
-}
-
 /***************************************************************************
  * Kernel crypto API interface
  ***************************************************************************/
@@ -192,17 +78,6 @@ static void jent_kcapi_cleanup(struct crypto_tfm *tfm)
	struct jitterentropy *rng = crypto_tfm_ctx(tfm);

	spin_lock(&rng->jent_lock);
-
-	if (rng->sdesc) {
-		shash_desc_zero(rng->sdesc);
-		kfree(rng->sdesc);
-	}
-	rng->sdesc = NULL;
-
-	if (rng->tfm)
-		crypto_free_shash(rng->tfm);
-	rng->tfm = NULL;
-
	if (rng->entropy_collector)
		jent_entropy_collector_free(rng->entropy_collector);
	rng->entropy_collector = NULL;
@@ -212,50 +87,13 @@ static void jent_kcapi_cleanup(struct crypto_tfm *tfm)
 static int jent_kcapi_init(struct crypto_tfm *tfm)
 {
	struct jitterentropy *rng = crypto_tfm_ctx(tfm);
-	struct crypto_shash *hash;
-	struct shash_desc *sdesc;
-	int size, ret = 0;
-
-	spin_lock_init(&rng->jent_lock);
-
-	/*
-	 * Use SHA3-256 as conditioner. We allocate only the generic
-	 * implementation as we are not interested in high-performance. The
-	 * execution time of the SHA3 operation is measured and adds to the
-	 * Jitter RNG's unpredictable behavior. If we have a slower hash
-	 * implementation, the execution timing variations are larger. When
-	 * using a fast implementation, we would need to call it more often
-	 * as its variations are lower.
-	 */
-	hash = crypto_alloc_shash(JENT_CONDITIONING_HASH, 0, 0);
-	if (IS_ERR(hash)) {
-		pr_err("Cannot allocate conditioning digest\n");
-		return PTR_ERR(hash);
-	}
-	rng->tfm = hash;
-
-	size = sizeof(struct shash_desc) + crypto_shash_descsize(hash);
-	sdesc = kmalloc(size, GFP_KERNEL);
-	if (!sdesc) {
-		ret = -ENOMEM;
-		goto err;
-	}
-
-	sdesc->tfm = hash;
-	crypto_shash_init(sdesc);
-	rng->sdesc = sdesc;
+	int ret = 0;

-	rng->entropy_collector = jent_entropy_collector_alloc(1, 0, sdesc);
-	if (!rng->entropy_collector) {
+	rng->entropy_collector = jent_entropy_collector_alloc(1, 0);
+	if (!rng->entropy_collector)
		ret = -ENOMEM;
-		goto err;
-	}

	spin_lock_init(&rng->jent_lock);
-	return 0;
-
-err:
-	jent_kcapi_cleanup(tfm);
	return ret;
 }

@@ -287,14 +125,16 @@ static int jent_kcapi_random(struct crypto_rng *tfm,
		/* Handle intermittent health test error */
		pr_warn_ratelimited("Reset Jitter RNG due to intermittent health test failure\n");
		ret = -EAGAIN;
-	} else if (ret == -1) {
-		/* Handle other errors */
-		ret = -EINVAL;
+	} else {
+		if (ret < 0) {
+			/* Handle other errors */
+			ret = -EINVAL;
+		}
	}

	spin_unlock(&rng->jent_lock);

-	return ret;
+	return ret > 0 ? 0 : ret;
 }

 static int jent_kcapi_reset(struct crypto_rng *tfm,
@@ -320,29 +160,14 @@ static struct rng_alg jent_alg = {

 static int __init jent_mod_init(void)
 {
-	SHASH_DESC_ON_STACK(desc, tfm);
-	struct crypto_shash *tfm;
	int ret = 0;

-	jent_testing_init();
-
-	tfm = crypto_alloc_shash(JENT_CONDITIONING_HASH, 0, 0);
-	if (IS_ERR(tfm)) {
-		jent_testing_exit();
-		return PTR_ERR(tfm);
-	}
-
-	desc->tfm = tfm;
-	crypto_shash_init(desc);
-	ret = jent_entropy_init(desc);
-	shash_desc_zero(desc);
-	crypto_free_shash(tfm);
+	ret = jent_entropy_init();
	if (ret) {
		/* Handle permanent health test error */
		if (fips_enabled)
			panic("jitterentropy: Initialization failed with host not compliant with requirements: %d\n", ret);

-		jent_testing_exit();
		pr_info("jitterentropy: Initialization failed with host not compliant with requirements: %d\n", ret);
		return -EFAULT;
	}
@@ -351,7 +176,6 @@ static int __init jent_mod_init(void)

 static void __exit jent_mod_exit(void)
 {
-	jent_testing_exit();
	crypto_unregister_rng(&jent_alg);
 }

@@ -361,5 +185,6 @@ module_exit(jent_mod_exit);

 MODULE_LICENSE("Dual BSD/GPL");
 MODULE_AUTHOR("Stephan Mueller <smueller@chronox.de>");
+MODULE_AUTHOR("Srinidhi Rao <srinidhir@vmware.com>");
 MODULE_DESCRIPTION("Non-physical True Random Number Generator based on CPU Jitter");
 MODULE_ALIAS_CRYPTO("jitterentropy_rng");
--
2.41.0
