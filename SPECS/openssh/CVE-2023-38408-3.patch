From 099cdf59ce1e72f55d421c8445bf6321b3004755 Mon Sep 17 00:00:00 2001
From: "djm@openbsd.org" <djm@openbsd.org>
Date: Wed, 19 Jul 2023 14:03:45 +0000
Subject: [PATCH] upstream: Separate ssh-pkcs11-helpers for each p11 module

Make ssh-pkcs11-client start an independent helper for each provider,
providing better isolation between modules and reliability if a single
module misbehaves.

This also implements reference counting of PKCS#11-hosted keys,
allowing ssh-pkcs11-helper subprocesses to be automatically reaped
when no remaining keys reference them. This fixes some bugs we have
that make PKCS11 keys unusable after they have been deleted, e.g.
https://bugzilla.mindrot.org/show_bug.cgi?id=3125

ok markus@

OpenBSD-Commit-ID: 0ce188b14fe271ab0568f4500070d96c5657244e

[shivania2: ported to v7.8p1. Bringback OPENSSL_HAS_ECC to ssh-pkcs11-client
https://github.com/openssh/openssh-portable/commit/51fda734e0d3c2df256fc03e8b060c4305be6e59.
Changed error_f, debug_f and fatal_f calls to error, debug and fatal calls 
respectively as defined in openssh-v7.8p1. Removed RSA_meth function calls which are not supported in openssh-v7.8p1]
Signed-off-by: Shivani Agarwal <shivania2@vmware.com>
---
 ssh-pkcs11-client.c | 465 ++++++++++++++++++++++++++++++++++++--------
 1 file changed, 389 insertions(+), 76 deletions(-)

diff --git a/ssh-pkcs11-client.c b/ssh-pkcs11-client.c
index 028b272..ea9def3 100644
--- a/ssh-pkcs11-client.c
+++ b/ssh-pkcs11-client.c
@@ -1,6 +1,7 @@
-/* $OpenBSD: ssh-pkcs11-client.c,v 1.10 2018/07/09 21:59:10 markus Exp $ */
+/* $OpenBSD: ssh-pkcs11-client.c,v 1.18 2023/07/19 14:03:45 djm Exp $ */
 /*
  * Copyright (c) 2010 Markus Friedl.  All rights reserved.
+ * Copyright (c) 2014 Pedro Martelletto. All rights reserved.
  *
  * Permission to use, copy, modify, and distribute this software for any
  * purpose with or without fee is hereby granted, provided that the above
@@ -29,7 +30,9 @@
 #include <string.h>
 #include <unistd.h>
 #include <errno.h>
+#include <limits.h>
 
+#include <openssl/ecdsa.h>
 #include <openssl/rsa.h>
 
 #include "pathnames.h"
@@ -43,34 +46,167 @@
 #include "ssh-pkcs11.h"
 #include "ssherr.h"
 
+#include "openbsd-compat/openssl-compat.h"
+
+#if !defined(OPENSSL_HAS_ECC) || !defined(HAVE_EC_KEY_METHOD_NEW)
+#define EC_KEY_METHOD void
+#define EC_KEY void
+#endif
+
 /* borrows code from sftp-server and ssh-agent */
 
-int fd = -1;
-pid_t pid = -1;
+/*
+ * Maintain a list of ssh-pkcs11-helper subprocesses. These may be looked up
+ * by provider path or their unique EC/RSA METHOD pointers.
+ */
+struct helper {
+	char *path;
+	pid_t pid;
+	int fd;
+	RSA_METHOD *rsa_meth;
+	EC_KEY_METHOD *ec_meth;
+	int (*rsa_finish)(RSA *rsa);
+	void (*ec_finish)(EC_KEY *key);
+	size_t nrsa, nec; /* number of active keys of each type */
+};
+static struct helper **helpers;
+static size_t nhelpers;
+
+static struct helper *
+helper_by_provider(const char *path)
+{
+	size_t i;
+
+	for (i = 0; i < nhelpers; i++) {
+		if (helpers[i] == NULL || helpers[i]->path == NULL ||
+		    helpers[i]->fd == -1)
+			continue;
+		if (strcmp(helpers[i]->path, path) == 0)
+			return helpers[i];
+	}
+	return NULL;
+}
+
+static struct helper *
+helper_by_rsa(const RSA *rsa)
+{
+	size_t i;
+	const RSA_METHOD *meth;
+
+	if ((meth = RSA_get_method(rsa)) == NULL)
+		return NULL;
+	for (i = 0; i < nhelpers; i++) {
+		if (helpers[i] != NULL && helpers[i]->rsa_meth == meth)
+			return helpers[i];
+	}
+	return NULL;
+
+}
+
+#if defined(OPENSSL_HAS_ECC) && defined(HAVE_EC_KEY_METHOD_NEW)
+static struct helper *
+helper_by_ec(const EC_KEY *ec)
+{
+	size_t i;
+	const EC_KEY_METHOD *meth;
+
+	if ((meth = EC_KEY_get_method(ec)) == NULL)
+		return NULL;
+	for (i = 0; i < nhelpers; i++) {
+		if (helpers[i] != NULL && helpers[i]->ec_meth == meth)
+			return helpers[i];
+	}
+	return NULL;
+
+}
+#endif /* defined(OPENSSL_HAS_ECC) && defined(HAVE_EC_KEY_METHOD_NEW) */
+
+static void
+helper_free(struct helper *helper)
+{
+	size_t i;
+	int found = 0;
+
+	if (helper == NULL)
+		return;
+	if (helper->path == NULL || helper->ec_meth == NULL ||
+	    helper->rsa_meth == NULL)
+		fatal("inconsistent helper");
+	debug3("free helper for provider %s", helper->path);
+	for (i = 0; i < nhelpers; i++) {
+		if (helpers[i] == helper) {
+			if (found)
+				fatal("helper recorded more than once");
+			found = 1;
+		}
+		else if (found)
+			helpers[i - 1] = helpers[i];
+	}
+	if (found) {
+		helpers = xrecallocarray(helpers, nhelpers,
+		    nhelpers - 1, sizeof(*helpers));
+		nhelpers--;
+	}
+	free(helper->path);
+#if defined(OPENSSL_HAS_ECC) && defined(HAVE_EC_KEY_METHOD_NEW)
+	EC_KEY_METHOD_free(helper->ec_meth);
+#endif
+	free(helper);
+}
 
 static void
-send_msg(struct sshbuf *m)
+helper_terminate(struct helper *helper)
+{
+	if (helper == NULL) {
+		return;
+	} else if (helper->fd == -1) {
+		debug3("already terminated");
+	} else {
+		debug3("terminating helper for %s; "
+		    "remaining %zu RSA %zu ECDSA",
+		    helper->path, helper->nrsa, helper->nec);
+		close(helper->fd);
+		/* XXX waitpid() */
+		helper->fd = -1;
+		helper->pid = -1;
+	}
+	/*
+	 * Don't delete the helper entry until there are no remaining keys
+	 * that reference it. Otherwise, any signing operation would call
+	 * a free'd METHOD pointer and that would be bad.
+	 */
+	if (helper->nrsa == 0 && helper->nec == 0)
+		helper_free(helper);
+}
+
+static void
+send_msg(int fd, struct sshbuf *m)
 {
 	u_char buf[4];
 	size_t mlen = sshbuf_len(m);
 	int r;
 
+	if (fd == -1)
+		return;
 	POKE_U32(buf, mlen);
 	if (atomicio(vwrite, fd, buf, 4) != 4 ||
 	    atomicio(vwrite, fd, sshbuf_mutable_ptr(m),
 	    sshbuf_len(m)) != sshbuf_len(m))
 		error("write to helper failed");
 	if ((r = sshbuf_consume(m, mlen)) != 0)
-		fatal("%s: buffer error: %s", __func__, ssh_err(r));
+		fatal("consume");
 }
 
 static int
-recv_msg(struct sshbuf *m)
+recv_msg(int fd, struct sshbuf *m)
 {
 	u_int l, len;
 	u_char c, buf[1024];
 	int r;
 
+	sshbuf_reset(m);
+	if (fd == -1)
+		return 0; /* XXX */
 	if ((len = atomicio(read, fd, buf, 4)) != 4) {
 		error("read from helper failed: %u", len);
 		return (0); /* XXX */
@@ -79,7 +215,6 @@ recv_msg(struct sshbuf *m)
 	if (len > 256 * 1024)
 		fatal("response too long: %u", len);
 	/* read len bytes into m */
-	sshbuf_reset(m);
 	while (len > 0) {
 		l = len;
 		if (l > sizeof(buf))
@@ -89,94 +224,263 @@ recv_msg(struct sshbuf *m)
 			return (0); /* XXX */
 		}
 		if ((r = sshbuf_put(m, buf, l)) != 0)
-			fatal("%s: buffer error: %s", __func__, ssh_err(r));
+			fatal("sshbuf_put");
 		len -= l;
 	}
 	if ((r = sshbuf_get_u8(m, &c)) != 0)
-		fatal("%s: buffer error: %s", __func__, ssh_err(r));
+		fatal("parse type");
 	return c;
 }
 
 int
 pkcs11_init(int interactive)
 {
-	return (0);
+	return 0;
 }
 
 void
 pkcs11_terminate(void)
 {
-	if (fd >= 0)
-		close(fd);
+	size_t i;
+
+	debug3("terminating %zu helpers", nhelpers);
+	for (i = 0; i < nhelpers; i++)
+		helper_terminate(helpers[i]);
 }
 
 static int
-pkcs11_rsa_private_encrypt(int flen, const u_char *from, u_char *to, RSA *rsa,
-    int padding)
+rsa_encrypt(int flen, const u_char *from, u_char *to, RSA *rsa, int padding)
 {
-	struct sshkey key;	/* XXX */
-	u_char *blob, *signature = NULL;
+	struct sshkey *key = NULL;
+	struct sshbuf *msg = NULL;
+	u_char *blob = NULL, *signature = NULL;
 	size_t blen, slen = 0;
 	int r, ret = -1;
-	struct sshbuf *msg;
+	struct helper *helper;
 
+	if ((helper = helper_by_rsa(rsa)) == NULL || helper->fd == -1)
+		fatal("no helper for PKCS11 key");
+	debug3("signing with PKCS11 provider %s", helper->path);
 	if (padding != RSA_PKCS1_PADDING)
-		return (-1);
-	key.type = KEY_RSA;
-	key.rsa = rsa;
-	if ((r = sshkey_to_blob(&key, &blob, &blen)) != 0) {
-		error("%s: sshkey_to_blob: %s", __func__, ssh_err(r));
-		return -1;
+		goto fail;
+	key = sshkey_new(KEY_UNSPEC);
+	if (key == NULL) {
+		error("sshkey_new failed");
+		goto fail;
+	}
+	key->type = KEY_RSA;
+	RSA_up_ref(rsa);
+	key->rsa = rsa;
+	if ((r = sshkey_to_blob(key, &blob, &blen)) != 0) {
+		error("encode key");
+		goto fail;
 	}
 	if ((msg = sshbuf_new()) == NULL)
-		fatal("%s: sshbuf_new failed", __func__);
+		fatal("sshbuf_new failed");
 	if ((r = sshbuf_put_u8(msg, SSH2_AGENTC_SIGN_REQUEST)) != 0 ||
 	    (r = sshbuf_put_string(msg, blob, blen)) != 0 ||
 	    (r = sshbuf_put_string(msg, from, flen)) != 0 ||
 	    (r = sshbuf_put_u32(msg, 0)) != 0)
-		fatal("%s: buffer error: %s", __func__, ssh_err(r));
-	free(blob);
-	send_msg(msg);
+		fatal("compose");
+	send_msg(helper->fd, msg);
 	sshbuf_reset(msg);
 
-	if (recv_msg(msg) == SSH2_AGENT_SIGN_RESPONSE) {
+	if (recv_msg(helper->fd, msg) == SSH2_AGENT_SIGN_RESPONSE) {
 		if ((r = sshbuf_get_string(msg, &signature, &slen)) != 0)
-			fatal("%s: buffer error: %s", __func__, ssh_err(r));
+			fatal("parse");
 		if (slen <= (size_t)RSA_size(rsa)) {
 			memcpy(to, signature, slen);
 			ret = slen;
 		}
 		free(signature);
 	}
+ fail:
+	free(blob);
+	sshkey_free(key);
 	sshbuf_free(msg);
 	return (ret);
 }
 
-/* redirect the private key encrypt operation to the ssh-pkcs11-helper */
 static int
-wrap_key(RSA *rsa)
+rsa_finish(RSA *rsa)
 {
-	static RSA_METHOD helper_rsa;
+	struct helper *helper;
 
-	memcpy(&helper_rsa, RSA_get_default_method(), sizeof(helper_rsa));
-	helper_rsa.name = "ssh-pkcs11-helper";
-	helper_rsa.rsa_priv_enc = pkcs11_rsa_private_encrypt;
-	RSA_set_method(rsa, &helper_rsa);
-	return (0);
+	if ((helper = helper_by_rsa(rsa)) == NULL)
+		fatal("no helper for PKCS11 key");
+	debug3("free PKCS11 RSA key for provider %s", helper->path);
+	if (helper->rsa_finish != NULL)
+		helper->rsa_finish(rsa);
+	if (helper->nrsa == 0)
+		fatal("RSA refcount error");
+	helper->nrsa--;
+	debug3("provider %s remaining keys: %zu RSA %zu ECDSA",
+	    helper->path, helper->nrsa, helper->nec);
+	if (helper->nrsa == 0 && helper->nec == 0)
+		helper_terminate(helper);
+	return 1;
+}
+
+#if defined(OPENSSL_HAS_ECC) && defined(HAVE_EC_KEY_METHOD_NEW)
+static ECDSA_SIG *
+ecdsa_do_sign(const unsigned char *dgst, int dgst_len, const BIGNUM *inv,
+    const BIGNUM *rp, EC_KEY *ec)
+{
+	struct sshkey *key = NULL;
+	struct sshbuf *msg = NULL;
+	ECDSA_SIG *ret = NULL;
+	const u_char *cp;
+	u_char *blob = NULL, *signature = NULL;
+	size_t blen, slen = 0;
+	int r, nid;
+	struct helper *helper;
+
+	if ((helper = helper_by_ec(ec)) == NULL || helper->fd == -1)
+		fatal("no helper for PKCS11 key");
+	debug3("signing with PKCS11 provider %s", helper->path);
+	nid = sshkey_ecdsa_key_to_nid(ec);
+	if (nid < 0) {
+		error("couldn't get curve nid");
+		goto fail;
+	}
+
+	key = sshkey_new(KEY_UNSPEC);
+	if (key == NULL) {
+		error("sshkey_new failed");
+		goto fail;
+	}
+	key->ecdsa = ec;
+	key->ecdsa_nid = nid;
+	key->type = KEY_ECDSA;
+	EC_KEY_up_ref(ec);
+
+	if ((r = sshkey_to_blob(key, &blob, &blen)) != 0) {
+		error("encode key");
+		goto fail;
+	}
+	if ((msg = sshbuf_new()) == NULL)
+		fatal("sshbuf_new failed");
+	if ((r = sshbuf_put_u8(msg, SSH2_AGENTC_SIGN_REQUEST)) != 0 ||
+	    (r = sshbuf_put_string(msg, blob, blen)) != 0 ||
+	    (r = sshbuf_put_string(msg, dgst, dgst_len)) != 0 ||
+	    (r = sshbuf_put_u32(msg, 0)) != 0)
+		fatal("compose");
+	send_msg(helper->fd, msg);
+	sshbuf_reset(msg);
+
+	if (recv_msg(helper->fd, msg) == SSH2_AGENT_SIGN_RESPONSE) {
+		if ((r = sshbuf_get_string(msg, &signature, &slen)) != 0)
+			fatal("parse");
+		cp = signature;
+		ret = d2i_ECDSA_SIG(NULL, &cp, slen);
+		free(signature);
+	}
+
+ fail:
+	free(blob);
+	sshkey_free(key);
+	sshbuf_free(msg);
+	return (ret);
+}
+
+static void
+ecdsa_do_finish(EC_KEY *ec)
+{
+	struct helper *helper;
+
+	if ((helper = helper_by_ec(ec)) == NULL)
+		fatal("no helper for PKCS11 key");
+	debug3("free PKCS11 ECDSA key for provider %s", helper->path);
+	if (helper->ec_finish != NULL)
+		helper->ec_finish(ec);
+	if (helper->nec == 0)
+		fatal("ECDSA refcount error");
+	helper->nec--;
+	debug3("provider %s remaining keys: %zu RSA %zu ECDSA",
+	    helper->path, helper->nrsa, helper->nec);
+	if (helper->nrsa == 0 && helper->nec == 0)
+		helper_terminate(helper);
+}
+#endif /* defined(OPENSSL_HAS_ECC) && defined(HAVE_EC_KEY_METHOD_NEW) */
+
+/* redirect private key crypto operations to the ssh-pkcs11-helper */
+static void
+wrap_key(struct helper *helper, struct sshkey *k)
+{
+	debug3("wrap %s for provider %s", sshkey_type(k), helper->path);
+	if (k->type == KEY_RSA) {
+		RSA_set_method(k->rsa, helper->rsa_meth);
+		if (helper->nrsa++ >= INT_MAX)
+			fatal("RSA refcount error");
+#if defined(OPENSSL_HAS_ECC) && defined(HAVE_EC_KEY_METHOD_NEW)
+	} else if (k->type == KEY_ECDSA) {
+		EC_KEY_set_method(k->ecdsa, helper->ec_meth);
+		if (helper->nec++ >= INT_MAX)
+			fatal("EC refcount error");
+#endif
+	} else
+		fatal("unknown key type");
+	k->flags |= SSHKEY_FLAG_EXT;
+	debug3("provider %s remaining keys: %zu RSA %zu ECDSA",
+	    helper->path, helper->nrsa, helper->nec);
 }
 
 static int
-pkcs11_start_helper(void)
+pkcs11_start_helper_methods(struct helper *helper)
+{
+	RSA_METHOD *rsa_meth;
+	EC_KEY_METHOD *ec_meth = NULL;
+#if defined(OPENSSL_HAS_ECC) && defined(HAVE_EC_KEY_METHOD_NEW)
+	int (*ec_init)(EC_KEY *key);
+	int (*ec_copy)(EC_KEY *dest, const EC_KEY *src);
+	int (*ec_set_group)(EC_KEY *key, const EC_GROUP *grp);
+	int (*ec_set_private)(EC_KEY *key, const BIGNUM *priv_key);
+	int (*ec_set_public)(EC_KEY *key, const EC_POINT *pub_key);
+	int (*ec_sign)(int, const unsigned char *, int, unsigned char *,
+	    unsigned int *, const BIGNUM *, const BIGNUM *, EC_KEY *) = NULL;
+
+	if ((ec_meth = EC_KEY_METHOD_new(EC_KEY_OpenSSL())) == NULL)
+		return -1;
+	EC_KEY_METHOD_get_sign(ec_meth, &ec_sign, NULL, NULL);
+	EC_KEY_METHOD_set_sign(ec_meth, ec_sign, NULL, ecdsa_do_sign);
+	EC_KEY_METHOD_get_init(ec_meth, &ec_init, &helper->ec_finish,
+	    &ec_copy, &ec_set_group, &ec_set_private, &ec_set_public);
+	EC_KEY_METHOD_set_init(ec_meth, ec_init, ecdsa_do_finish,
+	    ec_copy, ec_set_group, ec_set_private, ec_set_public);
+#endif /* defined(OPENSSL_HAS_ECC) && defined(HAVE_EC_KEY_METHOD_NEW) */
+
+	helper->ec_meth = ec_meth;
+	helper->rsa_meth = rsa_meth;
+	return 0;
+}
+
+static struct helper *
+pkcs11_start_helper(const char *path)
 {
 	int pair[2];
+	char *prog, *verbosity = NULL;
+	struct helper *helper;
+	pid_t pid;
 
+	if (nhelpers >= INT_MAX)
+		fatal("too many helpers");
+	debug3("start helper for %s", path);
 	if (socketpair(AF_UNIX, SOCK_STREAM, 0, pair) == -1) {
 		error("socketpair: %s", strerror(errno));
-		return (-1);
+		return NULL;
+	}
+	helper = xcalloc(1, sizeof(*helper));
+	if (pkcs11_start_helper_methods(helper) == -1) {
+		error("pkcs11_start_helper_methods failed");
+		goto fail;
 	}
 	if ((pid = fork()) == -1) {
 		error("fork: %s", strerror(errno));
-		return (-1);
+ fail:
+		close(pair[0]);
+		close(pair[1]);
+		free(helper);
+		return NULL;
 	} else if (pid == 0) {
 		if ((dup2(pair[1], STDIN_FILENO) == -1) ||
 		    (dup2(pair[1], STDOUT_FILENO) == -1)) {
@@ -185,55 +489,71 @@ pkcs11_start_helper(void)
 		}
 		close(pair[0]);
 		close(pair[1]);
-		execlp(_PATH_SSH_PKCS11_HELPER, _PATH_SSH_PKCS11_HELPER,
-		    (char *)NULL);
-		fprintf(stderr, "exec: %s: %s\n", _PATH_SSH_PKCS11_HELPER,
-		    strerror(errno));
+		prog = getenv("SSH_PKCS11_HELPER");
+		if (prog == NULL || strlen(prog) == 0)
+			prog = _PATH_SSH_PKCS11_HELPER;
+		if (log_level_get() >= SYSLOG_LEVEL_DEBUG1)
+			verbosity = "-vvv";
+		debug("starting %s %s", prog,
+		    verbosity == NULL ? "" : verbosity);
+		execlp(prog, prog, verbosity, (char *)NULL);
+		fprintf(stderr, "exec: %s: %s\n", prog, strerror(errno));
 		_exit(1);
 	}
 	close(pair[1]);
-	fd = pair[0];
-	return (0);
+	helper->fd = pair[0];
+	helper->path = xstrdup(path);
+	helper->pid = pid;
+	debug3("helper %zu for \"%s\" on fd %d pid %ld", nhelpers,
+	    helper->path, helper->fd, (long)helper->pid);
+	helpers = xrecallocarray(helpers, nhelpers,
+	    nhelpers + 1, sizeof(*helpers));
+	helpers[nhelpers++] = helper;
+	return helper;
 }
 
 int
 pkcs11_add_provider(char *name, char *pin, struct sshkey ***keysp)
 {
 	struct sshkey *k;
-	int r;
+	int r, type;
 	u_char *blob;
 	size_t blen;
 	u_int nkeys, i;
 	struct sshbuf *msg;
+	struct helper *helper;
 
-	if (fd < 0 && pkcs11_start_helper() < 0)
-		return (-1);
+	if ((helper = helper_by_provider(name)) == NULL &&
+	    (helper = pkcs11_start_helper(name)) == NULL)
+		return -1;
 
 	if ((msg = sshbuf_new()) == NULL)
-		fatal("%s: sshbuf_new failed", __func__);
+		fatal("sshbuf_new failed");
 	if ((r = sshbuf_put_u8(msg, SSH_AGENTC_ADD_SMARTCARD_KEY)) != 0 ||
 	    (r = sshbuf_put_cstring(msg, name)) != 0 ||
 	    (r = sshbuf_put_cstring(msg, pin)) != 0)
-		fatal("%s: buffer error: %s", __func__, ssh_err(r));
-	send_msg(msg);
+		fatal("compose");
+	send_msg(helper->fd, msg);
 	sshbuf_reset(msg);
 
-	if (recv_msg(msg) == SSH2_AGENT_IDENTITIES_ANSWER) {
+	type = recv_msg(helper->fd, msg);
+	if (type == SSH2_AGENT_IDENTITIES_ANSWER) {
 		if ((r = sshbuf_get_u32(msg, &nkeys)) != 0)
-			fatal("%s: buffer error: %s", __func__, ssh_err(r));
+			fatal("parse nkeys");
 		*keysp = xcalloc(nkeys, sizeof(struct sshkey *));
 		for (i = 0; i < nkeys; i++) {
 			/* XXX clean up properly instead of fatal() */
-			if ((r = sshbuf_get_string(msg, &blob, &blen)) != 0 ||
-			    (r = sshbuf_skip_string(msg)) != 0)
-				fatal("%s: buffer error: %s",
-				    __func__, ssh_err(r));
+			if ((r = sshbuf_get_string(msg, &blob, &blen)) != 0)
+				fatal("parse key");
 			if ((r = sshkey_from_blob(blob, blen, &k)) != 0)
-				fatal("%s: bad key: %s", __func__, ssh_err(r));
-			wrap_key(k->rsa);
+				fatal("decode key");
+			wrap_key(helper, k);
 			(*keysp)[i] = k;
 			free(blob);
 		}
+	} else if (type == SSH2_AGENT_FAILURE) {
+		if ((r = sshbuf_get_u32(msg, &nkeys)) != 0)
+			nkeys = -1;
 	} else {
 		nkeys = -1;
 	}
@@ -244,22 +564,15 @@ pkcs11_add_provider(char *name, char *pin, struct sshkey ***keysp)
 int
 pkcs11_del_provider(char *name)
 {
-	int r, ret = -1;
-	struct sshbuf *msg;
-
-	if ((msg = sshbuf_new()) == NULL)
-		fatal("%s: sshbuf_new failed", __func__);
-	if ((r = sshbuf_put_u8(msg, SSH_AGENTC_REMOVE_SMARTCARD_KEY)) != 0 ||
-	    (r = sshbuf_put_cstring(msg, name)) != 0 ||
-	    (r = sshbuf_put_cstring(msg, "")) != 0)
-		fatal("%s: buffer error: %s", __func__, ssh_err(r));
-	send_msg(msg);
-	sshbuf_reset(msg);
+	struct helper *helper;
 
-	if (recv_msg(msg) == SSH_AGENT_SUCCESS)
-		ret = 0;
-	sshbuf_free(msg);
-	return (ret);
+	/*
+	 * ssh-agent deletes keys before calling this, so the helper entry
+	 * should be gone before we get here.
+	 */
+	debug3("delete %s", name);
+	if ((helper = helper_by_provider(name)) != NULL)
+		helper_terminate(helper);
+	return 0;
 }
-
 #endif /* ENABLE_PKCS11 */
-- 
2.35.6

