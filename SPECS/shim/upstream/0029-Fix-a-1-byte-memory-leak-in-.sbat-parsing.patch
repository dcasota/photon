From a0673e36db13e660f809de3e60900cb9381f8589 Mon Sep 17 00:00:00 2001
From: Peter Jones <pjones@redhat.com>
Date: Wed, 28 Jun 2023 16:47:48 -0400
Subject: [PATCH 29/35] Fix a 1-byte memory leak in .sbat parsing.

On the occasion that .sbat is entirely made of characters that aren't
meaningfully CSV /data/, but which the parser accepts (i.e. newline), we
currently allocate a byte of memory which then gets leaked.

This patch tests for that condition and skips the allocation when there
aren't any actual /entries/ to parse.

Signed-off-by: Peter Jones <pjones@redhat.com>
---
 sbat.c      | 10 +++++++++-
 test-sbat.c | 18 ++++++++++++++++++
 2 files changed, 27 insertions(+), 1 deletion(-)

diff --git a/sbat.c b/sbat.c
index a08c5b2..4e51f2e 100644
--- a/sbat.c
+++ b/sbat.c
@@ -15,7 +15,7 @@ parse_sbat_section(char *section_base, size_t section_size,
 		   size_t *n_entries,
 		   struct sbat_section_entry ***entriesp)
 {
-	struct sbat_section_entry *entry = NULL, **entries;
+	struct sbat_section_entry *entry = NULL, **entries = NULL;
 	EFI_STATUS efi_status = EFI_SUCCESS;
 	list_t csv, *pos = NULL;
 	char * end = section_base + section_size - 1;
@@ -67,6 +67,13 @@ parse_sbat_section(char *section_base, size_t section_size,
 		n++;
 	}
 
+	/*
+	 * Not necessarily actually an *error* since we eat newlines and
+	 * the like; it could actually just be /empty/.
+	 */
+	if (n == 0)
+		goto out;
+
 	strtab = AllocateZeroPool(allocsz);
 	if (!strtab) {
 		efi_status = EFI_OUT_OF_RESOURCES;
@@ -101,6 +108,7 @@ parse_sbat_section(char *section_base, size_t section_size,
 		entry++;
 		n++;
 	}
+out:
 	*entriesp = entries;
 	*n_entries = n;
 err:
diff --git a/test-sbat.c b/test-sbat.c
index 1bba6e2..0ee3d69 100644
--- a/test-sbat.c
+++ b/test-sbat.c
@@ -195,6 +195,22 @@ free_mock_sbat_entries(list_t *entries)
 /*
  * parse_sbat_section() tests
  */
+int
+test_parse_sbat_tiny(void)
+{
+	char section_base[] = "\0a\00";
+	size_t section_size = 2;
+	struct sbat_section_entry **entries;
+	size_t n = 0;
+	EFI_STATUS status;
+
+	status = parse_sbat_section(section_base, section_size, &n, &entries);
+	assert_equal_return(status, EFI_SUCCESS, -1, "got %#hhx expected %#hhx\n");
+	assert_equal_return(n, 0, -1, "got %#hhx expected %#hhx\n");
+
+	return 0;
+}
+
 int
 test_parse_sbat_section_null_sbat_base(void)
 {
@@ -1141,7 +1157,9 @@ int
 main(void)
 {
 	int status = 0;
+
 	// parse_sbat section tests
+	test(test_parse_sbat_tiny);
 	test(test_parse_sbat_section_null_sbat_base);
 	test(test_parse_sbat_section_zero_sbat_size);
 	test(test_parse_sbat_section_null_entries);
-- 
2.39.0

