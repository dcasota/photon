From 6376d8b5f880b443c3fe36bc799c95f6ea3eda2e Mon Sep 17 00:00:00 2001
From: Him Kalyan Bordoloi <bordoloih@vmware.com>
Date: Wed, 19 Jul 2023 19:42:37 +0000
Subject: [PATCH] stalld: Move logging to dedicated thread

All logging in stalld is synchronous. Moreover stalld operates in an
environment where system hangs due to various reasons are common.
We have encountered several instances where IO is stuck across the system.
As a consequence stalld also gets stuck in uninterruptible sleep state.

We are moving all logging to a dedicated thread, so that even if IO is
blocked, stalld can continue boosting starving threads.

I have left warn and die messages alone for now.
---
 src/stalld.c | 93 +++++++++++++++++++++++++++++++++++++++++++++++++++-
 src/stalld.h | 24 ++++++++++++++
 src/utils.c  | 74 +++++++++++++++++++++++++++++++++--------
 3 files changed, 176 insertions(+), 15 deletions(-)

diff --git a/src/stalld.c b/src/stalld.c
index 8ddf760..d5c652c 100644
--- a/src/stalld.c
+++ b/src/stalld.c
@@ -53,6 +53,10 @@ int config_write_kmesg = 0;
 int config_log_syslog = 1;
 int config_log_only = 0;
 int config_foreground = 0;
+int config_threaded_log = 0;
+struct log_queue log_queue;
+struct log_thread logging_thread;
+unsigned long config_log_buffer_size = 1000;
 
 /*
  * denylisting feature
@@ -2001,6 +2005,83 @@ int check_policies(void)
 	return boosted;
 }
 
+void* logging_main(void* arg) {
+
+	while (1) {
+		pthread_mutex_lock(&log_queue.mutex);
+		/*
+		 * Wait here until there is something to log
+		 */
+		while (log_queue.count == 0 && running) {
+			pthread_cond_wait(&log_queue.not_empty, &log_queue.mutex);
+		}
+
+		/*
+		 * Exit when stalld has stopped and all pending logs are printed
+		 */
+		if (log_queue.count == 0 && !running) {
+			pthread_mutex_unlock(&log_queue.mutex);
+			logging_thread.thread_running = 0;
+			break;
+		}
+
+		char* message = log_queue.messages[log_queue.front];
+		log_queue.front = (log_queue.front + 1) % log_queue.size;
+		log_queue.count--;
+
+		pthread_mutex_unlock(&log_queue.mutex);
+
+		__log_msg(message);
+		free(message);
+	}
+
+	logging_thread.thread_running = 0;
+	return NULL;
+}
+
+void init_threaded_logging() {
+	pthread_attr_t attr;
+	struct sched_param param;
+	int retry, retval;
+	int retry_count = 3;
+
+	log_queue.size = config_log_buffer_size;
+	log_queue.messages = (char**)malloc(sizeof(char*) * log_queue.size);
+	if (log_queue.messages == NULL) {
+	    die ("Failed to allocate memory for log queue.\n");
+	}
+
+	log_queue.front = 0;
+	log_queue.rear = -1;
+	log_queue.count = 0;
+	log_queue.missed_logs = 0;
+	pthread_attr_init(&attr);
+	pthread_mutex_init(&log_queue.mutex, NULL);
+	pthread_cond_init(&log_queue.not_empty, NULL);
+
+	pthread_attr_setinheritsched(&attr, PTHREAD_EXPLICIT_SCHED);
+	pthread_attr_setschedpolicy(&attr, SCHED_OTHER);
+	pthread_attr_setschedparam(&attr, &param);
+
+	for (retry = 0; retry < retry_count; retry++) {
+		logging_thread.thread_running = 1;
+		retval = pthread_create(&logging_thread.thread, &attr, logging_main, NULL);
+		if (!retval) {
+			retval = pthread_setname_np(logging_thread.thread, "stalld-logging");
+			if (retval != 0) {
+				warn("Not able to set name for logging pthread error:%d", retval);
+			}
+			break;
+		}
+		if (retval != EAGAIN || retry == retry_count - 1) {
+			logging_thread.thread_running = 0;
+			cleanup_logging();
+			die("Failed to create logging thread\n");
+			break;
+		}
+	}
+}
+
 int main(int argc, char **argv)
 {
 	struct cpu_info *cpus;
@@ -2016,6 +2097,9 @@ int main(int argc, char **argv)
 
 	parse_args(argc, argv);
 
+	if (config_threaded_log)
+		init_threaded_logging();
+
 	find_sched_debug_path();
 
 	/*
@@ -2086,8 +2170,15 @@ int main(int argc, char **argv)
 
 	cleanup_regex(&nr_thread_ignore, &compiled_regex_thread);
 	cleanup_regex(&nr_process_ignore, &compiled_regex_process);
+
+	if (config_threaded_log){
+		if (join_thread(&logging_thread.thread) != 0) {
+			warn ("Failed to join logging thread.\n");
+		}
+		cleanup_logging();
+	}
+
 	if (config_log_syslog)
 		closelog();
-
 	exit(0);
 }
diff --git a/src/stalld.h b/src/stalld.h
index 1e22a58..cf03766 100644
--- a/src/stalld.h
+++ b/src/stalld.h
@@ -11,6 +11,7 @@
 
 #define BUFFER_PAGES		10
 #define MAX_WAITING_PIDS	30
+#define MAX_LOG_LENGTH		1015
 
 /*
  *workqueue worker names are now more verbose and needs
@@ -73,6 +74,23 @@ struct cpu_info {
        size_t buffer_size;
 };
 
+/* logging */
+struct log_queue {
+	char** messages;
+	int front;
+	int rear;
+	int count;
+	int size;
+	pthread_mutex_t mutex;
+	pthread_cond_t not_empty;
+	unsigned long missed_logs;
+};
+
+struct log_thread {
+	int thread_running;
+	pthread_t thread;
+};
+
 #ifdef __x86_64__
 # define __NR_sched_setattr 314
 # define __NR_sched_getattr 315
@@ -138,6 +156,7 @@ void __info(const char *fmt, ...);
 #define info(fmt, ...)	__info("%s: " fmt, __func__, ##__VA_ARGS__)
 
 void log_msg(const char *fmt, ...);
+void __log_msg(const char *msg);
 
 long get_long_from_str(char *start);
 long get_long_after_colon(char *start);
@@ -153,6 +172,7 @@ int parse_args(int argc, char **argv);
 int rt_throttling_is_off(void);
 int turn_off_rt_throttling(void);
 void cleanup_regex();
+void cleanup_logging();
 void find_sched_debug_path(void);
 
 /*
@@ -165,6 +185,10 @@ extern int config_write_kmesg;
 extern int config_log_syslog;
 extern int config_log_only;
 extern int config_foreground;
+extern int config_threaded_log;
+extern struct log_queue log_queue;
+extern struct log_thread logging_thread;
+extern unsigned long config_log_buffer_size;
 extern int config_ignore;
 extern unsigned long config_dl_period;
 extern unsigned long config_dl_runtime;
diff --git a/src/utils.c b/src/utils.c
index bfe178c..8d77998 100644
--- a/src/utils.c
+++ b/src/utils.c
@@ -89,6 +89,9 @@ static void inthandler (int signo, siginfo_t *info, void *extra)
 {
 	log_msg("received signal %d, starting shutdown\n", signo);
 	running = 0;
+	pthread_mutex_lock(&log_queue.mutex);
+	pthread_cond_signal(&log_queue.not_empty);
+	pthread_mutex_unlock(&log_queue.mutex);
 }
 
 static void set_sig_handler()
@@ -220,23 +223,12 @@ void __info(const char *fmt, ...)
 	}
 }
 
-
-
-void log_msg(const char *fmt, ...)
-{
+void __log_msg(const char *message) {
 	const char *log_prefix = "stalld: ";
-	char message[1024];
-	size_t bufsz;
+	const char *log;
 	int kmesg_fd;
-	va_list ap;
-	char *log;
 
-	strncpy(message, log_prefix, sizeof(message));
 	log = message + strlen(log_prefix);
-	bufsz = sizeof(message) - strlen(log_prefix);
-	va_start(ap, fmt);
-	vsnprintf(log, bufsz, fmt, ap);
-	va_end(ap);
 
 	/*
 	 * print the entire message (including PREFIX).
@@ -265,8 +257,55 @@ void log_msg(const char *fmt, ...)
 	 */
 	if (config_log_syslog)
 		syslog(LOG_INFO, "%s", log);
+}
+
+void log_msg(const char *fmt, ...)
+{
+	const char *log_prefix = "stalld: ";
+	char* message = NULL;
+	size_t bufsz, messagelen;
+	va_list ap;
+	char *log;
 
+	messagelen = sizeof(char) * MAX_LOG_LENGTH;
+	message = malloc(messagelen);
+	if (!message) {
+		warn("Malloc failed!");
+		return;
+	}
+
+	strncpy(message, log_prefix, messagelen);
+	log = message + strlen(log_prefix);
+	bufsz = messagelen - strlen(log_prefix);
+	va_start(ap, fmt);
+	vsnprintf(log, bufsz, fmt, ap);
+	va_end(ap);
+
+	if (config_threaded_log && logging_thread.thread_running) {
+		pthread_mutex_lock(&log_queue.mutex);
+		if (log_queue.count == log_queue.size) {
+			log_queue.missed_logs++;
+		} else {
+			log_queue.rear = (log_queue.rear + 1) % log_queue.size;
+			log_queue.messages[log_queue.rear] = message;
+			log_queue.count++;
+			pthread_cond_signal(&log_queue.not_empty);
+		}
+		pthread_mutex_unlock(&log_queue.mutex);
+	} else {
+		__log_msg(message);
+		free(message);
+	}
 }
+
+void cleanup_logging() {
+	pthread_mutex_destroy(&log_queue.mutex);
+	pthread_cond_destroy(&log_queue.not_empty);
+	if (log_queue.missed_logs)
+		log_msg("%lu logs dropped\n", log_queue.missed_logs);
+	free(log_queue.messages);
+}
+
 /*
  * Based on:
  * https://github.com/pasce/daemon-skeleton-linux-c
@@ -827,9 +866,11 @@ int parse_args(int argc, char **argv)
 		static struct option long_options[] = {
 			{"cpu",			required_argument, 0, 'c'},
 			{"log_only",		no_argument,	   0, 'l'},
+			{"threaded_logging",	no_argument,	   0, 'T'},
 			{"verbose",		no_argument,	   0, 'v'},
 			{"log_kmsg",		no_argument,	   0, 'k'},
 			{"log_syslog",		no_argument,	   0, 's'},
+			{"log_buffer_size",	required_argument, 0, 'b'},
 			{"foreground",		no_argument,	   0, 'f'},
 			{"aggressive_mode",	no_argument,	   0, 'A'},
 			{"power_mode",		no_argument,	   0, 'O'},
@@ -852,7 +893,7 @@ int parse_args(int argc, char **argv)
 		/* getopt_long stores the option index here. */
 		int option_index = 0;
 
-		c = getopt_long(argc, argv, "lvkfAOMhsp:r:d:t:c:FVSg:i:I:",
+		c = getopt_long(argc, argv, "lvkTfAOMhsb:p:r:d:t:c:FVSg:i:I:",
 				 long_options, &option_index);
 
 		/* Detect the end of the options. */
@@ -885,6 +926,11 @@ int parse_args(int argc, char **argv)
 		case 's':
 			config_log_syslog = 1;
 			break;
+		case 'T':
+			config_threaded_log = 1;
+			break;
+		case 'b':
+			config_log_buffer_size = get_long_from_str(optarg);
 		case 'f':
 			config_foreground = 1;
 			break;
-- 
2.23.3

