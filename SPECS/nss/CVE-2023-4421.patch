From c12635f9c2b9c7670a957f7ae152f21190d7e201 Mon Sep 17 00:00:00 2001
From: Shreenidhi Shedi <shreenidhi.shedi@broadcom.com>
Date: Sun, 14 Jan 2024 11:29:19 +0530
Subject: [PATCH] Origin:
 https://hg.mozilla.org/projects/nss/rev/fc05574c739947d615ab0b2b2b564f01c922eccd
 Origin:
 https://hg.mozilla.org/projects/nss/diff/3682d5ef3db54e9c02b5013dd1c3701df9a07985/lib/util/secport.h
 Author: Robert Relyea <rrelyea@redhat.com> Subject: New tlsfuzzer code can
 still detect timing issues in RSA operations

This patch defeats Bleichenbacher by not trying to hide the size of the
decrypted text, but to hide if the text succeeded for failed. This is done
by generating a fake returned text that's based on the key and the cipher text,
so the fake data is always the same for the same key and cipher text. Both the
length and the plain text are generated with a prf.

Here's the proposed spec the patch codes to:

    1. Use SHA-256 to hash the private exponent encoded as a big-endian
       integer to a string the same length as the public modulus. Keep this
       value secret. (this is just an optimisation so that the implementation
       doesn't have to serialise the key over and over again)
    2. Check the length of input according to step one of
       https://tools.ietf.org/html/rfc8017#section-7.2.2
    3. When provided with a ciphertext, use SHA-256 HMAC(key=hash_from_step1,
       text=ciphertext) to generate the key derivation key
    4. Use SHA-256 HMAC with key derivation key as the key and a two-byte
       big-endian iterator concatenated with byte string "length" with the
       big-endian representation of 2048 (0x0800) as the bit length of the
       generated string.
      - Iterate this PRF 8 times to generate a 256 byte string
    5. initialise the length of synthetic message to 0
    6. split the PRF output into 2 byte strings, convert into big-endian
       integers, zero-out high-order bits so that they have the same bit
       length as the octet length of the maximum acceptable message size
       (k-11), select the last integer that is no larger than (k-11) or remain
       at 0 if no integer is smaller than (k-11); this selection needs to be
       performed using a side-channel free operators
    7. Use SHA-256 HMAC with key derivation key as the key and a two-byte
       big-endian iterator concatenated with byte string "message" with the
       big-endian representation of k*8
      - use this PRF to generate k bytes of output (right-truncate last HMAC
        call if the number of generated bytes is not a multiple of SHA-256
        output size)
    8. perform the RSA decryption as described in step 2 of section 7.2.2 of rfc8017
    9. Verify the EM message padding as described in step 3 of section 7.2.2
       of rfc8017, but instead of outputting "decryption error", return the
       last l bytes of the "message" PRF, when l is the selected synthetic
       message length using the "length" PRF, make this decision and copy
       using side-channel free operation

[sshedi:
- took changes from debian and fixed hunk failures
https://packages.debian.org/buster/libnss3-tools
- Dropped test related changes
]
Signed-off-by: Shreenidhi Shedi <shreenidhi.shedi@broadcom.com>
---
 nss/lib/freebl/alghmac.c |  72 ++++++++--
 nss/lib/freebl/alghmac.h |   6 +
 nss/lib/freebl/rsapkcs.c | 276 +++++++++++++++++++++++++++++++++++----
 nss/lib/util/secport.h   |  65 +++++++++
 4 files changed, 378 insertions(+), 41 deletions(-)

diff --git a/nss/lib/freebl/alghmac.c b/nss/lib/freebl/alghmac.c
index dd8b73c..e879a2a 100644
--- a/nss/lib/freebl/alghmac.c
+++ b/nss/lib/freebl/alghmac.c
@@ -37,27 +37,20 @@ HMAC_Destroy(HMACContext *cx, PRBool freeit)
         PORT_Free(cx);
 }
 
-SECStatus
-HMAC_Init(HMACContext *cx, const SECHashObject *hash_obj,
-          const unsigned char *secret, unsigned int secret_len, PRBool isFIPS)
+/* just setup the hmac key */
+static SECStatus
+hmac_initKey(HMACContext *cx, const unsigned char *secret,
+             unsigned int secret_len, PRBool isFIPS)
 {
+
     unsigned int i;
     unsigned char hashed_secret[HASH_LENGTH_MAX];
 
     /* required by FIPS 198 Section 3 */
-    if (isFIPS && secret_len < hash_obj->length / 2) {
-        PORT_SetError(SEC_ERROR_INVALID_ARGS);
-        return SECFailure;
-    }
-    if (cx == NULL) {
+    if (isFIPS && secret_len < cx->hashobj->length / 2) {
         PORT_SetError(SEC_ERROR_INVALID_ARGS);
         return SECFailure;
     }
-    cx->wasAllocated = PR_FALSE;
-    cx->hashobj = hash_obj;
-    cx->hash = cx->hashobj->create();
-    if (cx->hash == NULL)
-        goto loser;
 
     if (secret_len > cx->hashobj->blocklength) {
         cx->hashobj->begin(cx->hash);
@@ -85,6 +78,31 @@ HMAC_Init(HMACContext *cx, const SECHashObject *hash_obj,
 
 loser:
     PORT_Memset(hashed_secret, 0, sizeof hashed_secret);
+    return SECFailure;
+}
+
+SECStatus
+HMAC_Init(HMACContext *cx, const SECHashObject *hash_obj,
+          const unsigned char *secret, unsigned int secret_len, PRBool isFIPS)
+{
+    SECStatus rv;
+
+    if (cx == NULL) {
+        PORT_SetError(SEC_ERROR_INVALID_ARGS);
+        return SECFailure;
+    }
+    cx->wasAllocated = PR_FALSE;
+    cx->hashobj = hash_obj;
+    cx->hash = cx->hashobj->create();
+    if (cx->hash == NULL)
+        goto loser;
+
+    rv = hmac_initKey(cx, secret, secret_len, isFIPS);
+    if (rv != SECSuccess)
+        goto loser;
+
+    return rv;
+loser:
     if (cx->hash != NULL)
         cx->hashobj->destroy(cx->hash, PR_TRUE);
     return SECFailure;
@@ -107,6 +125,34 @@ HMAC_Create(const SECHashObject *hash_obj, const unsigned char *secret,
     return cx;
 }
 
+/* this allows us to reuse an existing HMACContext with a new key and
+ * Hash function */
+SECStatus
+HMAC_ReInit(HMACContext *cx, const SECHashObject *hash_obj,
+            const unsigned char *secret, unsigned int secret_len, PRBool isFIPS)
+{
+    PRBool wasAllocated;
+    SECStatus rv;
+
+    /* if we are using the same hash, keep the hash contexts and only
+     * init the key */
+    if ((cx->hashobj == hash_obj) && (cx->hash != NULL)) {
+        return hmac_initKey(cx, secret, secret_len, isFIPS);
+    }
+    /* otherwise we destroy the contents of the context and
+     * initalize it from scratch. We need to preseve the current state
+     * of wasAllocated to the final destroy works correctly */
+    wasAllocated = cx->wasAllocated;
+    cx->wasAllocated = PR_FALSE;
+    HMAC_Destroy(cx, PR_FALSE);
+    rv = HMAC_Init(cx, hash_obj, secret, secret_len, isFIPS);
+    if (rv != SECSuccess) {
+        return rv;
+    }
+    cx->wasAllocated = wasAllocated;
+    return SECSuccess;
+}
+
 void
 HMAC_Begin(HMACContext *cx)
 {
diff --git a/nss/lib/freebl/alghmac.h b/nss/lib/freebl/alghmac.h
index 462526a..0e0d66a 100644
--- a/nss/lib/freebl/alghmac.h
+++ b/nss/lib/freebl/alghmac.h
@@ -30,6 +30,12 @@ SECStatus
 HMAC_Init(HMACContext *cx, const SECHashObject *hash_obj,
           const unsigned char *secret, unsigned int secret_len, PRBool isFIPS);
 
+/* like HMAC_Init, except caller passes in an existing context
+ * previously used by either HMAC_Create or HMAC_Init. */
+SECStatus
+HMAC_ReInit(HMACContext *cx, const SECHashObject *hash_obj,
+            const unsigned char *secret, unsigned int secret_len, PRBool isFIPS);
+
 /* reset HMAC for a fresh round */
 extern void
 HMAC_Begin(HMACContext *cx);
diff --git a/nss/lib/freebl/rsapkcs.c b/nss/lib/freebl/rsapkcs.c
index 875e4e2..48c3330 100644
--- a/nss/lib/freebl/rsapkcs.c
+++ b/nss/lib/freebl/rsapkcs.c
@@ -929,7 +929,161 @@ failure:
     return SECFailure;
 }
 
-/* XXX Doesn't set error code */
+static HMACContext *
+rsa_GetHMACContext(const SECHashObject *hash, RSAPrivateKey *key,
+                   const unsigned char *input, unsigned int inputLen)
+{
+    unsigned char keyHash[HASH_LENGTH_MAX];
+    void *hashContext;
+    HMACContext *hmac = NULL;
+    unsigned int privKeyLen = key->privateExponent.len;
+    unsigned int keyLen;
+    SECStatus rv;
+
+    /* first get the key hash (should store in the key structure) */
+    PORT_Memset(keyHash, 0, sizeof(keyHash));
+    hashContext = (*hash->create)();
+    if (hashContext == NULL) {
+        return NULL;
+    }
+    (*hash->begin)(hashContext);
+    if (privKeyLen < inputLen) {
+        int padLen = inputLen - privKeyLen;
+        while (padLen > sizeof(keyHash)) {
+            (*hash->update)(hashContext, keyHash, sizeof(keyHash));
+            padLen -= sizeof(keyHash);
+        }
+        (*hash->update)(hashContext, keyHash, padLen);
+    }
+    (*hash->update)(hashContext, key->privateExponent.data, privKeyLen);
+    (*hash->end)(hashContext, keyHash, &keyLen, sizeof(keyHash));
+    (*hash->destroy)(hashContext, PR_TRUE);
+
+    /* now create the hmac key */
+    hmac = HMAC_Create(hash, keyHash, keyLen, PR_TRUE);
+    if (hmac == NULL) {
+        PORT_Memset(keyHash, 0, sizeof(keyHash));
+        return NULL;
+    }
+    HMAC_Begin(hmac);
+    HMAC_Update(hmac, input, inputLen);
+    rv = HMAC_Finish(hmac, keyHash, &keyLen, sizeof(keyHash));
+    if (rv != SECSuccess) {
+        PORT_Memset(keyHash, 0, sizeof(keyHash));
+        HMAC_Destroy(hmac, PR_TRUE);
+        return NULL;
+    }
+    /* Finally set the new key into the hash context. We
+     * reuse the original context allocated above so we don't
+     * need to allocate and free another one */
+    rv = HMAC_ReInit(hmac, hash, keyHash, keyLen, PR_TRUE);
+    PORT_Memset(keyHash, 0, sizeof(keyHash));
+    if (rv != SECSuccess) {
+        HMAC_Destroy(hmac, PR_TRUE);
+        return NULL;
+    }
+
+    return hmac;
+}
+
+static SECStatus
+rsa_HMACPrf(HMACContext *hmac, const char *label, int labelLen,
+            int hashLength, unsigned char *output, int length)
+{
+    unsigned char iterator[2] = { 0, 0 };
+    unsigned char encodedLen[2] = { 0, 0 };
+    unsigned char hmacLast[HASH_LENGTH_MAX];
+    unsigned int left = length;
+    unsigned int hashReturn;
+    SECStatus rv = SECSuccess;
+
+    /* encodedLen is in bits, length is in bytes, thus the shifts
+     * do an implied multiply by 8 */
+    encodedLen[0] = (length >> 5) & 0xff;
+    encodedLen[1] = (length << 3) & 0xff;
+
+    while (left > hashLength) {
+        HMAC_Begin(hmac);
+        HMAC_Update(hmac, iterator, 2);
+        HMAC_Update(hmac, (const unsigned char *)label, labelLen);
+        HMAC_Update(hmac, encodedLen, 2);
+        rv = HMAC_Finish(hmac, output, &hashReturn, hashLength);
+        if (rv != SECSuccess) {
+            return rv;
+        }
+        iterator[1]++;
+        if (iterator[1] == 0)
+            iterator[0]++;
+        left -= hashLength;
+        output += hashLength;
+    }
+    if (left) {
+        HMAC_Begin(hmac);
+        HMAC_Update(hmac, iterator, 2);
+        HMAC_Update(hmac, (const unsigned char *)label, labelLen);
+        HMAC_Update(hmac, encodedLen, 2);
+        rv = HMAC_Finish(hmac, hmacLast, &hashReturn, sizeof(hmacLast));
+        if (rv != SECSuccess) {
+            return rv;
+        }
+        PORT_Memcpy(output, hmacLast, left);
+        PORT_Memset(hmacLast, 0, sizeof(hmacLast));
+    }
+    return rv;
+}
+
+/* This function takes an input number and
+ * creates the smallest mask which covers
+ * the whole number. Examples:
+ *     0x81 -> 0xff
+ *     0x1af -> 0x1ff
+ *     0x4d1 -> 0x7ff
+ */
+static int
+makeMask16(int len)
+{
+    // or the high bit in each bit location
+    len |= (len >> 1);
+    len |= (len >> 2);
+    len |= (len >> 4);
+    len |= (len >> 8);
+    return len;
+}
+
+#define STRING_AND_LENGTH(s) s, sizeof(s) - 1
+static int
+rsa_GetErrorLength(HMACContext *hmac, int hashLen, int maxLegalLen)
+{
+    unsigned char out[128 * 2];
+    unsigned char *outp;
+    int outLength = 0;
+    int lengthMask;
+    SECStatus rv;
+
+    lengthMask = makeMask16(maxLegalLen);
+    rv = rsa_HMACPrf(hmac, STRING_AND_LENGTH("length"), hashLen,
+                     out, sizeof(out));
+    if (rv != SECSuccess) {
+        return -1;
+    }
+    for (outp = out; outp < out + sizeof(out); outp += 2) {
+        int candidate = outp[0] << 8 | outp[1];
+        candidate = candidate & lengthMask;
+        outLength = PORT_CT_SEL(PORT_CT_LT(candidate, maxLegalLen),
+                                candidate, outLength);
+    }
+    PORT_Memset(out, 0, sizeof(out));
+    return outLength;
+}
+
+/*
+ * This function can only fail in environmental cases: Programming errors
+ * and out of memory situations. It can't fail if the keys are valid and
+ * the inputs are the proper size. If the actual RSA decryption fails, then
+ * and generated return value is returned based on the key and input.
+ * Applications are expected to detect decryption failures based on the fact
+ * that the decrypted value (usually a key) doesn't validate. The prevents
+ * Blecheinbaucher style attacks against the key. */
 SECStatus
 RSA_DecryptBlock(RSAPrivateKey *key,
                  unsigned char *output,
@@ -938,56 +1092,122 @@ RSA_DecryptBlock(RSAPrivateKey *key,
                  const unsigned char *input,
                  unsigned int inputLen)
 {
-    PRInt8 rv;
+    SECStatus rv;
+    PRUint32 fail;
     unsigned int modulusLen = rsa_modulusLen(&key->modulus);
     unsigned int i;
     unsigned char *buffer = NULL;
-    unsigned int outLen = 0;
-    unsigned int copyOutLen = modulusLen - 11;
-
+    unsigned char *errorBuffer = NULL;
+    unsigned char *bp = NULL;
+    unsigned char *ep = NULL;
+    unsigned int outLen = modulusLen;
+    unsigned int maxLegalLen = modulusLen - 10;
+    unsigned int errorLength;
+    const SECHashObject *hashObj;
+    HMACContext *hmac = NULL;
+
+    /* failures in the top section indicate failures in the environment
+     * (memory) or the library. OK to return errors in these cases because
+     * it doesn't provide any oracle information to attackers. */
     if (inputLen != modulusLen || modulusLen < 10) {
+        PORT_SetError(SEC_ERROR_INVALID_ARGS);
         return SECFailure;
     }
 
-    if (copyOutLen > maxOutputLen) {
-        copyOutLen = maxOutputLen;
+    /* Allocate enough space to decrypt */
+    buffer = PORT_ZAlloc(modulusLen);
+    if (!buffer) {
+        goto loser;
+    }
+    errorBuffer = PORT_ZAlloc(modulusLen);
+    if (!errorBuffer) {
+        goto loser;
+    }
+    hashObj = HASH_GetRawHashObject(HASH_AlgSHA256);
+    if (hashObj == NULL) {
+        goto loser;
     }
 
-    // Allocate enough space to decrypt + copyOutLen to allow copying outLen later.
-    buffer = PORT_ZAlloc(modulusLen + 1 + copyOutLen);
-    if (!buffer) {
-        return SECFailure;
+    /* calculate the values to return in the error case rather than
+     * the actual returned values. This data is the same for the
+     * same input and private key. */
+    hmac = rsa_GetHMACContext(hashObj, key, input, inputLen);
+    if (hmac == NULL) {
+        goto loser;
+    }
+    errorLength = rsa_GetErrorLength(hmac, hashObj->length, maxLegalLen);
+    if (((int)errorLength) < 0) {
+        goto loser;
+    }
+    /* we always have to generate a full moduluslen error string. Otherwise
+     * we create a timing dependency on errorLength, which could be used to
+     * determine the difference between errorLength and outputLen and tell
+     * us that there was a pkcs1 decryption failure */
+    rv = rsa_HMACPrf(hmac, STRING_AND_LENGTH("message"),
+                     hashObj->length, errorBuffer, modulusLen);
+    if (rv != SECSuccess) {
+        goto loser;
     }
 
-    // rv is 0 if everything is going well and 1 if an error occurs.
-    rv = RSA_PrivateKeyOp(key, buffer, input) != SECSuccess;
-    rv |= (buffer[0] != RSA_BLOCK_FIRST_OCTET) |
-          (buffer[1] != (unsigned char)RSA_BlockPublic);
+    HMAC_Destroy(hmac, PR_TRUE);
+    hmac = NULL;
+
+    /* From here on out, we will always return success. If there is
+     * an error, we will return deterministic output based on the key
+     * and the input data. */
+    rv = RSA_PrivateKeyOp(key, buffer, input);
+
+    fail = PORT_CT_NE(rv, SECSuccess);
+    fail |= PORT_CT_NE(buffer[0], RSA_BLOCK_FIRST_OCTET) | PORT_CT_NE(buffer[1], RSA_BlockPublic);
 
-    // There have to be at least 8 bytes of padding.
+    /* There have to be at least 8 bytes of padding. */
     for (i = 2; i < 10; i++) {
-        rv |= buffer[i] == RSA_BLOCK_AFTER_PAD_OCTET;
+        fail |= PORT_CT_EQ(buffer[i], RSA_BLOCK_AFTER_PAD_OCTET);
     }
 
     for (i = 10; i < modulusLen; i++) {
         unsigned int newLen = modulusLen - i - 1;
-        unsigned int c = (buffer[i] == RSA_BLOCK_AFTER_PAD_OCTET) & (outLen == 0);
-        outLen = constantTimeCondition(c, newLen, outLen);
+        PRUint32 condition = PORT_CT_EQ(buffer[i], RSA_BLOCK_AFTER_PAD_OCTET) & PORT_CT_EQ(outLen, modulusLen);
+        outLen = PORT_CT_SEL(condition, newLen, outLen);
+    }
+    // this can only happen if a zero wasn't found above
+    fail |= PORT_CT_GE(outLen, modulusLen);
+
+    outLen = PORT_CT_SEL(fail, errorLength, outLen);
+
+    /* index into the correct buffer. Do it before we truncate outLen if the
+     * application was asking for less data than we can return */
+    bp = buffer + modulusLen - outLen;
+    ep = errorBuffer + modulusLen - outLen;
+
+    /* at this point, outLen returns no information about decryption failures,
+     * no need to hide it's value. maxOutputLen is how much data the
+     * application is expecting, which is also not sensitive. */
+    if (outLen > maxOutputLen) {
+        outLen = maxOutputLen;
     }
-    rv |= outLen == 0;
-    rv |= outLen > maxOutputLen;
 
-    // Note that output is set even if SECFailure is returned.
-    PORT_Memcpy(output, buffer + modulusLen - outLen, copyOutLen);
-    *outputLen = constantTimeCondition(outLen > maxOutputLen, maxOutputLen,
-                                       outLen);
+    /* we can't use PORT_Memcpy because caching could create a time dependency
+     * on the status of fail. */
+    for (i = 0; i < outLen; i++) {
+        output[i] = PORT_CT_SEL(fail, ep[i], bp[i]);
+    }
+
+    *outputLen = outLen;
 
     PORT_Free(buffer);
+    PORT_Free(errorBuffer);
+
+    return SECSuccess;
 
-    for (i = 1; i < sizeof(rv) * 8; i <<= 1) {
-        rv |= rv << i;
+loser:
+    if (hmac) {
+        HMAC_Destroy(hmac, PR_TRUE);
     }
-    return (SECStatus)rv;
+    PORT_Free(buffer);
+    PORT_Free(errorBuffer);
+
+    return SECFailure;
 }
 
 /*
diff --git a/nss/lib/util/secport.h b/nss/lib/util/secport.h
index f1665a2..865bd6e 100644
--- a/nss/lib/util/secport.h
+++ b/nss/lib/util/secport.h
@@ -291,4 +291,69 @@ PORT_LoadLibraryFromOrigin(const char *existingShLibName,
 
 SEC_END_PROTOS
 
+/*
+ * Constant time macros
+ */
+/* These macros use the fact that arithmetic shift shifts-in the sign bit.
+ * However, this is not ensured by the C standard so you may need to replace
+ * them with something else for odd compilers. These macros work for object
+ * sizes up to 32 bits. The inequalities will produce incorrect results if
+ * abs(a-b) >= PR_UINT32_MAX/2. This can be a voided if unsigned values stay
+ * within the range 0-PRUINT32_MAX/2 and signed values stay within the range
+ * -PRINT32_MAX/2-PRINT32_MAX/2. If these are insufficient, we can fix
+ * this by either expanding the PORT_CT_DUPLICATE_MSB_TO_ALL to PRUint64
+ * or by creating the following new macros for inequality:
+ *
+ * PORT_CT_OVERFLOW prevents the overflow condition by handling the case
+ * where the high bits in a and b are different specially. Basically if
+ * the high bit in a and b differs we can just
+ * copy the high bit of one of the parameters to determine the result as
+ * follows:
+ *    GxU if a has the high bit on, a>b, so d=a
+ *    LxU if b has the high bit on, a<b, so d=b
+ *    GxS if b has the high bit on, it's negative a>b so d=b
+ *    LxS if a has the high bit on, it's negative a<b so d=a
+ * where PORT_CT_xxU() macros do unsigned compares and PORT_CT_xxS() do signed
+ * compares.
+ *
+ * #define PORT_CT_OVERFLOW(a,b,c,d) \
+ *       PORT_CT_SEL(PORT_CT_DUPLICATE_MSB_TO_ALL((a)^(b)), \
+ *                  (PORT_CT_DUPLICATE_MSB_TO_ALL(d)),c)
+ * #define PORT_CT_GTU(a,b) PORT_CT_OVERFLOW(a,b,PORT_CT_GT(a,b),a)
+ * #define PORT_CT_LTU(a,b) PORT_CT_OVERFLOW(a,b,PORT_CT_LT(a,b),b)
+ * #define PORT_CT_GEU(a,b) PORT_CT_OVERFLOW(a,b,PORT_CT_GE(a,b),a)
+ * #define PORT_CT_LEU(a,b) PORT_CT_OVERFLOW(a,b,PORT_CT_LE(a,b),b)
+ * #define PORT_CT_GTS(a,b) PORT_CT_OVERFLOW(a,b,PORT_CT_GT(a,b),b)
+ * #define PORT_CT_LTS(a,b) PORT_CT_OVERFLOW(a,b,PORT_CT_LT(a,b),a)
+ * #define PORT_CT_GES(a,b) PORT_CT_OVERFLOW(a,b,PORT_CT_GE(a,b),b)
+ * #define PORT_CT_LES(a,b) PORT_CT_OVERFLOW(a,b,PORT_CT_LE(a,b),a)
+ *
+ *
+ * */
+/* Constant-time helper macro that copies the MSB of x to all other bits. */
+#define PORT_CT_DUPLICATE_MSB_TO_ALL(x) ((PRUint32)((PRInt32)(x) >> (sizeof(PRInt32) * 8 - 1)))
+
+/* Constant-time helper macro that selects l or r depending on all-1 or all-0
+ * mask m */
+#define PORT_CT_SEL(m, l, r) (((m) & (l)) | (~(m) & (r)))
+
+/* Constant-time helper macro that returns all-1s if x is not 0; and all-0s
+ * otherwise. */
+#define PORT_CT_NOT_ZERO(x) (PORT_CT_DUPLICATE_MSB_TO_ALL(((x) | (0 - (x)))))
+
+/* Constant-time helper macro that returns all-1s if x is 0; and all-0s
+ * otherwise. */
+#define PORT_CT_ZERO(x) (~PORT_CT_DUPLICATE_MSB_TO_ALL(((x) | (0 - (x)))))
+
+/* Constant-time helper macro for equalities and inequalities.
+ * returns all-1's for true and all-0's for false */
+#define PORT_CT_EQ(a, b) PORT_CT_ZERO(((a) - (b)))
+#define PORT_CT_NE(a, b) PORT_CT_NOT_ZERO(((a) - (b)))
+#define PORT_CT_GT(a, b) PORT_CT_DUPLICATE_MSB_TO_ALL((b) - (a))
+#define PORT_CT_LT(a, b) PORT_CT_DUPLICATE_MSB_TO_ALL((a) - (b))
+#define PORT_CT_GE(a, b) (~PORT_CT_LT(a, b))
+#define PORT_CT_LE(a, b) (~PORT_CT_GT(a, b))
+#define PORT_CT_TRUE (~0)
+#define PORT_CT_FALSE 0
+
 #endif /* _SECPORT_H_ */
-- 
2.25.1

