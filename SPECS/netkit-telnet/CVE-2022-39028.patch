This is caused by a crash by a NULL pointer dereference when sending
the byte sequences «0xff 0xf7» or «0xff 0xf8».

Found-by: Pierre Kim and Alexandre Torres
Patch-adapted-by: Erik Auerswald <auerswal@unix-ag.uni-kl.de>

---
 ChangeLog       |  8 ++++++++
 telnetd/state.c | 12 +++++++++---
 2 files changed, 17 insertions(+), 3 deletions(-)

diff --git a/ChangeLog b/ChangeLog
index 7ef5e3e..41b3fed 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,3 +1,11 @@
+28-Aug-2022:
+  * Fix remote DoS vulnerability in inetutils-telnetd, caused by a crash by
+    a NULL pointer dereference when sending the byte sequences «0xff 0xf7»
+    or «0xff 0xf8». Found by Pierre Kim and Alexandre Torres. Patch
+    adapted by Erik Auerswald <auerswal@unix-ag.uni-kl.de>.
+
+ -- Guillem Jover <guillem@debian.org>  Sun, 28 Aug 2022 14:51:13 +0200
+
 22-Jul-2000:
 	Bug fixes for environment processing from Olaf Kirch. Also fixes
 	  privacy issue noticed by Steve Bellovin. Also fix a wrong 
diff --git a/telnetd/state.c b/telnetd/state.c
index b757411..545b09c 100644
--- a/telnetd/state.c
+++ b/telnetd/state.c
@@ -205,12 +205,18 @@ void telrcv(void) {
 	      case EC:
 	      case EL:
 		 {
-		     cc_t ch;
+		     cc_t ch = (cc_t) (_POSIX_VDISABLE);
 		     DIAG(TD_OPTIONS, printoption("td: recv IAC", c));
 		     ptyflush();	/* half-hearted */
 		     init_termbuf();
-		     if (c == EC) ch = *slctab[SLC_EC].sptr;
-		     else ch = *slctab[SLC_EL].sptr;
+		     if (c == EC) {
+                         if (slctab[SLC_EC].sptr)
+                              ch = *slctab[SLC_EC].sptr;
+                     }
+		     else {
+                         if (slctab[SLC_EL].sptr)
+                              ch = *slctab[SLC_EL].sptr;
+                     }
 		     if (ch != (cc_t)(_POSIX_VDISABLE))
 			 *pfrontp++ = (unsigned char)ch;
 		     break;
-- 
2.35.6

