From e3568ef53310f91e7ff2a00a9dea1109fd3c190c Mon Sep 17 00:00:00 2001
From: Weihang Lo <me@weihanglo.tw>
Date: Fri, 7 Jul 2023 14:50:59 +0100
Subject: [PATCH 1/2] fix: respect `umask` when unpacking `.crate` files

Without this, an attacker can upload globally writable files buried
in the `.crate` file. After a user downloaded and unpacked the file,
the attacker can then write malicous code to the downloaded sources.
---
 Cargo.lock                                    |  4 ++--
 src/tools/cargo/Cargo.toml                    |  2 +-
 src/tools/cargo/src/cargo/lib.rs              |  1 +
 .../cargo/src/cargo/sources/registry/mod.rs   | 16 ++++++++++++++++
 src/tools/cargo/src/cargo/util/mod.rs         | 19 +++++++++++++++++++
 5 files changed, 39 insertions(+), 3 deletions(-)

diff --git a/Cargo.lock b/Cargo.lock
index 48d9fdb3d..717ec181c 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -5135,9 +5135,9 @@ dependencies = [
 
 [[package]]
 name = "tar"
-version = "0.4.37"
+version = "0.4.39"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "d6f5515d3add52e0bbdcad7b83c388bb36ba7b754dda3b5f5bc2d38640cdba5c"
+checksum = "ec96d2ffad078296368d46ff1cb309be1c23c513b4ab0e22a45de0185275ac96"
 dependencies = [
  "filetime",
  "libc",
diff --git a/src/tools/cargo/Cargo.toml b/src/tools/cargo/Cargo.toml
index e23f4ec06..475839b62 100644
--- a/src/tools/cargo/Cargo.toml
+++ b/src/tools/cargo/Cargo.toml
@@ -54,7 +54,7 @@ serde_ignored = "0.1.0"
 serde_json = { version = "1.0.30", features = ["raw_value"] }
 shell-escape = "0.1.4"
 strip-ansi-escapes = "0.1.0"
-tar = { version = "0.4.35", default-features = false }
+tar = { version = "0.4.39", default-features = false }
 tempfile = "3.0"
 termcolor = "1.1"
 toml = "0.5.7"
diff --git a/src/tools/cargo/src/cargo/lib.rs b/src/tools/cargo/src/cargo/lib.rs
index 04d6d0a94..9500e3a68 100644
--- a/src/tools/cargo/src/cargo/lib.rs
+++ b/src/tools/cargo/src/cargo/lib.rs
@@ -7,6 +7,7 @@
 #![allow(clippy::all)]
 #![warn(clippy::needless_borrow)]
 #![warn(clippy::redundant_clone)]
+#![feature(once_cell)]
 
 use crate::core::shell::Verbosity::Verbose;
 use crate::core::Shell;
diff --git a/src/tools/cargo/src/cargo/sources/registry/mod.rs b/src/tools/cargo/src/cargo/sources/registry/mod.rs
index d9df11bbf..ea1bc3073 100644
--- a/src/tools/cargo/src/cargo/sources/registry/mod.rs
+++ b/src/tools/cargo/src/cargo/sources/registry/mod.rs
@@ -162,6 +162,8 @@ use std::borrow::Cow;
 use std::collections::BTreeMap;
 use std::collections::HashSet;
 use std::fs::{File, OpenOptions};
+use std::io;
+use std::io::Read;
 use std::io::Write;
 use std::path::{Path, PathBuf};
 
@@ -600,6 +602,7 @@ impl<'cfg> RegistrySource<'cfg> {
         }
         let gz = GzDecoder::new(tarball);
         let mut tar = Archive::new(gz);
+        set_mask(&mut tar);
         let prefix = unpack_dir.file_name().unwrap();
         let parent = unpack_dir.parent().unwrap();
         for entry in tar.entries()? {
@@ -791,3 +794,16 @@ impl<'cfg> Source for RegistrySource<'cfg> {
         self.index.is_yanked(pkg, &mut *self.ops)
     }
 }
+
+/// Set the current [`umask`] value for the given tarball. No-op on non-Unix
+/// platforms.
+///
+/// On Windows, tar only looks at user permissions and tries to set the "read
+/// only" attribute, so no-op as well.
+///
+/// [`umask`]: https://man7.org/linux/man-pages/man2/umask.2.html
+#[allow(unused_variables)]
+fn set_mask<R: Read>(tar: &mut Archive<R>) {
+    #[cfg(unix)]
+    tar.set_mask(crate::util::get_umask());
+}
diff --git a/src/tools/cargo/src/cargo/util/mod.rs b/src/tools/cargo/src/cargo/util/mod.rs
index 4b8604f92..c5de17120 100644
--- a/src/tools/cargo/src/cargo/util/mod.rs
+++ b/src/tools/cargo/src/cargo/util/mod.rs
@@ -107,3 +107,22 @@ pub fn indented_lines(text: &str) -> String {
         })
         .collect()
 }
+
+/// Get the current [`umask`] value.
+///
+/// [`umask`]: https://man7.org/linux/man-pages/man2/umask.2.html
+#[cfg(unix)]
+pub fn get_umask() -> u32 {
+    use std::lazy::SyncOnceCell;
+    static UMASK: SyncOnceCell<libc::mode_t> = SyncOnceCell::new();
+    // SAFETY: Syscalls are unsafe. Calling `umask` twice is even unsafer for
+    // multithreading program, since it doesn't provide a way to retrive the
+    // value without modifications. We use a static `SyncOnceCell` here to ensure
+    // it only gets call once during the entire program lifetime.
+    *UMASK.get_or_init(|| unsafe {
+        let umask = libc::umask(0o022);
+        libc::umask(umask);
+        umask
+    }) as u32 // it is u16 on macos
+}
+
-- 
2.35.6

