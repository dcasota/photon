From 54e812100df2a6f1d75fbef4e3b45c076599842f Mon Sep 17 00:00:00 2001
From: Florian Weimer <fweimer@redhat.com>
Date: Fri, 21 Jul 2023 16:18:18 +0200
Subject: [PATCH 138/175] nptl: Unconditionally use a 32-byte rseq area

If the kernel headers provide a larger struct rseq, we used that
size as the argument to the rseq system call.  As a result,
rseq registration would fail on older kernels which only accept
size 32.

(cherry picked from commit 2c6b4b272e6b4d07303af25709051c3e96288f2d)
---
 nptl/descr.h | 18 ++++++++++++++----
 1 file changed, 14 insertions(+), 4 deletions(-)

diff --git a/nptl/descr.h b/nptl/descr.h
index 70cf4b639a3437138f2f67c48df006e62cab568c..ff634dac331057d45fee5452177171268e3934f9 100644
--- a/nptl/descr.h
+++ b/nptl/descr.h
@@ -34,7 +34,6 @@
 #include <bits/types/res_state.h>
 #include <kernel-features.h>
 #include <tls-internal-struct.h>
-#include <sys/rseq.h>
 #include <internal-sigset.h>
 
 #ifndef TCB_ALIGNMENT
@@ -402,14 +401,25 @@ struct pthread
   /* Used on strsignal.  */
   struct tls_internal_t tls_state;
 
-  /* rseq area registered with the kernel.  */
-  struct rseq rseq_area;
+  /* rseq area registered with the kernel.  Use a custom definition
+     here to isolate from kernel struct rseq changes.  The
+     implementation of sched_getcpu needs acccess to the cpu_id field;
+     the other fields are unused and not included here.  */
+  union
+  {
+    struct
+    {
+      uint32_t cpu_id_start;
+      uint32_t cpu_id;
+    };
+    char pad[32];		/* Original rseq area size.  */
+  } rseq_area __attribute__ ((aligned (32)));
 
   /* Amount of end padding, if any, in this structure.
      This definition relies on rseq_area being last.  */
 #define PTHREAD_STRUCT_END_PADDING \
   (sizeof (struct pthread) - offsetof (struct pthread, rseq_area) \
-   + sizeof (struct rseq))
+   + sizeof ((struct pthread) {}.rseq_area))
 } __attribute ((aligned (TCB_ALIGNMENT)));
 
 static inline bool
-- 
2.35.6

